<ServerManagerConfiguration>
  <ProxyGroup name="internal_filters">
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPProbeFilter"
                 name="ProbeLine">
      <Documentation>Internal filter used by (filters, ProbeLine). The Plot
      Over Line filter samples the data set attributes of the current data set
      at the points along a line. The values of the point-centered variables
      along that line will be displayed in an XY Plot. This filter uses
      interpolation to determine the values at the selected point, whether or
      not it lies at an input point. The Probe filter operates on any type of
      data and produces polygonal output (a line).</Documentation>
      <InputProperty command="SetSourceConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>This property specifies the dataset from which to obtain
        probe values.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     label="Probe Type"
                     name="Source"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources"
                 name="HighResLineSource" />
        </ProxyListDomain>
        <Documentation>This property specifies the dataset whose geometry will
        be used in determining positions to probe.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPassPartialArrays"
                         default_values="1"
                         name="PassPartialArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>When dealing with composite datasets, partial arrays are
        common i.e. data-arrays that are not available in all of the blocks. By
        default, this filter only passes those point and cell data-arrays that
        are available in all the blocks i.e. partial array are removed. When
        PassPartialArrays is turned on, this behavior is changed to take a
        union of all arrays present thus partial arrays are passed as well.
        However, for composite dataset input, this filter still produces a
        non-composite output. For all those locations in a block of where a
        particular data array is missing, this filter uses vtkMath::Nan() for
        double and float arrays, while 0 for all other types of arrays i.e int,
        char etc.</Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetPassCellArrays"
                         default_values="0"
                         name="PassCellArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        When set the input's cell data arrays are shallow copied to the output.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetPassPointArrays"
                         default_values="0"
                         name="PassPointArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        When set the input's point data arrays are shallow copied to the output.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty command="SetPassFieldArrays"
                         default_values="1"
                         name="PassFieldArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to pass the field-data arrays from the Input i.e. the input
        providing the geometry to the output. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty command="SetComputeTolerance"
                         default_values="1"
                         name="ComputeTolerance"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to compute the tolerance or to use a user provided
        value. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <DoubleVectorProperty command="SetTolerance"
                            default_values="2.2204460492503131e-16"
                            name="Tolerance"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain min="2.2204460492503131e-16"
                           name="range" />
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="ComputeTolerance" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
        <Documentation>Set the tolerance to use for
        vtkDataSet::FindCell</Documentation>
      </DoubleVectorProperty>
      <!-- End ProbeLine -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractSelectionRange"
                 label="Extract Selection Range (internal)"
                 name="ExtractSelectionRange">
      <Documentation>
        This filter extracts the range of a given set of cells or points given
        a selection. The selection can be obtained from a rubber-band selection
        (either point, cell, visible or in a frustum) and passed to the filter or
        specified by providing an ID list. This is an internal filter.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>
          The input from which the selection is
          extracted.
        </Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="Selection"
                     port_index="1">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkSelection" />
        </DataTypeDomain>
        <Documentation>
          The input that provides the selection
          object.
        </Documentation>
      </InputProperty>
      <StringVectorProperty command="SetArrayName"
                            name="ArrayName"
                            number_of_elements="1">
        <Documentation>
          This property indicates the name of the scalar array
          used to compute the range.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetFieldType"
                         default_values="0"
                         is_internal="1"
                         name="FieldType"
                         number_of_elements="1">
        <Documentation>
          Set the field type of the selection.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetComponent"
                         default_values="0"
                         is_internal="1"
                         name="Component"
                         number_of_elements="1">
        <Documentation>
          Select the component of the selection.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="GetRange"
                            default_values="0 0"
                            information_only="1"
                            name="Range"
                            number_of_elements="2">
      </DoubleVectorProperty>
      <!-- End ExtractSelectionRange -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPassThrough"
                 name="PipelineConnection"
                 label="Pipeline Connection">
      <Documentation>
        This proxy provides UI for selecting an existing pipeline connection.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     panel_widget="input_selector"
                     null_on_empty="1"
                     panel_visibility="always">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
      </InputProperty>
      <IntVectorProperty command="SetAllowNullInput"
                         name="AllowNullInput"
                         default_values="1"
                         number_of_elements="1"
                         panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>
          Allow the filter to execute successful, producing an empty polydata,
          when the input is not specified.
        </Documentation>
      </IntVectorProperty>
      <!-- End PipelineConnection -->
    </SourceProxy>
    <!-- End of internal_filters -->
  </ProxyGroup>
  <ProxyGroup name="filters">
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAppendArcLength"
                 label="Append Arc-Length"
                 name="AppendArcLength">
      <Documentation long_help="Appends Arc length for input poly lines."
                     short_help="Appends Arc length for input poly lines.">
                     vtkAppendArcLength is used for filter such as
                     plot-over-line. In such cases, we need to add an attribute
                     array that is the arc_length over the length of the probed
                     line. That's when vtkAppendArcLength can be used. It adds
                     a new point-data array named "arc_length" with the
                     computed arc length for each of the polylines in the
                     input. For all other cell types, the arc length is set to
                     0.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>The input.</Documentation>
      </InputProperty>
      <!-- End of AppendArcLength -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPassThrough" label="Pass Through" name="PassThrough">
      <Documentation>
        A simple pass-through filter that doesn't transform data in any way.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the filter.</Documentation>
      </InputProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAdditionalFieldReader"
                 label="Add Field Arrays"
                 name="AddFieldArrays">
      <Documentation long_help="Reads arrays from a file and adds them to the input data object."
                     short_help="Adds arrays to a data object.">
                     Takes in an input data object and a filename. Opens the file
                     and adds any arrays it sees there to the input data.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
                <Documentation>The input.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetFileName"
                            name="FileName"
                            number_of_elements="1"
                            panel_visibility="always">
        <FileListDomain name="files" />
        <Documentation>
          This property specifies the file to read to get arrays
        </Documentation>
      </StringVectorProperty>
      <Property command="Modified"
                label="Reload"
                name="Reload"
                panel_widget="command_button"
                panel_visibility="always">
        <Documentation> A convenient way to reload the data file </Documentation>
      </Property>
    </SourceProxy>
    <!-- End of AdditionalFieldReader -->
    <SourceProxy class="vtkCountFaces"
                 label="Count Cell Faces"
                 name="CountCellFaces">
      <Documentation long_help="Counts the number of faces on each cell and appends a new cell data array."
                     short_help="Adds a new cell data array containing the number of faces per cell.">
        Adds a new cell data array containing the number of faces per cell.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>The input.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetOutputArrayName"
                            name="OutputArrayName"
                            label="Faces Array Name"
                            default_values="Face Count"
                            number_of_elements="1"
                            panel_visibility="always">
        <Documentation>
          This is the name of the array in the output containing the face counts.
        </Documentation>
      </StringVectorProperty>
    </SourceProxy>
    <!-- End of CountFaces -->
    <SourceProxy class="vtkCountVertices"
                 label="Count Cell Vertices"
                 name="CountCellVertices">
      <Documentation long_help="Counts the number of vertices on each cell and appends a new cell data array."
                     short_help="Adds a new cell data array containing the number of vertices per cell.">
        Adds a new cell data array containing the number of vertices per cell.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>The input.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetOutputArrayName"
                            name="OutputArrayName"
                            label="Vertices Array Name"
                            default_values="Vertex Count"
                            number_of_elements="1"
                            panel_visibility="always">
        <Documentation>
          This is the name of the array in the output containing the vertex counts.
        </Documentation>
      </StringVectorProperty>
    </SourceProxy>
    <!-- End of CountVertices -->
    <SourceProxy class="vtkEnvironmentAnnotationFilter"
                 label="Environment Annotation"
                 name="EnvironmentAnnotation">
      <Documentation long_help="Allows annotation of user name, date/time, OS, and possibly filename."
        short_help="Adds annotation overlay.">
        Apply to any source. Gui allows manual selection of desired annotation options.
        If the source is a file, can display the filename.
      </Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>Set the input of the filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetDisplayUserName"
                         name="DisplayUserName"
                         default_values="1"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle User Name Visibility.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetDisplaySystemName"
                         name="DisplaySystemName"
                         default_values="1"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle System Name Visibility.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetDisplayDate"
                         name="DisplayDate"
                         default_values="1"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle Date/Time Visibility.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetDisplayFileName"
                         name="DisplayFileName"
                         default_values="1"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle File Name Visibility.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetDisplayFilePath"
                         name="DisplayFilePath"
                         default_values="1"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Toggle Show Full File Path.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="DisplayFileName"
                                   value="1" />
          <!-- enable this widget when DisplayFileName==1 -->
        </Hints>
      </IntVectorProperty>
      <StringVectorProperty command="SetFileName"
                            name="FileName"
                            default_values=""
                            number_of_elements="1"
                            panel_widget="filename_widget">
        <Documentation>Annotation of file name.</Documentation>
        <InputFileNameDomain name="filename">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </InputFileNameDomain>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="DisplayFileName"
                                   value="1" />
          <!-- enable this widget when DisplayFileName==1 -->
        </Hints>
      </StringVectorProperty>
      <Hints>
        <Visibility replace_input="0" />
        <OutputPort index="0"
                    name="Output-0"
                    type="text" />
      </Hints>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAMRToMultiBlockFilter"
                 label="Convert AMR dataset to Multi-block"
                 name="AMRToMultiBlock">
      <Documentation long_help="Convert AMR to Multiblock"
                     short_help="Convert AMR to Multiblock"></Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkOverlappingAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input for this
        filter.</Documentation>
      </InputProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAMRCutPlane"
                 label="AMR CutPlane"
                 name="AMRCutPlane">
      <Documentation long_help="Planar Cut of an AMR grid dataset"
                     short_help="Planar Cut of an AMR grid dataset">This filter
                     creates a cut-plane of the</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkOverlappingAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input for this
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetUseNativeCutter"
                         default_values="0"
                         name="UseNativeCutter"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This property specifies whether the ParaView's generic
        dataset cutter is used instead of the specialized AMR
        cutter.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetLevelOfResolution"
                         default_values="0"
                         name="LevelOfResolution"
                         number_of_elements="1">
        <IntRangeDomain max="100"
                        min="0"
                        name="range" />
        <Documentation>Set maximum slice resolution.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetCenter"
                            default_values="0.5 0.5 0.5"
                            label="Center"
                            name="Center"
                            number_of_elements="3"
                            panel_visibility="never">
        <BoundsDomain default_mode="mid" mode="normal" name="range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetNormal"
                            default_values="0 0 1"
                            label="Normal"
                            name="Normal"
                            number_of_elements="3"
                            panel_visibility="never"></DoubleVectorProperty>
      <PropertyGroup label="Plane Parameters" panel_widget="InteractivePlane">
        <Property function="Origin" name="Center" />
        <Property function="Normal" name="Normal" />
        <Property function="Input" name="Input" />
      </PropertyGroup>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAMRResampleFilter"
                 label="Resample AMR"
                 name="AMRResampleFilter">
      <Documentation long_help="Converts AMR data to a uniform grid"
                    short_help="Converts AMR data to a uniform grid">This
                    filter allows the user to specify a Region of Interest(ROI)
                    within the AMR data-set and extract it as a uniform
                    grid.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkOverlappingAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input for this
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetDemandDrivenMode"
                         default_values="1"
                         name="Demand-Driven Mode"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This property specifies whether the resampling filter
        will operate in demand-driven mode or not.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetTransferToNodes"
                         default_values="1"
                         name="TransferToNodes"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This property specifies whether the solution will be
        transferred to the nodes of the extracted region or the
        cells.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetNumberOfPartitions"
                         default_values="1"
                         name="NumberOfPartitions"
                         number_of_elements="1">
        <IntRangeDomain name="range" />
        <Documentation>Set the number of subdivisions for recursive coordinate
        bisection.</Documentation>
      </IntVectorProperty>
      <!--
     <IntVectorProperty
        name="LevelOfResolution"
        command="SetLevelOfResolution"
        number_of_elements="1"
        default_values="0" >
        <IntRangeDomain name="range" min="0" max="100" />
        <Documentation>
          Set maximum slice resolution.
        </Documentation>
      </IntVectorProperty>

      -->
      <IntVectorProperty animateable="1"
                         command="SetNumberOfSamples"
                         default_values="10 10 10"
                         name="Number of Samples"
                         number_of_elements="3">
        <IntRangeDomain name="range" />
        <Documentation>Sets the number of samples in each
        dimension</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetMin"
                            default_values="0.0 0.0 0.0"
                            name="Min"
                            number_of_elements="3">
        <DoubleRangeDomain name="range" />
        <Documentation>This property sets the minimum 3-D coordinate location
        by which the particles will be filtered out.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetMax"
                            default_values="0.0 0.0 0.0"
                            name="Max"
                            number_of_elements="3">
        <DoubleRangeDomain name="range" />
        <Documentation>This property sets the minimum 3-D coordinate location
        by which the particles will be filtered out.</Documentation>
      </DoubleVectorProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAMRSliceFilter"
                 label="Slice AMR data"
                 name="AMRSlice">
      <Documentation long_help="Slices AMR Data"
                     short_help="Slices AMR Data">This filter slices AMR
                     data.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkOverlappingAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input for this
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetMaxResolution"
                         default_values="0"
                         name="Level"
                         number_of_elements="1">
        <AMRLevelsDomain default_mode="max"
                         name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </AMRLevelsDomain>
        <Documentation>Set maximum slice resolution.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetOffsetFromOrigin"
                            default_values="0.0"
                            name="OffSet"
                            number_of_elements="1">
        <BoundsDomain default_mode="mid"
                      mode="extents"
                      name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="AxisFlags"
                      name="Normal" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>Set's the offset from the origin of the
        data-set</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetNormal"
                         default_values="1"
                         name="Normal"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="X-Normal"
                 value="1" />
          <Entry text="Y-Normal"
                 value="2" />
          <Entry text="Z-Normal"
                 value="4" />
        </EnumerationDomain>
        <Documentation>This property sets the normal of the
        slice.</Documentation>
      </IntVectorProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPExtractDataArraysOverTime"
                 label="Plot Data Over Time"
                 name="PlotDataOverTime">
      <InputProperty command="SetInputConnection"
                     name="Input"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkTable" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>The input from which the selection is
        extracted.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetFieldAssociation"
                         default_values="0"
                         name="FieldAssociation"
                         number_of_elements="1">
        <Documentation>Select the attribute data to pass.</Documentation>
        <EnumerationDomain name="enum">
          <Entry text="Points" value="0" />
          <Entry text="Cells" value="1" />
          <Entry text="Vertices" value="4" />
          <Entry text="Edges" value="5" />
          <Entry text="Rows" value="6" />
        </EnumerationDomain>
      </IntVectorProperty>

      <IntVectorProperty command="SetReportStatisticsOnly"
                         default_values="1"
                         name="Only Report Selection Statistics"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the min, max,
          inter-quartile ranges, and (for numeric arrays) mean and standard
          deviation of all the selected points or cells within each time step
          are reported -- instead of breaking each selected point's or cell's
          attributes out into separate time history tables.</Documentation>
      </IntVectorProperty>
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <PipelineIcon name="XYChartView" />
        <View type="QuartileChartView" />
        <WarnOnCreate title="Potentially slow operation">
          **Plot Data Over Time** filter needs to process all timesteps
          available in your dataset and can potentially take a long time to complete.
          Do you want to continue?
        </WarnOnCreate>
      </Hints>
      <!-- End of ExtractSelectionOverTime -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPExtractSelectedArraysOverTime"
                 label="Plot Selection Over Time"
                 name="ExtractSelectionOverTime">
      <Documentation long_help="Extracts selection over time and then plots it."
                     short_help="Extracts selection over time and then plots it.">
                     This filter extracts the selection over time, i.e. cell
                     and/or point variables at a cells/point selected are
                     extracted over time The output multiblock consists of 1D
                     rectilinear grids where the x coordinate corresponds to
                     time (the same array is also copied to a point array named
                     Time or TimeData (if Time exists in the input)). If
                     selection input is a Location based selection then the
                     point values are interpolated from the nearby cells, ie
                     those of the cell the location lies in.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkTable" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>The input from which the selection is
        extracted.</Documentation>
      </InputProperty>
      <InputProperty command="SetSelectionConnection"
                     name="Selection"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkSelection" />
        </DataTypeDomain>
        <Documentation>The input that provides the selection
        object.</Documentation>
        <Hints>
          <!-- This tag alerts the auto-generated panels and input selection
              that this input is a selection.  It should use the special
              selection GUI. -->
          <SelectionInput />
        </Hints>
      </InputProperty>
      <IntVectorProperty command="SetReportStatisticsOnly"
                         default_values="1"
                         name="Only Report Selection Statistics"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the min, max,
          inter-quartile ranges, and (for numeric arrays) mean and standard
          deviation of all the selected points or cells within each time step
          are reported -- instead of breaking each selected point's or cell's
          attributes out into separate time history tables.</Documentation>
      </IntVectorProperty>

      <SubProxy command="SetSelectionExtractor">
        <Proxy name="SetSelectionExtractor" class="vtkPVExtractSelection" />
      </SubProxy>

      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <PipelineIcon name="XYChartView" />
        <View type="QuartileChartView" />
        <WarnOnCreate title="Potentially slow operation">
          **Plot Selection Over Time** filter needs to process all timesteps
          available in your dataset and can potentially take a long time to complete.
          Do you want to continue?
        </WarnOnCreate>
        <InitializationHelper class="vtkSMExtractSelectionProxyInitializationHelper" />
      </Hints>
      <!-- End of ExtractSelectionOverTime -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPExtractExodusGlobalTemporalVariables"
                 label="Plot Global Variables Over Time"
                 name="ExtractFieldDataOverTime">
      <Documentation long_help="Extracts and plots data in field data over time."
                     short_help="Extracts and plots data in field data over time.">
          This filter extracts the variables that reside in a
          dataset's field data and are defined for all timesteps. Such variables
          are generated by certain readers, like the Exodus reader.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>The input from which the selection is
        extracted.</Documentation>
      </InputProperty>
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <Plotable />
        <InitializationHelper class="vtkSMExtractSelectionProxyInitializationHelper" />
      </Hints>
      <!-- End ExtractFieldDatasOverTime -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageShrink3D"
                 label="Image Shrink"
                 name="ImageShrink">
      <Documentation long_help="Reduce the size of an image/volume by subsampling."
                     short_help="Subsample an image/volume.">The Image Shrink
                     filter reduces the size of an image/volume dataset by
                     subsampling it (i.e., extracting every nth pixel/voxel in
                     integer multiples). The subsampling rate can be set
                     separately for each dimension of the
                     image/volume.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Image Shrink
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="1"
                         command="SetShrinkFactors"
                         default_values="1 1 1"
                         name="ShrinkFactors"
                         number_of_elements="3">
        <IntRangeDomain max="100"
                        min="1"
                        name="range" />
        <Documentation>The value of this property indicates the amount by which
        to shrink along each axis.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetAveraging"
                         default_values="1"
                         name="Averaging"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is 1, an average of
        neighborhood scalar values will be used as the output scalar value for
        each output point. If its value is 0, only subsampling will be
        performed, and the original scalar values at the points will be
        retained.</Documentation>
      </IntVectorProperty>
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <Plotable />
      </Hints>
      <!-- End ImageShrink -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkSurfaceVectors"
                 label="Surface Vectors"
                 name="SurfaceVectors">
      <Documentation long_help="This filter constrains vectors to lie on a surface."
                     short_help="This filter constrains vectors to lie on a surface.">
                     The Surface Vectors filter is used for 2D data sets. It
                     constrains vectors to lie in a surface by removing
                     components of the vectors normal to the local
                     surface.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>This property specifies the input to the Surface Vectors
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies the name of the input vector
        array to process.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetConstraintMode"
                         default_values="0"
                         name="ConstraintMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Parallel"
                 value="0" />
          <Entry text="Perpendicular"
                 value="1" />
          <Entry text="PerpendicularScale"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property specifies whether the vectors will be
        parallel or perpendicular to the surface. If the value is set to
        PerpendicularScale (2), then the output will contain a scalar array
        with the dot product of the surface normal and the vector at each
        point.</Documentation>
      </IntVectorProperty>
      <!-- End SurfaceVectors -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkIntegrateAttributes"
                 label="Integrate Variables"
                 name="IntegrateAttributes">
      <Documentation long_help="This filter integrates cell and point attributes."
                     short_help="Integrates over lines, surfaces or vectors.">
                     The Integrate Attributes filter integrates point and cell
                     data over lines and surfaces. It also computes length of
                     lines, area of surface, or volume.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Integrate
        Attributes filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetDivideAllCellDataByVolume"
                         name="DivideCellDataByVolume"
                         default_values="0"
                         number_of_elements="1">
        <Documentation>
          This property specifies if the output data will be divided by the
          volume/area computed for the integrated cells.  If it is on, then each
          value in the output cell data will be divided by the area/volume.
        </Documentation>
        <BooleanDomain name="bool"/>
      </IntVectorProperty>

      <Hints>
        <Visibility replace_input="0" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="SpreadSheetView" />
        <Plotable />
      </Hints>
      <!-- End IntegrateAttributes -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkIntegrateFlowThroughSurface"
                 label="Surface Flow"
                 name="IntegrateFlowThroughSurface">
      <Documentation long_help="This filter integrates flow through a surface."
                     short_help="This filter integrates flow through a surface.">
                     The flow integration filter integrates the dot product of
                     a point flow vector field and surface normal. It computes
                     the net flow across the 2D surface. It operates on any
                     type of dataset and produces an unstructured grid
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>This property specifies the input to the Surface Flow
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>The value of this property specifies the name of the
        input vector array containing the flow vector field.</Documentation>
      </StringVectorProperty>
      <!-- End IntegrateFlowThroughSurface -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkMergeArrays"
                 label="Append Attributes"
                 name="AppendAttributes">
      <Documentation long_help="Copies geometry from first input.  Puts all of the arrays into the output."
                     short_help="Puts all input arrays into the single output.">
                     The Append Attributes filter takes multiple input data
                     sets with the same geometry and merges their point and
                     cell attributes to produce a single output containing all
                     the point and cell attributes of the inputs. Any inputs
                     without the same number of points and cells as the first
                     input are ignored. The input data sets must already be
                     collected together, either as a result of a reader that
                     loads multiple parts (e.g., EnSight reader) or because the
                     Group Parts filter has been run to form a collection of
                     data sets.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Append
        Attributes filter.</Documentation>
      </InputProperty>
      <!-- End AppendAttributes -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAppendPolyData"
                 label="Append Geometry"
                 name="AppendPolyData">
      <Documentation long_help="Takes an input of multiple poly data parts and output has only one part."
                     short_help="Append multiple parts into one.">The Append
                     Geometry filter operates on multiple polygonal data sets.
                     It merges their geometry into a single data set. Only the
                     point and cell attributes that all of the input data sets
                     have in common will appear in the output.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>Set the input to the Append Geometry
        filter.</Documentation>
      </InputProperty>
      <!-- End AppendPolyData -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAppendDataSets"
                 label="Append Datasets"
                 name="Append">
      <Documentation long_help="Takes an input of multiple datasets and output has only one unstructured grid or polydata."
                     short_help="Append multiple datasets into one.">The Append
                     Datasets filter operates on multiple data sets of any type
                     (polygonal, structured, etc.). It merges their meshes
                     into a single dataset. If all inputs are polydata, the output
                     is a polydata, otherwise it is an unstructured grid.
                     Only the point and cell attributes that all of the input
                     datasets have in common will appear in the output.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="0"
                        name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the datasets to be merged into a
        single dataset by the Append Datasets filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetOutputDataSetType"
                         default_values="4"
                         number_of_elements="1"
                         name="OutputDataSetType"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Polygonal Mesh"
                 value="0" />
          <Entry text="Unstructured Grid"
                 value="4" />
        </EnumerationDomain>
        <Documentation>Determines the output type produced by this filter. Only input datasets compatible
        with the output type will be merged in the output. For example, if the output type is
        "Polygonal Mesh", then inputs of type "Image Data", "StructuredGrid", etc. will not be merged.
        On the other hand, if the output type is "Unstructured Grid", then inputs of almost any type
        will be merged in the output. Defaults to "Unstructured Grid".
        </Documentation>
      </IntVectorProperty>
      <!-- End AppendDataSet -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCellCenters"
                 label="Cell Centers"
                 name="CellCenters">
      <Documentation long_help="Create a point (no geometry) at the center of each input cell."
                     short_help="Convert cells to vertices.">The Cell Centers
                     filter places a point at the center of each cell in the
                     input data set. The center computed is the parametric
                     center of the cell, not necessarily the geometric or
                     bounding box center. The cell attributes of the input will
                     be associated with these newly created points of the
                     output. You have the option of creating a vertex cell per
                     point in the output. This is useful because vertex cells
                     are rendered, but points are not. The points themselves
                     could be used for placing glyphs (using the Glyph filter).
                     The Cell Centers filter takes any type of data set as
                     input and produces a polygonal data set as
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Cell Centers
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetVertexCells"
                         default_values="0"
                         name="VertexCells"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If set to 1, a vertex cell will be generated per point
        in the output. Otherwise only points will be generated.</Documentation>
      </IntVectorProperty>
      <!-- End CellCenters -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPCellDataToPointData"
                 label="Cell Data to Point Data"
                 name="CellDataToPointData">
      <Documentation long_help="Create point attributes by averaging cell attributes."
                     short_help="Convert cell data to point data.">The Cell
                     Data to Point Data filter averages the values of the cell
                     attributes of the cells surrounding a point to compute
                     point attributes. The Cell Data to Point Data filter
                     operates on any type of data set, and the output data set
                     is of the same type as the input.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array" />
        <Documentation>This property specifies the input to the Cell Data to
        Point Data filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetProcessAllArrays"
                         default_values="1"
                         name="ProcessAllArrays"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property controls whether all input
        cell arrays will be processed and converted into point arrays.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearCellDataArrays"
                            command="AddCellDataArray"
                            name="CellDataArrays"
                            label="Cell Data Array to process"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>Add a cell array by name to be converted to point array.</Documentation>
        <ArrayListDomain input_domain_name="input_array" name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="ProcessAllArrays" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
      </StringVectorProperty>
      <IntVectorProperty command="SetPassCellData"
                         default_values="0"
                         name="PassCellData"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, then the input cell data
        is passed through to the output; otherwise, only the generated point
        data will be available in the output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPieceInvariant"
                         default_values="0"
                         name="PieceInvariant"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, this filter
        will request ghost levels so that the values at boundary points match
        across processes. NOTE: Enabling this option might cause multiple
        executions of the data source because more information is needed to
        remove internal surfaces.</Documentation>
      </IntVectorProperty>
      <!-- End CellDataToPointData -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkIdFilter"
                 label="Generate Ids"
                 name="GenerateIdScalars">
      <Documentation long_help="Generate scalars from point and cell ids."
                     short_help="Generate scalars from point and cell ids.">
                     This filter generates scalars using cell and point ids.
                     That is, the point attribute data scalars are generated
                     from the point ids, and the cell attribute data scalars or
                     field data are generated from the the cell
                     ids.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Cell Data to
        Point Data filter.</Documentation>
      </InputProperty>
      <IntVectorProperty name="GeneratePointIds"
                         command="SetPointIds"
                         number_of_elements="1"
                         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Enable generation of point ids.
        </Documentation>
      </IntVectorProperty>

      <StringVectorProperty command="SetPointIdsArrayName"
                            default_values="PointIds"
                            name="PointIdsArrayName"
                            number_of_elements="1">
        <Documentation>The name of the point ids array.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="enabled_state"
                                   property="GeneratePointIds"
                                   value="1" />
        </Hints>
      </StringVectorProperty>

      <IntVectorProperty name="GenerateCellIds"
                         command="SetCellIds"
                         number_of_elements="1"
                         default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Enable generation of cell ids.
        </Documentation>
      </IntVectorProperty>

      <StringVectorProperty command="SetCellIdsArrayName"
                            default_values="CellIds"
                            name="CellIdsArrayName"
                            number_of_elements="1">
        <Documentation>The name of the cell ids array.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="enabled_state"
                                   property="GenerateCellIds"
                                   value="1" />
        </Hints>
      </StringVectorProperty>
      <PropertyGroup label="Point Ids">
        <Property name="GeneratePointIds" />
        <Property name="PointIdsArrayName" />
      </PropertyGroup>
      <PropertyGroup label="Cell Ids">
        <Property name="GenerateCellIds" />
        <Property name="CellIdsArrayName" />
      </PropertyGroup>

      <!-- End GenerateIdScalars -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGenerateGlobalIds"
                 label="Generate Global Ids"
                 name="GenerateGlobalIds">
      <Documentation short_help="Generate global point and cell ids.">
        Generate global point and cell ids. Global ids are unique ids where the same point
        (or cell) will be assigned the same id even if the point (or cell) is duplicated among
        multiple blocks or ranks. This filter also flags duplicated points as ghost points.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input.</Documentation>
      </InputProperty>

      <!-- End GenerateGlobalIds -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCleanPolyData"
                 label="Clean"
                 name="CleanPolyData">
      <Documentation long_help="Merge coincident points if they do not meet a feature edge criteria."
                     short_help="Merge coincident points.">The Clean filter
                     takes polygonal data as input and generates polygonal data
                     as output. This filter can merge duplicate points, remove
                     unused points, and transform degenerate cells into their
                     appropriate forms (e.g., a triangle is converted into a
                     line if two of its points are merged).</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>Set the input to the Clean filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPieceInvariant"
                         default_values="1"
                         name="PieceInvariant"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the whole data set will be
        processed at once so that cleaning the data set always produces the
        same results. If it is set to 0, the data set can be processed one
        piece at a time, so it is not necessary for the entire data set to fit
        into memory; however the results are not guaranteed to be the same as
        they would be if the Piece invariant option was on. Setting this option
        to 0 may produce seams in the output dataset when ParaView is run in
        parallel.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTolerance"
                            default_values="0.0"
                            name="Tolerance"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>If merging nearby points (see PointMerging property) and
        not using absolute tolerance (see ToleranceIsAbsolute property), this
        property specifies the tolerance for performing merging as a fraction
        of the length of the diagonal of the bounding box of the input data
        set.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetAbsoluteTolerance"
                            default_values="1.0"
                            name="AbsoluteTolerance"
                            number_of_elements="1">
        <DoubleRangeDomain min="0"
                           name="range" />
        <Documentation>If merging nearby points (see PointMerging property) and
        using absolute tolerance (see ToleranceIsAbsolute property), this
        property specifies the tolerance for performing merging in the spatial
        units of the input data set.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetToleranceIsAbsolute"
                         default_values="0"
                         name="ToleranceIsAbsolute"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This property determines whether to use absolute or
        relative (a percentage of the bounding box) tolerance when performing
        point merging.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetConvertLinesToPoints"
                         default_values="1"
                         name="ConvertLinesToPoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, degenerate lines (a "line"
        whose endpoints are at the same spatial location) will be converted to
        points.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetConvertPolysToLines"
                         default_values="1"
                         name="ConvertPolysToLines"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, degenerate polygons (a
        "polygon" with only two distinct point coordinates) will be converted
        to lines.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetConvertStripsToPolys"
                         default_values="1"
                         name="ConvertStripsToPolys"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, degenerate triangle strips
        (a triangle "strip" containing only one triangle) will be converted to
        triangles.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPointMerging"
                         default_values="1"
                         name="PointMerging"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, then points will be merged
        if they are within the specified Tolerance or AbsoluteTolerance (see
        the Tolerance and AbsoluteTolerance properties), depending on the value
        of the ToleranceIsAbsolute property. (See the ToleranceIsAbsolute
        property.) If this property is set to 0, points will not be
        merged.</Documentation>
      </IntVectorProperty>
      <!-- End CleanPolyData -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCleanUnstructuredGrid"
                 label="Clean to Grid"
                 name="CleanUnstructuredGrid">
      <Documentation long_help="This filter merges points and converts the data set to unstructured grid."
                     short_help="Merge points.">The Clean to Grid filter merges
                     points that are exactly coincident. It also converts the
                     data set to an unstructured grid. You may wish to do this
                     if you want to apply a filter to your data set that is
                     available for unstructured grids but not for the initial
                     type of your data set (e.g., applying warp vector to
                     volumetric data). The Clean to Grid filter operates on any
                     type of data set.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Clean to Grid
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTolerance"
                            default_values="0.0"
                            name="Tolerance"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>When merging nearby points and
        not using absolute tolerance (see ToleranceIsAbsolute property), this
        property specifies the tolerance for performing merging as a fraction
        of the length of the diagonal of the bounding box of the input data
        set.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetAbsoluteTolerance"
                            default_values="1.0"
                            name="AbsoluteTolerance"
                            number_of_elements="1">
        <DoubleRangeDomain min="0"
                           name="range" />
        <Documentation>When merging nearby points and
        using absolute tolerance (see ToleranceIsAbsolute property), this
        property specifies the tolerance for performing merging in the spatial
        units of the input data set.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetToleranceIsAbsolute"
                         default_values="0"
                         name="ToleranceIsAbsolute"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This property determines whether to use absolute or
        relative (a percentage of the bounding box) tolerance when performing
        point merging.</Documentation>
      </IntVectorProperty>
      <!-- End CleanUnstructuredGrid -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCleanUnstructuredGridCells"
                 label="Clean Cells to Grid"
                 name="CleanUnstructuredGridCells">
      <Documentation long_help="This filter merges cells and converts the data set to unstructured grid."
                     short_help="Merge cells.">Merges degenerate cells. Assumes
                     the input grid does not contain duplicate points. You may
                     want to run vtkCleanUnstructuredGrid first to assert it.
                     If duplicated cells are found they are removed in the
                     output. The filter also handles the case, where a cell may
                     contain degenerate nodes (i.e. one and the same node is
                     referenced by a cell more than once).</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUnstructuredGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Clean Cells to
        Grid filter.</Documentation>
      </InputProperty>
      <!-- End CleanUnstructuredGridCells -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDelaunay2D"
                 label="Delaunay 2D"
                 name="Delaunay2D">
      <Documentation long_help="Create 2D Delaunay triangulation of input points.
It expects a vtkPointSet as input and produces vtkPolyData as output.
The points are expected to be in a mostly planar distribution."
                     short_help="Create 2D Delaunay triangulation of input points.">
                     Delaunay2D is a filter that constructs a 2D Delaunay
                     triangulation from a list of input points. These points
                     may be represented by any dataset of type vtkPointSet and
                     subclasses. The output of the filter is a polygonal
                     dataset containing a triangle mesh. The 2D Delaunay
                     triangulation is defined as the triangulation that
                     satisfies the Delaunay criterion for n-dimensional
                     simplexes (in this case n=2 and the simplexes are
                     triangles). This criterion states that a circumsphere of
                     each simplex in a triangulation contains only the n+1
                     defining points of the simplex. In two dimensions, this
                     translates into an optimal triangulation. That is, the
                     maximum interior angle of any triangle is less than or
                     equal to that of any possible triangulation. Delaunay
                     triangulations are used to build topological structures
                     from unorganized (or unstructured) points. The input to
                     this filter is a list of points specified in 3D, even
                     though the triangulation is 2D. Thus the triangulation is
                     constructed in the x-y plane, and the z coordinate is
                     ignored (although carried through to the output). You can
                     use the option ProjectionPlaneMode in order to compute the
                     best-fitting plane to the set of points, project the
                     points and that plane and then perform the triangulation
                     using their projected positions and then use it as the
                     plane in which the triangulation is performed. The
                     Delaunay triangulation can be numerically sensitive in
                     some cases. To prevent problems, try to avoid injecting
                     points that will result in triangles with bad aspect
                     ratios (1000:1 or greater). In practice this means
                     inserting points that are "widely dispersed", and enables
                     smooth transition of triangle sizes throughout the mesh.
                     (You may even want to add extra points to create a better
                     point distribution.) If numerical problems are present,
                     you will see a warning message to this effect at the end
                     of the triangulation process. Warning: Points arranged on
                     a regular lattice (termed degenerate cases) can be
                     triangulated in more than one way (at least according to
                     the Delaunay criterion). The choice of triangulation (as
                     implemented by this algorithm) depends on the order of the
                     input points. The first three points will form a triangle;
                     other degenerate points will not break this triangle.
                     Points that are coincident (or nearly so) may be discarded
                     by the algorithm. This is because the Delaunay
                     triangulation requires unique input points. The output of
                     the Delaunay triangulation is supposedly a convex hull. In
                     certain cases this implementation may not generate the
                     convex hull.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input dataset to the
        Delaunay 2D filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetProjectionPlaneMode"
                         default_values="0"
                         name="ProjectionPlaneMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="XY Plane"
                 value="0" />
          <!--         <Entry value="1" text="Perpendicular"/> -->
          <Entry text="Best-Fitting Plane"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines type of projection plane to use
        in performing the triangulation.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetAlpha"
                            default_values="0.0"
                            name="Alpha"
                            number_of_elements="1">
        <DoubleRangeDomain min="0"
                           name="range" />
        <Documentation>The value of this property controls the output of this
        filter. For a non-zero alpha value, only edges or triangles contained
        within a sphere centered at mesh vertices will be output. Otherwise,
        only triangles will be output.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTolerance"
                            default_values="0.00001"
                            name="Tolerance"
                            number_of_elements="1">
        <DoubleRangeDomain max="1.0"
                           min="0"
                           name="range" />
        <Documentation>This property specifies a tolerance to control
        discarding of closely spaced points. This tolerance is specified as a
        fraction of the diagonal length of the bounding box of the
        points.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetOffset"
                            default_values="1.0"
                            name="Offset"
                            number_of_elements="1">
        <DoubleRangeDomain min="0.75"
                           name="range" />
        <Documentation>This property is a multiplier to control the size of the
        initial, bounding Delaunay triangulation.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetBoundingTriangulation"
                         default_values="0"
                         name="BoundingTriangulation"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, bounding triangulation
        points (and associated triangles) are included in the output. These are
        introduced as an initial triangulation to begin the triangulation
        process. This feature is nice for debugging output.</Documentation>
      </IntVectorProperty>
      <!-- End Delaunay2D -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDelaunay3D"
                 label="Delaunay 3D"
                 name="Delaunay3D">
      <Documentation long_help="Create a 3D Delaunay triangulation of input
                               points.  It expects a vtkPointSet as input and
                               produces vtkUnstructuredGrid as output."
                     short_help="Create a 3D Delaunay triangulation of input
                                points.">Delaunay3D is a filter that constructs
a 3D Delaunay triangulation from a list of input points. These points may be
represented by any dataset of type vtkPointSet and subclasses. The output of
the filter is an unstructured grid dataset. Usually the output is a tetrahedral
mesh, but if a non-zero alpha distance value is specified (called the "alpha"
value), then only tetrahedra, triangles, edges, and vertices lying within the
alpha radius are output. In other words, non-zero alpha values may result in
arbitrary combinations of tetrahedra, triangles, lines, and vertices. (The
notion of alpha value is derived from Edelsbrunner's work on "alpha shapes".)
The 3D Delaunay triangulation is defined as the triangulation that satisfies
the Delaunay criterion for n-dimensional simplexes (in this case n=3 and the
simplexes are tetrahedra). This criterion states that a circumsphere of each
simplex in a triangulation contains only the n+1 defining points of the
simplex. (See text for more information.) While in two dimensions this
translates into an "optimal" triangulation, this is not true in 3D, since a
measurement for optimality in 3D is not agreed on. Delaunay triangulations are
used to build topological structures from unorganized (or unstructured) points.
The input to this filter is a list of points specified in 3D. (If you wish to
create 2D triangulations see Delaunay2D.) The output is an unstructured grid.
The Delaunay triangulation can be numerically sensitive. To prevent problems,
try to avoid injecting points that will result in triangles with bad aspect
ratios (1000:1 or greater). In practice this means inserting points that are
"widely dispersed", and enables smooth transition of triangle sizes throughout
the mesh. (You may even want to add extra points to create a better point
distribution.) If numerical problems are present, you will see a warning
message to this effect at the end of the triangulation process. Warning: Points
arranged on a regular lattice (termed degenerate cases) can be triangulated in
more than one way (at least according to the Delaunay criterion). The choice of
triangulation (as implemented by this algorithm) depends on the order of the
input points. The first four points will form a tetrahedron; other degenerate
points (relative to this initial tetrahedron) will not break it. Points that
are coincident (or nearly so) may be discarded by the algorithm. This is
because the Delaunay triangulation requires unique input points. You can
control the definition of coincidence with the "Tolerance" instance variable.
The output of the Delaunay triangulation is supposedly a convex hull. In
certain cases this implementation may not generate the convex hull. This
behavior can be controlled by the Offset instance variable. Offset is a
multiplier used to control the size of the initial triangulation. The larger
the offset value, the more likely you will generate a convex hull; and the more
likely you are to see numerical problems. The implementation of this algorithm
varies from the 2D Delaunay algorithm (i.e., Delaunay2D) in an important way.
When points are injected into the triangulation, the search for the enclosing
tetrahedron is quite different. In the 3D case, the closest previously inserted
point point is found, and then the connected tetrahedra are searched to find
the containing one. (In 2D, a "walk" towards the enclosing triangle is
performed.) If the triangulation is Delaunay, then an enclosing tetrahedron
will be found. However, in degenerate cases an enclosing tetrahedron may not be
found and the point will be rejected.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input dataset to the
        Delaunay 3D filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetAlpha"
                            default_values="0.0"
                            name="Alpha"
                            number_of_elements="1">
        <DoubleRangeDomain min="0"
                           name="range" />
        <Documentation>This property specifies the alpha (or distance) value to
        control the output of this filter. For a non-zero alpha value, only
        edges, faces, or tetra contained within the circumsphere (of radius
        alpha) will be output. Otherwise, only tetrahedra will be
        output.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTolerance"
                            default_values="0.001"
                            name="Tolerance"
                            number_of_elements="1">
        <DoubleRangeDomain max="1.0"
                           min="0"
                           name="range" />
        <Documentation>This property specifies a tolerance to control
        discarding of closely spaced points. This tolerance is specified as a
        fraction of the diagonal length of the bounding box of the
        points.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetOffset"
                            default_values="2.5"
                            name="Offset"
                            number_of_elements="1">
        <DoubleRangeDomain min="2.5"
                           name="range" />
        <Documentation>This property specifies a multiplier to control the size
        of the initial, bounding Delaunay triangulation.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetBoundingTriangulation"
                         default_values="0"
                         name="BoundingTriangulation"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This boolean controls whether bounding triangulation
        points (and associated triangles) are included in the output. (These
        are introduced as an initial triangulation to begin the triangulation
        process. This feature is nice for debugging output.)</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetAlphaTets"
                         default_values="1"
                         name="AlphaTets"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>This boolean controls whether tetrahedrons which satisfy
        the alpha criterion output when alpha is non-zero.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetAlphaTris"
                         default_values="1"
                         name="AlphaTris"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>This boolean controls whether triangles which satisfy
        the alpha criterion output when alpha is non-zero.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetAlphaLines"
                         default_values="0"
                         name="AlphaLines"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>This boolean controls whether lines which satisfy the
        alpha criterion output when alpha is non-zero.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetAlphaVerts"
                         default_values="0"
                         name="AlphaVerts"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>This boolean controls whether vertices which satisfy the
        alpha criterion are output when alpha is non-zero.</Documentation>
      </IntVectorProperty>
      <!-- End Delaunay3d -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkConnectivityFilter"
                 label="Connectivity"
                 name="PVConnectivityFilter">
      <Documentation long_help="Mark connected components with integer point attribute array."
                     short_help="Find connected components.">The Connectivity
                     filter assigns a region id to connected components of the
                     input data set. (The region id is assigned as a point
                     scalar value.) This filter takes any data set type as
                     input and produces unstructured grid
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="0"
                        name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Connectivity
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetExtractionMode"
                         default_values="5"
                         name="ExtractionMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Extract Largest Region"
                 value="4" />
          <Entry text="Extract All Regions"
                 value="5" />
          <Entry text="Extract Closest Point Region"
                 value="6" />
        </EnumerationDomain>
        <Documentation>Controls the extraction of connected
        surfaces.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetColorRegions"
                         default_values="1"
                         name="ColorRegions"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Controls the coloring of the connected
        regions.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetRegionIdAssignmentMode"
                         default_values="0"
                         name="RegionIdAssignmentMode"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
          Specifies how regions IDs are assigned to the connected components. **Unspecified** means
          regions will have no particular order, **Cell Count Descending** assigns increasing region
          IDs to connected components with progressively smaller cell counts, and **Cell Count Ascending**
          assigns increasing region IDs to connected components with progressively larger cell counts.
        </Documentation>
        <EnumerationDomain name="enum">
          <Entry text="Unspecified"
                 value="0" />
          <Entry text="Cell Count Descending"
                 value="1" />
          <Entry text="Cell Count Ascending"
                 value="2" />
        </EnumerationDomain>
      </IntVectorProperty>
      <DoubleVectorProperty
        name="ClosestPoint"
        command="SetClosestPoint"
        number_of_elements="3"
        default_values="0 0 0">
        <Documentation>Specifies the point to use in closest point mode.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="ExtractionMode"
                                   value="6" />
          <!-- show this widget when ExtractionMode==6 -->
        </Hints>
      </DoubleVectorProperty>

      <!-- End PVConnectivityFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageClip"
                 label="Crop"
                 name="ImageClip">
      <Documentation long_help="Efficiently extract an area/volume of interest from a 2-d image or 3-d volume."
                     short_help="Extract a volume of interest.">The Crop filter
                     extracts an area/volume of interest from a 2D image or a
                     3D volume by allowing the user to specify the minimum and
                     maximum extents of each dimension of the data. Both the
                     input and output of this filter are uniform rectilinear
                     data.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Crop
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetOutputWholeExtent"
                         default_values="0 0 0 0 0 0"
                         name="OutputWholeExtent"
                         number_of_elements="6">
        <ExtentDomain name="extent">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ExtentDomain>
        <Documentation>This property gives the minimum and maximum point index
        (extent) in each dimension for the output dataset.</Documentation>
      </IntVectorProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
      <!-- End ImageClip -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCurvatures"
                 label="Curvature"
                 name="Curvatures">
      <Documentation long_help="This filter will compute the Gaussian or mean curvature of the mesh at each point."
                     short_help="Compute the curvature at each point.">The
                     Curvature filter computes the curvature at each point in a
                     polygonal data set. This filter supports both Gaussian and
                     mean curvatures. ; the type can be selected from the
                     Curvature type menu button.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Curvature
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetInvertMeanCurvature"
                         default_values="0"
                         name="InvertMeanCurvature"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the mean curvature
        calculation will be inverted. This is useful for meshes with
        inward-pointing normals.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCurvatureType"
                         default_values="0"
                         name="CurvatureType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Gaussian"
                 value="0" />
          <Entry text="Mean"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This property specifies which type of curvature to
        compute.</Documentation>
      </IntVectorProperty>
      <!-- End Curvatures -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDecimatePro"
                 label="Decimate"
                 name="DecimatePro">
      <Documentation long_help="Simplify a polygonal model using an adaptive edge collapse algorithm.  This filter works with triangles only."
                     short_help="Reduce the number of triangles in a model.">
                     The Decimate filter reduces the number of triangles in a
                     polygonal data set. Because this filter only operates on
                     triangles, first run the Triangulate filter on a dataset
                     that contains polygons other than
                     triangles.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Decimate
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTargetReduction"
                            default_values="0.9"
                            name="TargetReduction"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>This property specifies the desired reduction in the
        total number of polygons in the output dataset. For example, if the
        TargetReduction value is 0.9, the Decimate filter will attempt to
        produce an output dataset that is 10% the size of the
        input.)</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetPreserveTopology"
                         default_values="0"
                         name="PreserveTopology"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, decimation will not split
        the dataset or produce holes, but it may keep the filter from reaching
        the reduction target. If it is set to 0, better reduction can occur
        (reaching the reduction target), but holes in the model may be
        produced.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetFeatureAngle"
                            default_values="15.0"
                            name="FeatureAngle"
                            number_of_elements="1">
        <DoubleRangeDomain max="180"
                           min="0"
                           name="range" />
        <Documentation>The value of this property is used in determining where
        the data set may be split. If the angle between two adjacent triangles
        is greater than or equal to the FeatureAngle value, then their boundary
        is considered a feature edge where the dataset can be
        split.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetBoundaryVertexDeletion"
                         default_values="1"
                         name="BoundaryVertexDeletion"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, then vertices on the
        boundary of the dataset can be removed. Setting the value of this
        property to 0 preserves the boundary of the dataset, but it may cause
        the filter not to reach its reduction target.</Documentation>
      </IntVectorProperty>
      <!-- End DecimatePro -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkDecimatePolylineFilter"
                 label="Decimate Polyline"
                 name="DecimatePolyline">
      <Documentation long_help="Reduce the number of lines in a polyline by evaluating an error metric for each vertex and removing the vertices with smaller errors first."
                     short_help="Reduce the number of lines in a polyline.">
        Decimate Polyline is a filter to reduce the number of lines in a
        polyline. The algorithm functions by evaluating an error metric for each
        vertex (i.e., the distance of the vertex to a line defined from the two
        vertices on either side of the vertex). Then, these vertices are placed
        into a priority queue, and those with smaller errors are deleted first.
        The decimation continues until the target reduction is reached. While the
        filter will not delete end points, it will decimate closed loops down to a
        single line, thereby changing topology.

        As this filter works on polylines, you may need to call Triangle Strips before calling
        this filter.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Decimate Polyline
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTargetReduction"
                            default_values="0.9"
                            name="TargetReduction"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>This property specifies the desired reduction in the
        total number of lines in the output dataset. For example, if the
        TargetReduction value is 0.9, the Decimate Polyline filter will attempt to
        produce an output dataset that is 10% the size of the
        input.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMaximumError"
                            default_values="1.79769e+308"
                            name="MaximumError"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>
          Set the largest decimation error that is allowed during the decimation
          process. This may limit the maximum reduction that may be achieved. The
          maximum error is specified as a fraction of the maximum length of
          the input data bounding box.
        </Documentation>
      </DoubleVectorProperty>
      <!-- End DecimatePolyline -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkElevationFilter"
                 label="Elevation"
                 name="ElevationFilter">
      <Documentation long_help="Create point attribute array by projecting points onto an elevation vector."
                     short_help="Create a point array representing elevation.">
                     The Elevation filter generates point scalar values for an
                     input dataset along a specified direction vector. The
                     Input menu allows the user to select the data set to which
                     this filter will be applied. Use the Scalar range entry
                     boxes to specify the minimum and maximum scalar value to
                     be generated. The Low Point and High Point define a line
                     onto which each point of the data set is projected. The
                     minimum scalar value is associated with the Low Point, and
                     the maximum scalar value is associated with the High
                     Point. The scalar value for each point in the data set is
                     determined by the location along the line to which that
                     point projects.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input dataset to the
        Elevation filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetScalarRange"
                            default_values="0 1"
                            name="ScalarRange"
                            number_of_elements="2">
        <DoubleRangeDomain name="range" />
        <Documentation>This property determines the range into which scalars
        will be mapped.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetLowPoint"
                            default_values="0 0 0"
                            label="Low Point"
                            name="LowPoint"
                            number_of_elements="3" >
        <BoundsDomain default_mode="min"
                      mode="normal"
                      name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>This property defines one end of the direction vector
        (small scalar values).</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetHighPoint"
                            default_values="0 0 1"
                            label="High Point"
                            name="HighPoint"
                            number_of_elements="3" >
        <BoundsDomain default_mode="max"
                      mode="normal"
                      name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>This property defines the other end of the direction
        vector (large scalar values).</Documentation>
      </DoubleVectorProperty>
      <PropertyGroup panel_widget="InteractiveLine">
        <Property function="Point1WorldPosition" name="LowPoint" />
        <Property function="Point2WorldPosition" name="HighPoint" />
        <Property function="Input" name="Input" />
      </PropertyGroup>

      <Hints>
      </Hints>
      <!-- End ElevationFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractCTHPart"
                 label="Extract CTH Parts"
                 name="CTHPart">
      <Documentation long_help="Create a surface from a CTH volume fraction."
                     short_help="Extract a part from a CTH dataset.">Extract
                     CTH Parts is a specialized filter for visualizing the data
                     from a CTH simulation. It first converts the selected
                     cell-centered arrays to point-centered ones. It then
                     contours each array at a value of 0.5. The user has the
                     option of clipping the resulting surface(s) with a plane.
                     This filter only operates on unstructured data. It
                     produces polygonal output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input to the Extract CTH
        Parts filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetClipPlane"
                     label="Clip Type"
                     name="ClipPlane">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="None" />
          <Proxy group="implicit_functions"
                 name="Plane" />
        </ProxyListDomain>
        <Documentation>This property specifies whether to clip the dataset, and
        if so, it also specifies the parameters of the plane with which to
        clip.</Documentation>
      </ProxyProperty>
      <StringVectorProperty clean_command="RemoveVolumeArrayNames"
                            command="AddVolumeArrayName"
                            label="Volume Arrays"
                            name="VolumeArrays"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>This property specifies the name(s) of the volume
        fraction array(s) for generating parts.</Documentation>
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetVolumeFractionSurfaceValue"
                            default_values="0.1"
                            label="Volume Fraction Value"
                            name="VolumeFractionSurfaceValue"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>The value of this property is the volume fraction value
        for the surface.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty name="CapSurfaces"
                         command="SetCapping"
                         number_of_elements="1"
                         default_values="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>
          When enabled, volume surfaces are capped to produce visually closed
          surface.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty name="RemoveGhostCells"
                         command="SetRemoveGhostCells"
                         number_of_elements="1"
                         default_values="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>
          When set to false, the output surfaces will not hide contours
          extracted from ghost cells. This results in overlapping contours but
          overcomes holes.  Default is set to true.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty name="GenerateTriangles"
                         command="SetGenerateTriangles"
                         number_of_elements="1"
                         default_values="0"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>
          Triangulate results. When set to false, the internal cut and contour filters
          are told not to triangulate results if possible.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty name="GenerateSolidGeometry"
                         command="SetGenerateSolidGeometry"
                         number_of_elements="1"
                         default_values="0"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>
          Generate solid output with 3D cells. When set to false, 2D contours are generated.
        </Documentation>
      </IntVectorProperty>
      <!-- End CTHPart -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractEdges"
                 label="Extract Edges"
                 name="ExtractEdges">
      <Documentation long_help="Extract edges of 2D and 3D cells as lines."
                     short_help="Covert data to wireframe.">The Extract Edges
                     filter produces a wireframe version of the input dataset
                     by extracting all the edges of the dataset's cells as
                     lines. This filter operates on any type of data set and
                     produces polygonal output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Extract Edges
        filter.</Documentation>
      </InputProperty>
      <!-- End ExtractEdges -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDataSetSurfaceFilter"
                 label="Extract Surface"
                 name="DataSetSurfaceFilter">
      <Documentation long_help="Extract a 2D boundary surface using neighbor relations to eliminate internal faces."
                     short_help="Extract 2D boundary surface.">The Extract
                     Surface filter extracts the polygons forming the outer
                     surface of the input dataset. This filter operates on any
                     type of data and produces polygonal data as
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Extract Surface
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPieceInvariant"
                         default_values="1"
                         name="PieceInvariant"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, internal
        surfaces along process boundaries will be removed. NOTE: Enabling this
        option might cause multiple executions of the data source because more
        information is needed to remove internal surfaces.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetNonlinearSubdivisionLevel"
                         default_values="1"
                         name="NonlinearSubdivisionLevel"
                         number_of_elements="1">
        <IntRangeDomain max="4"
                        min="0"
                        name="range" />
        <Documentation>If the input is an unstructured grid with nonlinear
        faces, this parameter determines how many times the face is subdivided
        into linear faces. If 0, the output is the equivalent of its linear
        counterpart (and the midpoints determining the nonlinear interpolation
        are discarded). If 1, the nonlinear face is triangulated based on the
        midpoints. If greater than 1, the triangulated pieces are recursively
        subdivided to reach the desired subdivision. Setting the value to
        greater than 1 may cause some point data to not be passed even if no
        quadratic faces exist. This option has no effect if the input is not an
        unstructured grid.</Documentation>
      </IntVectorProperty>
      <!-- End DataSetSurfaceFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDataSetRegionSurfaceFilter"
                 label="Extract Region Surface"
                 name="DataSetRegionSurfaceFilter">
      <Documentation long_help="Extract a 2D boundary surface using neighbor relations to eliminate internal faces."
                     short_help="Extract 2D boundary surface.">The Extract
                     Surface filter extracts the polygons forming the outer
                     surface of the input dataset. This filter operates on any
                     type of data and produces polygonal data as
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Extract Surface
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPieceInvariant"
                         default_values="1"
                         name="PieceInvariant"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, internal
        surfaces along process boundaries will be removed. NOTE: Enabling this
        option might cause multiple executions of the data source because more
        information is needed to remove internal surfaces.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetNonlinearSubdivisionLevel"
                         default_values="1"
                         name="NonlinearSubdivisionLevel"
                         number_of_elements="1">
        <IntRangeDomain max="4"
                        min="0"
                        name="range" />
        <Documentation>If the input is an unstructured grid with nonlinear
        faces, this parameter determines how many times the face is subdivided
        into linear faces. If 0, the output is the equivalent of its linear
        counterpart (and the midpoints determining the nonlinear interpolation
        are discarded). If 1, the nonlinear face is triangulated based on the
        midpoints. If greater than 1, the triangulated pieces are recursively
        subdivided to reach the desired subdivision. Setting the value to
        greater than 1 may cause some point data to not be passed even if no
        quadratic faces exist. This option has no effect if the input is not an
        unstructured grid.</Documentation>
      </IntVectorProperty>

      <StringVectorProperty command="SetRegionArrayName"
                            default_values="material"
                            name="RegionArrayName"
                            number_of_elements="1">
        <Documentation>This property specifies the name of the material
        array for generating parts.</Documentation>
      </StringVectorProperty>

      <IntVectorProperty command="SetSingleSided"
                         default_values="1"
                         name="SingleSided"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1 (the default),
        surfaces along the boundary are 1 layer thick. Otherwise there is
        a surface for the material on each side.</Documentation>
      </IntVectorProperty>

      <StringVectorProperty command="SetMaterialPropertiesName"
                            default_values="material_properties"
                            name="MaterialPropertiesName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This the name of the input material property field data array</Documentation>
      </StringVectorProperty>

      <StringVectorProperty command="SetMaterialIDsName"
                            default_values="material_ids"
                            name="MaterialIDsName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This the name of the input and output material id field data array</Documentation>
      </StringVectorProperty>

      <StringVectorProperty command="SetMaterialPIDsName"
                            default_values="material_ancestors"
                            name="MaterialPIDsName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This the name of the output material ancestry id field data array</Documentation>
      </StringVectorProperty>

      <StringVectorProperty command="SetInterfaceIDsName"
                            default_values="interface_ids"
                            name="InterfaceIDsName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This the name of the input and output interface id field data array</Documentation>
      </StringVectorProperty>

      <!-- End DataSetRegionSurfaceFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVArrayCalculator"
                 name="Calculator">
      <Documentation long_help="Compute new attribute arrays as function of existing arrays."
                     short_help="Compute new attribute arrays.">
The Calculator filter computes a new data array or new point
coordinates as a function of existing scalar or vector arrays. If
point-centered arrays are used in the computation of a new data array,
the resulting array will also be point-centered. Similarly,
computations using cell-centered arrays will produce a new
cell-centered array. If the function is computing point coordinates,
the result of the function must be a three-component vector.

The Calculator interface operates similarly to a scientific
calculator. In creating the function to evaluate, the standard order
of operations applies. Each of the calculator functions is described
below. Unless otherwise noted, enclose the operand in parentheses
using the ( and ) buttons.

- Clear: Erase the current function (displayed in the read-only text
  box above the calculator buttons).
- /: Divide one scalar by another. The operands for this function are
  not required to be enclosed in parentheses.
- *: Multiply two scalars, or multiply a vector by a scalar (scalar multiple).
  The operands for this function are not required to be enclosed in parentheses.
- -: Negate a scalar or vector (unary minus), or subtract one scalar or vector
  from another. The operands for this function are not required to be enclosed
  in parentheses.
- +: Add two scalars or two vectors. The operands for this function are not
  required to be enclosed in parentheses.
- sin: Compute the sine of a scalar. cos: Compute the cosine of a scalar.
- tan: Compute the tangent of a scalar.
- asin: Compute the arcsine of a scalar.
- acos: Compute the arccosine of a scalar.
- atan: Compute the arctangent of a scalar.
- sinh: Compute the hyperbolic sine of a scalar.
- cosh: Compute the hyperbolic cosine of a scalar.
- tanh: Compute the hyperbolic tangent of a scalar.
- min: Compute minimum of two scalars.
- max: Compute maximum of two scalars.
- x^y: Raise one scalar to the power of another scalar. The operands for
  this function are not required to be enclosed in parentheses.
- sqrt: Compute the square root of a scalar.
- e^x: Raise e to the power of a scalar.
- log: Compute the logarithm of a scalar (deprecated. same as log10).
- log10: Compute the logarithm of a scalar to the base 10.
- ln: Compute the logarithm of a scalar to the base 'e'.
- ceil: Compute the ceiling of a scalar. floor: Compute the floor of a scalar.
- abs: Compute the absolute value of a scalar.
- v1.v2: Compute the dot product of two vectors. The operands for this
  function are not required to be enclosed in parentheses.
- cross: Compute cross product of two vectors.
- mag: Compute the magnitude of a vector.
- norm: Normalize a vector.

The operands are described below. The digits 0 - 9 and the decimal
point are used to enter constant scalar values. **iHat**, **jHat**,
and **kHat** are vector constants representing unit vectors in the X,
Y, and Z directions, respectively. The scalars menu lists the names of
the scalar arrays and the components of the vector arrays of either
the point-centered or cell-centered data.  The vectors menu lists the
names of the point-centered or cell-centered vector arrays. The
function will be computed for each point (or cell) using the scalar or
vector value of the array at that point (or cell). The filter operates
on any type of data set, but the input data set must have at least one
scalar or vector array. The arrays can be either point-centered or
cell-centered. The Calculator filter's output is of the same data set
type as the input.

The output array type can be specified as an advanced option with the default
being of a vtkDoubleArray.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkGraph"/>
          <DataType value="vtkTable"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" optional="1"/>
        <Documentation>This property specifies the input dataset (vtkDataSet, vtkTable or vtkGraph) to the
        Calculator filter. The scalar and vector variables may be chosen from
        this dataset's arrays.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetAttributeType"
                         default_values="0"
                         name="AttributeType"
                         number_of_elements="1">
        <FieldDataDomain name="enum">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>This property determines on which types of field data the computation is to
        be performed on.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCoordinateResults"
                         default_values="0"
                         name="CoordinateResults"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property determines whether the
        results of this computation should be used as point coordinates or as a
        new array.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetResultNormals"
                         default_values="0"
                         name="ResultNormals"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>Set whether to output results as point/cell
        normals. Outputting as normals is only valid with vector
        results. Point or cell normals are selected using
        AttributeMode.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetResultTCoords"
                         default_values="0"
                         name="ResultTCoords"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>Set whether to output results as point/cell
        texture coordinates.  Point or cell texture coordinates are
        selected using AttributeMode. 2-component texture coordinates
        cannot be generated at this time.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetResultArrayName"
                            default_values="Result"
                            name="ResultArrayName"
                            number_of_elements="1">
        <Documentation>This property contains the name for the output array
        containing the result of this computation.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetFunction"
                            name="Function"
                            number_of_elements="1"
                            panel_widget="calculator" >
        <Documentation>
This property contains the equation for computing the new
array.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetReplaceInvalidValues"
                         default_values="1"
                         label="Replace Invalid Results"
                         name="ReplaceInvalidValues"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>This property determines whether invalid values in the
        computation will be replaced with a specific value. (See the
        ReplacementValue property.)</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetReplacementValue"
                            default_values="0.0"
                            name="ReplacementValue"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>If invalid values in the computation are to be replaced
        with another value, this property contains that value.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetResultArrayType"
                         default_values="11"
                         label="Result Array Type"
                         name="ResultArrayType"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Char"
                 value="2" />
          <Entry text="Signed Char"
                 value="15" />
          <Entry text="Unsigned Char"
                 value="3" />
          <Entry text="Short"
                 value="4" />
          <Entry text="Unsigned Short"
                 value="5" />
          <Entry text="Int"
                 value="6" />
          <Entry text="Unsigned Int"
                 value="7" />
          <Entry text="Long"
                 value="8" />
          <Entry text="Unsigned Long"
                 value="9" />
          <Entry text="Float"
                 value="10" />
          <Entry text="Double"
                 value="11" />
          <Entry text="Id Type"
                 value="12" />
        </EnumerationDomain>
        <Documentation>This property determines what array type to output.
        The default is a vtkDoubleArray.</Documentation>
      </IntVectorProperty>
      <!-- End Calculator -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkFeatureEdges"
                 label="Feature Edges"
                 name="FeatureEdges">
      <Documentation long_help="This filter will extract edges along sharp edges of surfaces or boundaries of surfaces."
                     short_help="Extract edges that meet the feature criteria.">
                     The Feature Edges filter extracts various subsets of edges
                     from the input data set. This filter operates on polygonal
                     data and produces polygonal output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Feature Edges
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetBoundaryEdges"
                         default_values="1"
                         name="BoundaryEdges"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, boundary
        edges will be extracted. Boundary edges are defined as lines cells or
        edges that are used by only one polygon.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetFeatureEdges"
                         default_values="1"
                         name="FeatureEdges"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, feature edges
        will be extracted. Feature edges are defined as edges that are used by
        two polygons whose dihedral angle is greater than the feature angle.
        (See the FeatureAngle property.) Toggle whether to extract feature
        edges.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetNonManifoldEdges"
                         default_values="1"
                         label="Non-Manifold Edges"
                         name="NonManifoldEdges"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, non-manifold
        edges will be extracted. Non-manifold edges are defined as edges that
        are use by three or more polygons.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetManifoldEdges"
                         default_values="0"
                         name="ManifoldEdges"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, manifold
        edges will be extracted. Manifold edges are defined as edges that are
        used by exactly two polygons.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetColoring"
                         default_values="0"
                         name="Coloring"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, then the
        extracted edges are assigned a scalar value based on the type of the
        edge.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetFeatureAngle"
                            default_values="30.0"
                            name="FeatureAngle"
                            number_of_elements="1">
        <DoubleRangeDomain max="180"
                           min="0"
                           name="range" />
        <Documentation>The value of this property is used to define a feature
        edge. If the surface normal between two adjacent triangles is at least
        as large as this Feature Angle, a feature edge exists. (See the
        FeatureEdges property.)</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
      <!-- End FeatureEdges -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy name="ForceTime"
                 class="vtkForceTime"
                 label="Force Time">
      <Documentation>
        Filter used to explicitly request a specific time from the pipeline.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Documentation>
          This property specifies the input to the ForceTime filter.
        </Documentation>
      </InputProperty>
      <IntVectorProperty name="IgnorePipelineTime"
                         command="SetIgnorePipelineTime"
                         number_of_elements="1"
                         animatable="1"
                         default_values="1">
        <BooleanDomain  name="bool"/>
        <Documentation>
          If set to 0, this filter will do nothing, only shallow copy the
          input to the output. If set to 1, this filter will always request the
          ForcedTime to the pipeline, ignoring time requests.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty
        name="ForcedTime"
        command="SetForcedTime"
        number_of_elements="1"
        animatable="1"
        default_values="0.0">
        <DoubleRangeDomain name="range"/>
        <Documentation>
          This property specifies the time to request.
          If the IgnorePipelineTime property is set, then this value will override any time request in the VTK pipeline.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="enabled_state"
                                   property="IgnorePipelineTime"
                                   value="1" />
        </Hints>
      </DoubleVectorProperty>
      <Hints>
        <ShowInMenu category="Temporal" />
      </Hints>
      <!-- End ForceTime -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy name="TemporalArrayOperator"
                 label="Temporal Array Operator"
                 class="vtkTemporalArrayOperatorFilter">
      <Documentation>
        Filter used to perform an operation on a data array at 2 different timesteps.
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <InputArrayDomain attribute_type="any"
                          name="input_array"/>
        <Documentation>
          This property specifies the input to the TemporalArrayOperator filter.
        </Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputArray"
                            number_of_elements="5">
        <ArrayListDomain name="array_list"
                         input_domain_name="input_array">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property lists the name of the array from which to
        use.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty
        name="FirstTimeStepIndex"
        command="SetFirstTimeStepIndex"
        number_of_elements="1"
        animatable="1"
        default_values="0">
        <IntRangeDomain name="range"/>
        <Documentation>
          This property specifies the timestep index to use in the first part of the comparison computation
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetOperator"
                         default_values="0"
                         name="Operator"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="+"
                 value="0" />
          <Entry text="-"
                 value="1" />
          <Entry text="*"
                 value="2" />
          <Entry text="/"
                 value="3" />
        </EnumerationDomain>
        <Documentation>The property determines the operation to compute
        between the first and second timestep data.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty
        name="SecondTimeStepIndex"
        command="SetSecondTimeStepIndex"
        number_of_elements="1"
        animatable="1"
        default_values="0">
        <IntRangeDomain name="range"/>
        <Documentation>
          This property specifies the timestep index to use in the second part of the comparison computation
        </Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetOutputArrayNameSuffix"
                            name="OutputArrayNameSuffix"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This property set the suffix to be append to the output array name.
        If empty, output will be suffixed with '_' and the operation type.
        </Documentation>
      </StringVectorProperty>
      <Hints>
        <ShowInMenu category="Temporal" />
      </Hints>
      <!-- End TemporalArrayOperator -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageGradient"
                 label="Gradient"
                 name="Gradient">
      <Documentation long_help="This filter computes gradient vectors for an image/volume."
                     short_help="Compute gradient vectors.">The Gradient filter
                     computes the gradient vector at each point in an image or
                     volume. This filter uses central differences to compute
                     the gradients. The Gradient filter operates on uniform
                     rectilinear (image) data and produces image data
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input to the Gradient
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property lists the name of the array from which to
        compute the gradient.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetDimensionality"
                         default_values="3"
                         name="Dimensionality"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Two"
                 value="2" />
          <Entry text="Three"
                 value="3" />
        </EnumerationDomain>
        <Documentation>This property indicates whether to compute the gradient
        in two dimensions or in three. If the gradient is being computed in two
        dimensions, the X and Y dimensions are used.</Documentation>
      </IntVectorProperty>
      <!-- End Gradient -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGradientFilter"
                 label="Gradient Of Unstructured DataSet"
                 name="UnstructuredGradient">
      <Documentation long_help="Estimate the gradient for each point or cell in any type of dataset."
                     short_help="Compute gradients for any type of dataset.">
                     The Gradient (Unstructured) filter estimates the gradient
                     vector at each point or cell. It operates on any type of
                     vtkDataSet, and the output is the same type as the input.
                     If the dataset is a vtkImageData, use the Gradient filter
                     instead; it will be more efficient for this type of
                     dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>This property specifies the input to the Gradient
        (Unstructured) filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalar Array"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property lists the name of the scalar array from
        which to compute the gradient.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeGradient"
                         default_values="1"
                         name="ComputeGradient"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When this flag is on, the gradient filter will compute
        the gradient of the input array.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetResultArrayName"
                            default_values="Gradients"
                            name="ResultArrayName"
                            number_of_elements="1">
        <Documentation>This property provides a name for the output array
        containing the gradient vectors.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetFasterApproximation"
                         default_values="0"
                         name="FasterApproximation"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When this flag is on, the gradient filter will provide a
        less accurate (but close) algorithm that performs fewer derivative
        calculations (and is therefore faster). The error contains some
        smoothing of the output data and some possible errors on the boundary.
        This parameter has no effect when performing the gradient of cell
        data or when the input grid is not a vtkUnstructuredGrid.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetComputeDivergence"
                         default_values="0"
                         name="ComputeDivergence"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When this flag is on, the gradient filter will compute
        the divergence of a 3 component array.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetDivergenceArrayName"
                            default_values="Divergence"
                            name="DivergenceArrayName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This property provides a name for the output array
        containing the divergence vector.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeVorticity"
                         default_values="0"
                         name="ComputeVorticity"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When this flag is on, the gradient filter will compute
        the vorticity/curl of a 3 component array.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetVorticityArrayName"
                            default_values="Vorticity"
                            name="VorticityArrayName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This property provides a name for the output array
        containing the vorticity vector.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeQCriterion"
                         default_values="0"
                         name="ComputeQCriterion"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When this flag is on, the gradient filter will compute
        the Q-criterion of a 3 component array.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetQCriterionArrayName"
                            default_values="Q-criterion"
                            name="QCriterionArrayName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>This property provides a name for the output array
        containing Q criterion.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetContributingCellOption"
                         default_values="2"
                         name="ContributingCellOption"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="All"
                 value="0" />
          <Entry text="Patch"
                 value="1" />
          <Entry text="Dataset Max"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Specify which dimensions of cells should be used
        when computing gradient quantities. Default is to use
        the dataset's maximum cell dimension.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetReplacementValueOption"
                         default_values="1"
                         name="ReplacementValueOption"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Zero"
                 value="0" />
          <Entry text="NaN"
                 value="1" />
          <Entry text="Data Type Min"
                 value="2" />
          <Entry text="Data Type Max"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Specify what value to use for when the gradient quantities at a
        point can't be computed with the selected **ContributingCellOption**.</Documentation>
      </IntVectorProperty>
      <!-- End UnstructuredGradient -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageGradientMagnitude"
                 label="Gradient Magnitude"
                 name="GradientMagnitude">
      <Documentation long_help="Compute the magnitude of the gradient vectors for an image/volume."
                     short_help="Compute the gradient magnitude.">The Gradient
                     Magnitude filter computes the magnitude of the gradient
                     vector at each point in an image or volume. This filter
                     operates on uniform rectilinear (image) data and produces
                     image data output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input to the Gradient
        Magnitude filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetDimensionality"
                         default_values="3"
                         name="Dimensionality"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Two"
                 value="2" />
          <Entry text="Three"
                 value="3" />
        </EnumerationDomain>
        <Documentation>This property indicates whether to compute the gradient
        magnitude in two or three dimensions. If computing the gradient
        magnitude in 2D, the gradients in X and Y are used for computing the
        gradient magnitude.</Documentation>
      </IntVectorProperty>
      <!-- End Gradient -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGridConnectivity"
                 label="Grid Connectivity"
                 name="GridConnectivity">
      <Documentation long_help="Mass properties of connected fragments for unstructured grids."
                     short_help="Parallel connectivity and integration.">This
                     filter works on multiblock unstructured grid inputs and
                     also works in parallel. It Ignores any cells with a cell
                     data Status value of 0. It performs connectivity to
                     distict fragments separately. It then integrates
                     attributes of the fragments.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUnstructuredGrid" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the
        filter.</Documentation>
      </InputProperty>
      <!-- End Grid Fragment -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRectilinearGridConnectivity"
                 label="Rectilinear Grid Connectivity"
                 name="RectilinearGridConnectivity">
      <Documentation long_help="Parallel fragments extraction and attributes integration on rectilinear grids."
                     short_help="Parallel fragments extraction and attributes integration on rectilinear grids.">
      Extracts material fragments from multiblock vtkRectilinearGrid datasets
      based on the selected volume fraction array(s) and a fraction isovalue
      and integrates the associated attributes.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkRectilinearGrid" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input of the
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty clean_command="RemoveDoubleVolumeArrayNames"
                            command="AddDoubleVolumeArrayName"
                            label="Double Volume Arrays"
                            name="AddDoubleVolumeArrayName"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>This property specifies the name(s) of the volume
        fraction array(s) for generating parts.</Documentation>
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_DOUBLE"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
           not set the default value for this property
           using the domain when the proxy is created -->
          <NoDefault />
          <PropertyWidgetDecorator type="CTHArraySelectionDecorator">
            <Property name="AddFloatVolumeArrayName" />
            <Property name="AddUnsignedCharVolumeArrayName" />
          </PropertyWidgetDecorator>
        </Hints>
      </StringVectorProperty>
      <StringVectorProperty clean_command="RemoveFloatVolumeArrayNames"
                            command="AddFloatVolumeArrayName"
                            label="Float Volume Arrays"
                            name="AddFloatVolumeArrayName"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>This property specifies the name(s) of the volume
        fraction array(s) for generating parts.</Documentation>
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_FLOAT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
           not set the default value for this property
           using the domain when the proxy is created -->
          <NoDefault />
          <PropertyWidgetDecorator type="CTHArraySelectionDecorator">
            <Property name="AddDoubleVolumeArrayName" />
            <Property name="AddUnsignedCharVolumeArrayName" />
          </PropertyWidgetDecorator>
        </Hints>
      </StringVectorProperty>
      <StringVectorProperty clean_command="RemoveUnsignedCharVolumeArrayNames"
                            command="AddUnsignedCharVolumeArrayName"
                            label="Unsigned Character Volume Arrays"
                            name="AddUnsignedCharVolumeArrayName"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>This property specifies the name(s) of the volume
        fraction array(s) for generating parts.</Documentation>
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This overrides the GUI's default mechanism to
           not set the default value for this property
           using the domain when the proxy is created -->
          <NoDefault />
          <PropertyWidgetDecorator type="CTHArraySelectionDecorator">
            <Property name="AddDoubleVolumeArrayName" />
            <Property name="AddFloatVolumeArrayName" />
          </PropertyWidgetDecorator>
        </Hints>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetVolumeFractionSurfaceValue"
                            default_values="0.1"
                            label="Volume Fraction Value"
                            name="VolumeFractionSurfaceValue"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>The value of this property is the volume fraction value
        for the surface.</Documentation>
      </DoubleVectorProperty>
      <!-- End Rectilinear Grid Connectivity -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <!--<SourceProxy name="AMRDualClip" class="vtkAMRDualClip"
       label="AMR Clip">
      <Documentation
        short_help="Clip with decimation."
        long_help="Clip with scalars.  Tetrahedra.">
      </Documentation>
      <InputProperty
         name="Input"
         command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" attribute_type="cell"
                          number_of_components="1"/>
        <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>

      <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        animateable="0"
        label="Contour By">
        <ArrayListDomain name="array_list" attribute_type="Scalars">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          This property specifies the name of the cell scalar array from which the clip filter will compute clipped cells.
        </Documentation>
      </StringVectorProperty>

      <DoubleVectorProperty
        name="ContourValue"
        command="SetIsoValue"
        label="Isosurface"
        number_of_elements="1"
        default_values="1" >
        animateable="1">
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="SelectInputScalars" function="ArraySelection"/>
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>
          This property specifies the values at which to compute the isosurface.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
        name="DegenerateCells"
        command="SetEnableDegenerateCells"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is on, a transition mesh between levels is created.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MultiprocessCommunication"
        command="SetEnableMultiProcessCommunication"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          If this property is off, each process executes independently.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty
        name="MergePoints"
        command="SetEnableMergePoints"
        number_of_elements="1"
        animateable="1"
        default_values="1" >
        <BooleanDomain name="bool"/>
        <Documentation>
          Use more memory to merge points on the boundaries of blocks.
        </Documentation>
      </IntVectorProperty>
    </SourceProxy>-->
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVAMRDualClip"
                 label="AMR Dual Clip"
                 name="AMRDualClip">
      <Documentation long_help="Clip with scalars.  Tetrahedra."
                     short_help="Clip with decimation."></Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the
        filter.</Documentation>
        <InputArrayDomain attribute_type="cell"
                          name="input_array"
                          number_of_components="1" />
      </InputProperty>
      <StringVectorProperty clean_command="ClearInputCellArrayToProcess"
                            command="AddInputCellArrayToProcess"
                            name="SelectMaterialArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        clip filter will compute clipped cells.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetVolumeFractionSurfaceValue"
                            default_values="0.1"
                            label="Volume Fraction Value"
                            name="VolumeFractionSurfaceValue"
                            number_of_elements="1">
        <DoubleRangeDomain max="1.0"
                           min="0.0"
                           name="scalar_range" />
        <!--<RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="AddInputCellArrayToProcess" function="ArraySelection"/>
          </RequiredProperties>
        </ArrayRangeDomain>-->
        <Documentation>This property specifies the values at which to compute
        the isosurface.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetEnableInternalDecimation"
                         default_values="1"
                         name="InternalDecimation"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is on, internal tetrahedra are
        decimation</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetEnableMultiProcessCommunication"
                         default_values="1"
                         name="MultiprocessCommunication"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is off, each process executes
        independently.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetEnableMergePoints"
                         default_values="1"
                         name="MergePoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Use more memory to merge points on the boundaries of
        blocks.</Documentation>
      </IntVectorProperty>
      <!-- End PV AMR Dual Clip -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVAMRDualContour"
                 label="AMR Contour"
                 name="AMRDualContour">
      <Documentation short_help="Iso surface cell array."></Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the input of the
        filter.</Documentation>
        <DataTypeDomain name="input_type">
          <DataType value="vtkNonOverlappingAMR" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array"
                          number_of_components="1" />
      </InputProperty>
      <StringVectorProperty clean_command="ClearInputCellArrayToProcess"
                            command="AddInputCellArrayToProcess"
                            name="SelectMaterialArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR VTK_INT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        contour filter will compute contour cells.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetVolumeFractionSurfaceValue"
                            default_values="0.1"
                            label="Volume Fraction Value"
                            name="VolumeFractionSurfaceValue"
                            number_of_elements="1">
        <DoubleRangeDomain max="1.0"
                           min="0.0"
                           name="scalar_range" />
        <!--<RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="AddInputCellArrayToProcess" function="ArraySelection"/>
          </RequiredProperties>
        </ArrayRangeDomain>-->
        <Documentation>This property specifies the values at which to compute
        the isosurface.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetEnableCapping"
                         default_values="1"
                         name="Capping"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is on, the the boundary of the data set
        is capped.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetEnableDegenerateCells"
                         default_values="1"
                         name="DegenerateCells"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is on, a transition mesh between levels
        is created.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetEnableMultiProcessCommunication"
                         default_values="1"
                         name="MultiprocessCommunication"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is off, each process executes
        independently.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetSkipGhostCopy"
                         default_values="1"
                         name="SkipGhostCopy"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>A simple test to see if ghost values are already set
        properly.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetTriangulateCap"
                         default_values="1"
                         name="Triangulate"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Use triangles instead of quads on capping
        surfaces.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetEnableMergePoints"
                         default_values="1"
                         name="MergePoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Use more memory to merge points on the boundaries of
        blocks.</Documentation>
      </IntVectorProperty>
      <!-- End AMR Dual Contour -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAMRFragmentsFilter"
                 label="AMR Fragments Filter"
                 name="AMRFragmentsFilter">
      <Documentation short_help="Meta Fragment filter">Combines the running of
      AMRContour, AMRFragmentIntegration, AMRDualContour and ExtractCTHParts</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the volume input of the
        filter.</Documentation>
        <DataTypeDomain name="input_type">
          <DataType value="vtkNonOverlappingAMR" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array"
                          number_of_components="1" />
      </InputProperty>
      <StringVectorProperty clean_command="ClearInputVolumeArrayToProcess"
                            command="AddInputVolumeArrayToProcess"
                            name="SelectMaterialArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR VTK_INT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine fragments</Documentation>
      </StringVectorProperty>
      <StringVectorProperty clean_command="ClearInputMassArrayToProcess"
                            command="AddInputMassArrayToProcess"
                            name="SelectMassArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_DOUBLE VTK_FLOAT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine fragment mass</Documentation>
      </StringVectorProperty>
      <StringVectorProperty clean_command="ClearInputVolumeWeightedArrayToProcess"
                            command="AddInputVolumeWeightedArrayToProcess"
                            name="SelectVolumeWeightedArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_DOUBLE VTK_FLOAT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine volume weighted average values</Documentation>
      </StringVectorProperty>
      <StringVectorProperty clean_command="ClearInputMassWeightedArrayToProcess"
                            command="AddInputMassWeightedArrayToProcess"
                            name="SelectMassWeightedArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_DOUBLE VTK_FLOAT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine mass weighted average values</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetVolumeFractionSurfaceValue"
                            default_values="0.1"
                            label="Volume Fraction Value"
                            name="VolumeFractionSurfaceValue"
                            number_of_elements="1">
        <DoubleRangeDomain max="1.0"
                           min="0.0"
                           name="scalar_range" />
        <Documentation>This property specifies the values at which to compute
        the isosurface.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetExtractSurface"
                         default_values="0"
                         name="Extract Surface"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Whether or not to extract a surface from this data</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseWatertightSurface"
                         default_values="0"
                         name="Use Watertight Surface"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Whether the extracted surface should be watertight or not</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegrateFragments"
                         default_values="1"
                         name="Integrate Fragments"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Whether or not to integrate fragments in this data</Documentation>
      </IntVectorProperty>
      <!-- End AMR Fragments Filter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVAMRFragmentIntegration"
                 label="AMR Fragment Integration"
                 name="AMRFragmentIntegration">
      <Documentation short_help="Fragment Integration"></Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the volume input of the
        filter.</Documentation>
        <DataTypeDomain name="input_type">
          <DataType value="vtkNonOverlappingAMR" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array"
                          number_of_components="1" />
      </InputProperty>
      <StringVectorProperty clean_command="ClearInputVolumeArrayToProcess"
                            command="AddInputVolumeArrayToProcess"
                            name="SelectMaterialArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR VTK_INT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine fragments</Documentation>
      </StringVectorProperty>
      <StringVectorProperty clean_command="ClearInputMassArrayToProcess"
                            command="AddInputMassArrayToProcess"
                            name="SelectMassArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_DOUBLE VTK_FLOAT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine fragment mass</Documentation>
      </StringVectorProperty>
      <StringVectorProperty clean_command="ClearInputVolumeWeightedArrayToProcess"
                            command="AddInputVolumeWeightedArrayToProcess"
                            name="SelectVolumeWeightedArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_DOUBLE VTK_FLOAT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine volume weighted average values</Documentation>
      </StringVectorProperty>
      <StringVectorProperty clean_command="ClearInputMassWeightedArrayToProcess"
                            command="AddInputMassWeightedArrayToProcess"
                            name="SelectMassWeightedArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_DOUBLE VTK_FLOAT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine mass weighted average values</Documentation>
      </StringVectorProperty>
      <!-- End AMR Fragment Integration -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAMRConnectivity"
                 label="AMR Connectivity"
                 name="AMRConnectivity">
      <Documentation short_help="Fragment Identification"></Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the volume input of the
        filter.</Documentation>
        <DataTypeDomain name="input_type">
          <DataType value="vtkNonOverlappingAMR" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array"
                          number_of_components="1" />
      </InputProperty>
      <StringVectorProperty clean_command="ClearInputVolumeArrayToProcess"
                            command="AddInputVolumeArrayToProcess"
                            name="SelectMaterialArrays"
                            number_of_elements="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR VTK_INT"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
        <Documentation>This property specifies the cell arrays from which the
        analysis will determine fragments</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetVolumeFractionSurfaceValue"
                            default_values="0.1"
                            label="Volume Fraction Value"
                            name="VolumeFractionSurfaceValue"
                            number_of_elements="1">
        <DoubleRangeDomain max="1.0"
                           min="0.0"
                           name="scalar_range" />
        <!--<RequiredProperties>
            <Property name="Input" function="Input"/>
            <Property name="AddInputCellArrayToProcess" function="ArraySelection"/>
          </RequiredProperties>
        </ArrayRangeDomain>-->
        <Documentation>This property specifies the values at which to compute
        the isosurface.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetResolveBlocks"
                         default_values="1"
                         name="Resolve Blocks"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Resolve the fragments between blocks.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPropagateGhosts"
                         default_values="0"
                         name="Propagate Ghosts"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Propagate regionIds into the ghosts.</Documentation>
      </IntVectorProperty>
      <!-- End AMR Fragment Integration -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCTHSimpleSurface"
                 label="CTH Surface"
                 name="CTHSurface">
      <Documentation long_help="Not finished yet."
                     short_help="Creates surface for every block.">
                     </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <Documentation>This property specifies the input of the
        filter.</Documentation>
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
      </InputProperty>
      <!-- End CTH Simple Surface -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVLinearExtrusionFilter"
                 label="Linear Extrusion"
                 name="LinearExtrusionFilter">
      <Documentation long_help="This filter creates a swept surface defined by translating the input along a vector."
                     short_help="Generate a linear swept surface.">The Linear
                     Extrusion filter creates a swept surface by translating
                     the input dataset along a specified vector. This filter is
                     intended to operate on 2D polygonal data. This filter
                     operates on polygonal data and produces polygonal data
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Linear
        Extrusion filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetScaleFactor"
                            default_values="1.0"
                            name="ScaleFactor"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>The value of this property determines the distance along
        the vector the dataset will be translated. (A scale factor of 0.5 will
        move the dataset half the length of the vector, and a scale factor of 2
        will move it twice the vector's length.)</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetVector"
                            default_values="0 0 1"
                            name="Vector"
                            number_of_elements="3">
        <DoubleRangeDomain name="range" />
        <Documentation>The value of this property indicates the X, Y, and Z
        components of the vector along which to sweep the input
        dataset.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetCapping"
                         default_values="1"
                         name="Capping"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property indicates whether to cap the
        ends of the swept surface. Capping works by placing a copy of the input
        dataset on either end of the swept surface, so it behaves properly if
        the input is a 2D surface composed of filled polygons. If the input
        dataset is a closed solid (e.g., a sphere), then if capping is on
        (i.e., this property is set to 1), two copies of the data set will be
        displayed on output (the second translated from the first one along the
        specified vector). If instead capping is off (i.e., this property is
        set to 0), then an input closed solid will produce no
        output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPieceInvariant"
                         default_values="0"
                         name="PieceInvariant"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property determines whether the output
        will be the same regardless of the number of processors used to compute
        the result. The difference is whether there are internal polygonal
        faces on the processor boundaries. A value of 1 will keep the results
        the same; a value of 0 will allow internal faces on processor
        boundaries.</Documentation>
      </IntVectorProperty>
      <!-- End LinearExtrusionFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkLoopSubdivisionFilter"
                 label="Loop Subdivision"
                 name="LoopSubdivisionFilter">
      <Documentation long_help="This filter iteratively divides each triangle into four triangles.  New points are placed so the output surface is smooth."
                     short_help="Create a higher resolution and smoother surface.">
                     The Loop Subdivision filter increases the granularity of a
                     polygonal mesh. It works by dividing each triangle in the
                     input into four new triangles. It is named for Charles
                     Loop, the person who devised this subdivision scheme. This
                     filter only operates on triangles, so a data set that
                     contains other types of polygons should be passed through
                     the Triangulate filter before applying this filter to it.
                     This filter only operates on polygonal data (specifically
                     triangle meshes), and it produces polygonal
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Loop
        Subdivision filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="1"
                         command="SetNumberOfSubdivisions"
                         default_values="1"
                         label="Number of Subdivisions"
                         name="NumberOfSubdivisions"
                         number_of_elements="1">
        <IntRangeDomain max="4"
                        min="1"
                        name="range" />
        <Documentation>Set the number of subdivision iterations to perform.
        Each subdivision divides single triangles into four new
        triangles.</Documentation>
      </IntVectorProperty>
      <!-- End LoopSubdivisionFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPMaskPoints"
                 label="Mask Points"
                 name="MaskPoints">
      <Documentation long_help="Reduce the number of points.  This filter is often used before glyphing. Generating vertices is an option."
                     short_help="Reduce the number of points.">The Mask Points
                     filter reduces the number of points in the dataset. It
                     operates on any type of dataset, but produces only points
                     / vertices as output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Mask Points
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetOnRatio"
                         default_values="2"
                         name="OnRatio"
                         number_of_elements="1">
        <IntRangeDomain min="1"
                        name="range" />
        <Documentation>The value of this property specifies that every
        OnStride-th points will be retained in the output when not using Random
        (the skip or stride size for point ids). (For example, if the on ratio
        is 3, then the output will contain every 3rd point, up to the the
        maximum number of points.)</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfPoints"
                         default_values="5000"
                         label="Maximum Number of Points"
                         name="MaximumNumberOfPoints"
                         number_of_elements="1">
        <IntRangeDomain min="0"
                        name="range" />
        <Documentation>The value of this property indicates the maximum number
        of points in the output dataset.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetProportionalMaximumNumberOfPoints"
                         default_values="0"
                         label="Proportionally Distribute Maximum Number Of Points"
                         name="ProportionalMaximumNumberOfPoints"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When this is off, the maximum number of points is taken
        per processor when running in parallel (total number of points = number
        of processors * maximum number of points). When this is on, the maximum
        number of points is proportionally distributed across processors
        depending on the number of points per processor
        ("total number of points" is the same as "maximum number of points"
         maximum number of points per processor = number of points on a processor
         * maximum number of points / total number of points across all processors
        ).
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetOffset"
                         default_values="0"
                         name="Offset"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <IntRangeDomain min="0"
                        name="range" />
        <Documentation>The value of this property indicates the starting point
        id in the ordered list of input points from which to start
        masking.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetRandomMode"
                         default_values="0"
                         label="Random Sampling"
                         name="RandomMode"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to true, then the
        points in the output will be randomly selected from the input in
        various ways set by Random Mode; otherwise this filter will subsample
        point ids regularly.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetRandomModeType"
                         default_values="0"
                         label="Random Sampling Mode"
                         name="RandomModeType"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Randomized Id Strides"
                 value="0" />
          <Entry text="Random Sampling"
                 value="1" />
          <Entry text="Spatially Stratified Random Sampling"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Randomized Id Strides picks points with random id
        increments starting at Offset (the output probably isn't a
        statistically random sample). Random Sampling generates a statistically
        random sample of the input, ignoring Offset (fast - O(sample size)).
        Spatially Stratified Random Sampling is a variant of random sampling
        that splits the points into equal sized spatial strata before randomly
        sampling (slow - O(N log N)).</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetGenerateVertices"
                         default_values="0"
                         name="GenerateVertices"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>This property specifies whether to generate vertex cells
        as the topography of the output. If set to 1, the geometry (vertices)
        will be displayed in the rendering window; otherwise no geometry will
        be displayed.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetSingleVertexPerCell"
                         default_values="0"
                         name="SingleVertexPerCell"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>Tell filter to only generate one vertex per cell instead
        of multiple vertices in one cell.</Documentation>
      </IntVectorProperty>
      <!-- End MaskPoints -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageMedian3D"
                 name="Median">
      <Documentation long_help="Compute the median scalar values in a specified neighborhood for image/volume datasets."
                     short_help="Compute median values in a given neighborhood.">
                     The Median filter operates on uniform rectilinear (image
                     or volume) data and produces uniform rectilinear output.
                     It replaces the scalar value at each pixel / voxel with
                     the median scalar value in the specified surrounding
                     neighborhood. Since the median operation removes outliers,
                     this filter is useful for removing high-intensity,
                     low-probability noise (shot noise).</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input to the Median
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>The value of this property lists the name of the scalar
        array to use in computing the median.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetKernelSize"
                         default_values="1 1 1"
                         name="KernelSize"
                         number_of_elements="3">
        <IntRangeDomain name="range" />
        <Documentation>The value of this property specifies the number of
        pixels/voxels in each dimension to use in computing the median to
        assign to each pixel/voxel. If the kernel size in a particular
        dimension is 1, then the median will not be computed in that
        direction.</Documentation>
      </IntVectorProperty>
      <!-- End Median -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkMeshQuality"
                 label="Mesh Quality"
                 name="MeshQuality">
      <Documentation long_help="This filter creates a new cell array containing a geometric measure of each cell's fitness. Different quality measures can be chosen for different cell shapes."
                     short_help="Evaluate geometric mesh quality.">This filter
                     creates a new cell array containing a geometric measure of
                     each cell's fitness. Different quality measures can be
                     chosen for different cell shapes. Supported shapes include linear
                     triangles, quadrilaterals, tetrahedra, and hexahedra. For
                     other shapes, a value of 0 is assigned.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Mesh Quality
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetTriangleQualityMeasure"
                         default_values="2"
                         name="TriangleQualityMeasure"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Area"
                 value="28" />
          <Entry text="Aspect Ratio"
                 value="1" />
          <Entry text="Aspect Frobenius"
                 value="3" />
          <Entry text="Condition"
                 value="9" />
          <Entry text="Distortion"
                 value="15" />
          <Entry text="Edge Ratio"
                 value="0" />
          <Entry text="Maximum Angle"
                 value="8" />
          <Entry text="Minimum Angle"
                 value="6" />
          <Entry text="Scaled Jacobian"
                 value="10" />
          <Entry text="Radius Ratio"
                 value="2" />
          <Entry text="Relative Size Squared"
                 value="12" />
          <Entry text="Shape"
                 value="13" />
          <Entry text="Shape and Size"
                 value="14" />
        </EnumerationDomain>
        <Documentation>This property indicates which quality measure will be
        used to evaluate triangle quality. The radius ratio is the size of a
        circle circumscribed by a triangle's 3 vertices divided by the size of
        a circle tangent to a triangle's 3 edges. The edge ratio is the ratio
        of the longest edge length to the shortest edge length.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetQuadQualityMeasure"
                         default_values="0"
                         name="QuadQualityMeasure"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Area"
                 value="28" />
          <Entry text="Aspect Ratio"
                 value="1" />
          <Entry text="Condition"
                 value="9" />
          <Entry text="Distortion"
                 value="15" />
          <Entry text="Edge Ratio"
                 value="0" />
          <Entry text="Jacobian"
                 value="25" />
          <Entry text="Maximum Aspect Frobenius"
                 value="5" />
          <Entry text="Maximum Aspect Frobenius"
                 value="5" />
          <Entry text="Maximum Edge Ratio"
                 value="16" />
          <Entry text="Mean Aspect Frobenius"
                 value="4" />
          <Entry text="Minimum Angle"
                 value="6" />
          <Entry text="Oddy"
                 value="23" />
          <Entry text="Radius Ratio"
                 value="2" />
          <Entry text="Relative Size Squared"
                 value="12" />
          <Entry text="Scaled Jacobian"
                 value="10" />
          <Entry text="Shape"
                 value="13" />
          <Entry text="Shape and Size"
                 value="14" />
          <Entry text="Shear"
                 value="11" />
          <Entry text="Shear and Size"
                 value="24" />
          <Entry text="Skew"
                 value="17" />
          <Entry text="Stretch"
                 value="20" />
          <Entry text="Taper"
                 value="18" />
          <Entry text="Warpage"
                 value="26" />
        </EnumerationDomain>
        <Documentation>This property indicates which quality measure will be
        used to evaluate quadrilateral quality.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetTetQualityMeasure"
                         default_values="2"
                         name="TetQualityMeasure"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Edge Ratio"
                 value="0" />
          <Entry text="Aspect Beta"
                 value="29" />
          <Entry text="Aspect Gamma"
                 value="27" />
          <Entry text="Aspect Frobenius"
                 value="3" />
          <Entry text="Aspect Ratio"
                 value="1" />
          <Entry text="Collapse Ratio"
                 value="7" />
          <Entry text="Condition"
                 value="9" />
          <Entry text="Distortion"
                 value="15" />
          <Entry text="Jacobian"
                 value="25" />
          <Entry text="Minimum Dihedral Angle"
                 value="6" />
          <Entry text="Radius Ratio"
                 value="2" />
          <Entry text="Relative Size Squared"
                 value="12" />
          <Entry text="Scaled Jacobian"
                 value="10" />
          <Entry text="Shape"
                 value="13" />
          <Entry text="Shape and Size"
                 value="14" />
          <Entry text="Volume"
                 value="19" />
        </EnumerationDomain>
        <Documentation>This property indicates which quality measure will be
        used to evaluate tetrahedral quality. The radius ratio is the size of a
        sphere circumscribed by a tetrahedron's 4 vertices divided by the size
        of a circle tangent to a tetrahedron's 4 faces. The edge ratio is the
        ratio of the longest edge length to the shortest edge length. The
        collapse ratio is the minimum ratio of height of a vertex above the
        triangle opposite it divided by the longest edge of the opposing
        triangle across all vertex/triangle pairs.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetHexQualityMeasure"
                         default_values="5"
                         name="HexQualityMeasure"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Diagonal"
                 value="21" />
          <Entry text="Dimension"
                 value="22" />
          <Entry text="Distortion"
                 value="15" />
          <Entry text="Edge Ratio"
                 value="0" />
          <Entry text="Jacobian"
                 value="25" />
          <Entry text="Maximum Edge Ratio"
                 value="16" />
          <Entry text="Maximum Aspect Frobenius"
                 value="5" />
          <Entry text="Mean Aspect Frobenius"
                 value="4" />
          <Entry text="Oddy"
                 value="23" />
          <Entry text="Relative Size Squared"
                 value="12" />
          <Entry text="Scaled Jacobian"
                 value="10" />
          <Entry text="Shape"
                 value="13" />
          <Entry text="Shape and Size"
                 value="14" />
          <Entry text="Shear"
                 value="11" />
          <Entry text="Shear and Size"
                 value="24" />
          <Entry text="Skew"
                 value="17" />
          <Entry text="Stretch"
                 value="20" />
          <Entry text="Taper"
                 value="18" />
          <Entry text="Volume"
                 value="19" />
        </EnumerationDomain>
        <Documentation>This property indicates which quality measure will be
        used to evaluate hexahedral quality.</Documentation>
      </IntVectorProperty>
      <!-- End MeshQuality -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCellValidator"
                 label="Validate Cells"
                 name="ValidateCells">
      <Documentation long_help="vtkCellValidator accepts as input a dataset and adds integral cell data
 to it corresponding to the validity of each cell. The validity field
 encodes a bitfield for identifying problems that prevent a cell from standard
 use, including:

   WrongNumberOfPoints: filters assume that a cell has access to the
                        appropriate number of points that comprise it. This
                        assumption is often tacit, resulting in unexpected
                        behavior when the condition is not met. This check
                        simply confirms that the cell has the minimum number
                        of points needed to describe it.

   IntersectingEdges: cells that incorrectly describe the order of their
                      points often manifest with intersecting edges or
                      intersecting faces. Given a tolerance, this check
                      ensures that two edges from a two-dimensional cell
                      are separated by at least the tolerance (discounting
                      end-to-end connections).

   IntersectingFaces: cells that incorrectly describe the order of their
                      points often manifest with intersecting edges or
                      intersecting faces. Given a tolerance, this check
                      ensures that two faces from a three-dimensional cell
                      do not intersect.

   NoncontiguousEdges: another symptom of incorrect point ordering within a
                       cell is the presence of noncontiguous edges where
                       contiguous edges are otherwise expected. Given a
                       tolerance, this check ensures that edges around the
                       perimeter of a two-dimensional cell are contiguous.

   Nonconvex: many algorithms implicitly require that all input three-
              dimensional cells be convex. This check uses the generic
              convexity checkers implemented in vtkPolygon and vtkPolyhedron
              to test this requirement.

   FacesAreOrientedIncorrectly: All three-dimensional cells have an implicit
                                expectation for the orientation of their
                                faces. While the convention is unfortunately
                                inconsistent across cell types, it is usually
                                required that cell faces point outward. This
                                check tests that the faces of a cell point in
                                the direction required by the cell type,
                                taking into account the cell types with
                                nonstandard orientation requirements.
"
        short_help="Compute cell validities."></Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Cell Validation filter.</Documentation>
      </InputProperty>
      <!-- End ValidateCells -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPCellSizeFilter"
                 label="Cell Size"
                 name="CellSize">
      <Documentation long_help="This filter computes sizes for 0D (1 for vertex and number of points in for polyvertex), 1D (length), 2D (area)
        and 3D (volume) cells. ComputePoint, ComputeLength, ComputeArea and ComputeVolume options can be used to specify what dimension
        cells to compute for. Alternatively, the ComputeHighestDimension will compute sizes for only the highest dimension cells for
        the vtkDataSet. The values are placed in a cell data array named ArrayName. The SumSize option will give a summation of the
        computed cell sizes for a vtkDataSet and for composite datasets will contain a sum of the underlying blocks."
        short_help="Compute cell sizes.">This filter computes sizes for 0D (1 for vertex and number of points in for polyvertex), 1D (length), 2D (area)
        and 3D (volume) cells. ComputeVertexCount, ComputeLength, ComputeArea and ComputeVolume options can be used to specify what dimension
        cells to compute for. The values are placed in a cell data array named ArrayName. The ComputeSum option will give a summation of the
        computed cell sizes for a vtkDataSet and for composite datasets will contain a sum of the underlying blocks in the top-level block.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Cell Size filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetComputeVertexCount"
                         default_values="1"
                         name="ComputeVertexCount"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute the number of points in 0D cells.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetVertexCountArrayName"
                            default_values="VertexCount"
                            name="VertexCountArrayName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>
          Specify the name of the array to store the 0D cell vertex count and optionally the field data vertex count sum.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeLength"
                         default_values="1"
                         name="ComputeLength"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute the length of 1D cells.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetLengthArrayName"
                            default_values="Length"
                            name="LengthArrayName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>
          Specify the name of the array to store the 1D cell length and optionally the field data length sum.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeArea"
                         default_values="1"
                         name="ComputeArea"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute the area of 2D cells.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetAreaArrayName"
                            default_values="Area"
                            name="AreaArrayName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>
          Specify the name of the array to store 2D cell area and optionally the field data area sum.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeVolume"
                         default_values="1"
                         name="ComputeVolume"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute the volume of 3D cells .</Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetVolumeArrayName"
                            default_values="Volume"
                            name="VolumeArrayName"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>
          Specify the name of the array to store 3D cell volume and optionally the field data volume sum.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeSum"
                         default_values="0"
                         name="ComputeSum"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to sum the computed sizes of cells in datasets. The result is stored in field data.</Documentation>
      </IntVectorProperty>
      <!-- End CellSize -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPPolyDataNormals"
                 label="Generate Surface Normals"
                 name="PolyDataNormals">
      <Documentation long_help="This filter will produce surface normals used for smooth shading. Splitting is used to avoid smoothing across feature edges."
                     short_help="Produce surface point normals.">This filter
                     generates surface normals at the points of the input
                     polygonal dataset to provide smooth shading of the
                     dataset. The resulting dataset is also polygonal. The
                     filter works by calculating a normal vector for each
                     polygon in the dataset and then averaging the normals at
                     the shared points.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Normals
        Generation filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetFeatureAngle"
                            default_values="30"
                            name="FeatureAngle"
                            number_of_elements="1">
        <DoubleRangeDomain max="180"
                           min="0"
                           name="range" />
        <Documentation>The value of this property defines a feature edge. If
        the surface normal between two adjacent triangles is at least as large
        as this Feature Angle, a feature edge exists. If Splitting is on,
        points are duplicated along these feature edges. (See the Splitting
        property.)</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetSplitting"
                         default_values="1"
                         name="Splitting"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This property controls the splitting of sharp edges. If
        sharp edges are split (property value = 1), then points are duplicated
        along these edges, and separate normals are computed for both sets of
        points to give crisp (rendered) surface definition.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetConsistency"
                         default_values="1"
                         name="Consistency"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property controls whether consistent
        polygon ordering is enforced. Generally the normals for a data set
        should either all point inward or all point outward. If the value of
        this property is 1, then this filter will reorder the points of cells
        that whose normal vectors are oriented the opposite direction from the
        rest of those in the data set.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetFlipNormals"
                         default_values="0"
                         name="FlipNormals"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is 1, this filter will
        reverse the normal direction (and reorder the points accordingly) for
        all polygons in the data set; this changes front-facing polygons to
        back-facing ones, and vice versa. You might want to do this if your
        viewing position will be inside the data set instead of outside of
        it.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetNonManifoldTraversal"
                         default_values="1"
                         label="Non-Manifold Traversal"
                         name="NonManifoldTraversal"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Turn on/off traversal across non-manifold edges. Not
        traversing non-manifold edges will prevent problems where the
        consistency of polygonal ordering is corrupted due to topological
        loops.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetComputeCellNormals"
                         default_values="0"
                         name="ComputeCellNormals"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This filter computes the normals at the points in the
        data set. In the process of doing this it computes polygon normals too.
        If you want these normals to be passed to the output of this filter,
        set the value of this property to 1.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPieceInvariant"
                         default_values="1"
                         name="PieceInvariant"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Turn this option to to produce the same results
        regardless of the number of processors used (i.e., avoid seams along
        processor boundaries). Turn this off if you do want to process ghost
        levels and do not mind seams.</Documentation>
      </IntVectorProperty>
      <!-- End  PolyDataNormals -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPolyDataTangents"
                 label="Generate Surface Tangents"
                 name="PolyDataTangents">
      <Documentation long_help="This filter will produce surface tangents used for normal mapping."
                     short_help="Produce surface point tangents.">This filter
                     generates surface tangents at the points of the input
                     polygonal dataset based on the normals and the texture coordinates.
                     The resulting dataset is also polygonal. The tangents are required when using
                     a normal texture.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Tangents
        Generation filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetComputeCellTangents"
                         default_values="0"
                         name="ComputeCellTangents"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This filter computes the tangents at the points in the
        data set. In the process of doing this it computes polygon tangents too.
        If you want these normals to be passed to the output of this filter,
        set the value of this property to 1.</Documentation>
      </IntVectorProperty>
      <!-- End  PolyDataTangents -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPOutlineFilter"
                 label="Outline"
                 name="OutlineFilter">
      <Documentation long_help="This filter generates a bounding box representation of the input."
                     short_help="Generates a bounding box.">The Outline filter
                     generates an axis-aligned bounding box for the input
                     dataset. This filter operates on any type of dataset and
                     produces polygonal output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkGraph" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Outline
        filter.</Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
      <!-- End  OutlineFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPOutlineCornerFilter"
                 label="Outline Corners"
                 name="OutlineCornerFilter">
      <Documentation long_help="This filter generates a bounding box representation of the input. It only displays the corners of the bounding box."
                     short_help="Generates corners of a bounding box.">The
                     Outline Corners filter generates the corners of a bounding
                     box for the input dataset. This filter operates on any
                     type of dataset and produces polygonal
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Outline Corners
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetCornerFactor"
                            default_values="0.2"
                            name="CornerFactor"
                            number_of_elements="1">
        <DoubleRangeDomain max="0.5"
                           min="0.001"
                           name="range" />
        <Documentation>The value of this property sets the size of the corners
        as a percentage of the length of the corresponding bounding box
        edge.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
      <!-- End  OutlineCornerFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkProcessIdScalars"
                 label="Process Id Scalars"
                 name="ProcessIdScalars">
      <Documentation long_help="This filter uses colors to show how data is partitioned across processes."
                     short_help="Generate point scalars from process id.">The
                     Process Id Scalars filter assigns a unique scalar value to
                     each piece of the input according to which processor it
                     resides on. This filter operates on any type of data when
                     ParaView is run in parallel. It is useful for determining
                     whether your data is load-balanced across the processors
                     being used. The output data set type is the same as that
                     of the input.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Process Id
        Scalars filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetRandomMode"
                         default_values="0"
                         name="RandomMode"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property determines whether to use
        random id values for the various pieces. If set to 1, the unique value
        per piece will be chosen at random; otherwise the unique value will
        match the id of the process.</Documentation>
      </IntVectorProperty>
      <!-- End ProcessIdScalars -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPointDataToCellData"
                 label="Point Data to Cell Data"
                 name="PointDataToCellData">
      <Documentation long_help="Create cell attributes by averaging point attributes."
                     short_help="Convert point data to cell data.">The Point
                     Data to Cell Data filter averages the values of the point
                     attributes of the points of a cell to compute cell
                     attributes. This filter operates on any type of dataset,
                     and the output dataset is the same type as the
                     input.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array" />
        <FixedTypeDomain name="fixed_type" />
        <Documentation>This property specifies the input to the Point Data to
        Cell Data filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetProcessAllArrays"
                         default_values="1"
                         name="ProcessAllArrays"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property controls whether all input
        point arrays will be processed and converted into cell arrays.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearPointDataArrays"
                            command="AddPointDataArray"
                            name="PointDataArrays"
                            label="Point Data Array to process"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>Add a point array by name to be converted to cell array.</Documentation>
        <ArrayListDomain input_domain_name="input_array" name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="ProcessAllArrays" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
      </StringVectorProperty>
      <IntVectorProperty command="SetPassPointData"
                         default_values="0"
                         name="PassPointData"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>The value of this property controls whether the input
        point data will be passed to the output. If set to 1, then the input
        point data is passed through to the output; otherwise, only generated
        cell data is placed into the output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCategoricalData"
                         default_values="0"
                         name="CategoricalData"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>Control whether the input point data is to be
        treated as categorical. If  the data is categorical, then the
        resultant cell data will be determined by  a majority rules
        vote, with ties going to the smaller value.</Documentation>
      </IntVectorProperty>
      <!-- End PointDataToCellData -->
    </SourceProxy>
    <!--
  <SourceProxy
      name="QuadraturePointStatistics"
      class="vtkQuadraturePointStatistics"
      label="Quadrature Point Statistics">

    <Documentation
        long_help="Compute basics statistics over data fields interpolated to quadrature points."
        short_help="Compute basics statistics over data fields interpolated to quadrature points.">
        "Compute basics statistics over data fields interpolated to quadrature points."
    </Documentation>

    <InputProperty
        name="Input"
        command="SetInputConnection">

      <ProxyGroupDomain name="groups">
        <Group name="sources"/>
        <Group name="filters"/>
      </ProxyGroupDomain>

      <DataTypeDomain name="input_type">
        <DataType value="vtkUnstructuredGrid"/>
      </DataTypeDomain>
      <Documentation>This property specifies the input of the filter.</Documentation>
    </InputProperty>
  </SourceProxy>
   ############################################################################ -->
    <!-- ############################################################################ -->
    <SourceProxy class="vtkQuadraturePointInterpolator"
                 label="Interpolate to Quadrature Points"
                 name="QuadraturePointInterpolator">
      <Documentation long_help="Create scalar/vector data arrays interpolated to quadrature points."
                     short_help="Create scalar/vector data arrays interpolated to quadrature points.">
      "Create scalar/vector data arrays interpolated to quadrature
      points."</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUnstructuredGrid" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell" name="input_array" />
        <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="QuadratureSchemeDefinition"
                            label="Quadrature Scheme Def"
                            number_of_elements="5">
        <Documentation>Specifies the offset array from which we interpolate
        values to quadrature points.</Documentation>
        <ArrayListDomain attribute_type="Scalars"
                         key_locations="vtkQuadratureSchemeDefinition"
                         key_names="DICTIONARY"
                         key_strategies="NEED_KEY"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
      </StringVectorProperty>
    </SourceProxy>
    <!-- ############################################################################ -->
    <SourceProxy class="vtkQuadraturePointsGenerator"
                 label="Generate Quadrature Points"
                 name="QuadraturePointsGenerator">
      <Documentation long_help="Create a point set with data at quadrature points."
                     short_help="Create a point set with data at quadrature points.">
                     "Create a point set with data at quadrature
                     points."</Documentation>
      <OutputPort index="0" name="Quadrature Points" />
      <InputProperty command="SetInputConnection" name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUnstructuredGrid" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell" name="input_array" />
        <Documentation>This property specifies the input of the filter.</Documentation>
      </InputProperty>
      <!-- Source Array-->
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="QuadratureSchemeDefinition"
                            label="Quadrature Scheme Def"
                            number_of_elements="5">
        <Documentation>Specifies the offset array from which we generate
        quadrature points.</Documentation>
        <ArrayListDomain attribute_type="Scalars"
                         key_locations="vtkQuadratureSchemeDefinition"
                         key_names="DICTIONARY"
                         key_strategies="NEED_KEY"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
      </StringVectorProperty>
    </SourceProxy>
    <!-- ############################################################################ -->
    <SourceProxy class="vtkQuadratureSchemeDictionaryGenerator"
                 label="Generate Quadrature Scheme Dictionary"
                 name="QuadratureSchemeDictionaryGenerator">
      <Documentation long_help="Generate quadrature scheme dictionaries in data sets that do not have them."
                     short_help="Generate quadrature scheme dictionaries in data sets that do not have them.">
      Generate quadrature scheme dictionaries in data sets that do not have
      them.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUnstructuredGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the
        filter.</Documentation>
      </InputProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkQuadricClustering"
                 label="Quadric Clustering"
                 name="QuadricClustering">
      <Documentation long_help="This filter is the same filter used to generate level of detail for ParaView.  It uses a structured grid of bins and merges all points contained in each bin."
                     short_help="Simplify polygonal models.">The Quadric
                     Clustering filter produces a reduced-resolution polygonal
                     approximation of the input polygonal dataset. This filter
                     is the one used by ParaView for computing LODs. It uses
                     spatial binning to reduce the number of points in the data
                     set; points that lie within the same spatial bin are
                     collapsed into one representative point.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Quadric
        Clustering filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetNumberOfDivisions"
                         default_values="50 50 50"
                         label="Number of Dimensions"
                         name="NumberOfDivisions"
                         number_of_elements="3">
        <IntRangeDomain name="range" />
        <Documentation>This property specifies the number of bins along the X,
        Y, and Z axes of the data set.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseInputPoints"
                         default_values="1"
                         name="UseInputPoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, the
        representative point for each bin is selected from one of the input
        points that lies in that bin; the input point that produces the least
        error is chosen. If the value of this property is 0, the location of
        the representative point is calculated to produce the least error
        possible for that bin, but the point will most likely not be one of the
        input points.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseFeatureEdges"
                         default_values="0"
                         name="UseFeatureEdges"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, feature edge quadrics will
        be used to maintain the boundary edges along processor
        divisions.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseFeaturePoints"
                         default_values="0"
                         name="UseFeaturePoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, feature point quadrics
        will be used to maintain the boundary points along processor
        divisions.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCopyCellData"
                         default_values="1"
                         name="CopyCellData"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the cell data from the
        input will be copied to the output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseInternalTriangles"
                         default_values="0"
                         name="UseInternalTriangles"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, triangles completely
        contained in a spatial bin will be included in the computation of the
        bin's quadrics. When this property is set to 0, the filters operates
        faster, but the resulting surface may not be as
        well-behaved.</Documentation>
      </IntVectorProperty>
      <!-- End QuadricClustering -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRandomAttributeGenerator"
                 label="Random Attributes"
                 name="RandomAttributeGenerator">
      <Documentation long_help=
                     "This filter creates a new random attribute
                      array and sets it as the default array."
                     short_help="Creates random data attributes.">
        The Random Attributes filter creates random attributes
        including scalars and vectors. These attributes can be
        generated as point data or cell data. The generation of each
        component is normalized between a user-specified minimum and
        maximum value.

        This filter provides that capability to specify the data type
        of the attributes and the range for each of the components.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Random Scalars
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty
          name="DataType"
          command="SetDataType"
          number_of_elements="1"
          default_values="3">
        <EnumerationDomain name="enum">
          <Entry value="1" text="Bit"/>
          <Entry value="2" text="Char"/>
          <Entry value="3" text="UnsignedChar"/>
          <Entry value="4" text="Short"/>
          <Entry value="5" text="UnsignedShort"/>
          <Entry value="6" text="Int"/>
          <Entry value="7" text="UnsignedInt"/>
          <Entry value="8" text="Long"/>
          <Entry value="9" text="UnsignedLong"/>
          <Entry value="10" text="Float"/>
          <Entry value="11" text="Double"/>
          <Entry value="12" text="vtkIdType"/>
        </EnumerationDomain>
        <Documentation>
          Specify the type of array to create (all components of this
          array are of this type). This holds true for all arrays that
          are created.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetComponentRange"
                            default_values="0 255"
                            name="ComponentRange"
                            number_of_elements="2">
        <Documentation>Set the range values (minimum and maximum) for
        each component. This applies to all data that is
        generated.</Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty
          name="AttributesConstantPerBlock"
          command="SetAttributesConstantPerBlock"
          number_of_elements="1"
          default_values="0">
        <BooleanDomain name="bool"/>
        <Documentation>Indicate that the generated attributes are
        constant within a block. This can be used to highlight
        blocks in a composite dataset.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty
          name="GeneratePointScalars"
          command="SetGeneratePointScalars"
          number_of_elements="1"
          default_values="0">
        <BooleanDomain name="bool"/>
        <Documentation>Indicate that point scalars are to be
        generated.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty
          name="GeneratePointVectors"
          command="SetGeneratePointVectors"
          number_of_elements="1"
          default_values="0">
        <BooleanDomain name="bool"/>
        <Documentation>Indicate that point vectors are to be
        generated.</Documentation>
      </IntVectorProperty>

      <IntVectorProperty
          name="GenerateCellScalars"
          command="SetGenerateCellScalars"
          number_of_elements="1"
          default_values="0">
        <BooleanDomain name="bool"/>
        <Documentation>Indicate that point scalars are to be
        generated.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty
          name="GenerateCellVectors"
          command="SetGenerateCellVectors"
          number_of_elements="1"
          default_values="1">
        <BooleanDomain name="bool"/>
        <Documentation>Indicate that point vectors are to be
        generated.</Documentation>
      </IntVectorProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkBrownianPoints"
                 label="Random Vectors"
                 name="BrownianPoints">
      <Documentation long_help="This filter creates a new 3-component point data array and sets it as the default vector array. It uses a random number generator to create values."
                     short_help="Create a new random vector array.">The Random
                     Vectors filter generates a point-centered array of random
                     vectors. It uses a random number generator to determine
                     the components of the vectors. This filter operates on any
                     type of data set, and the output data set will be of the
                     same type as the input.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Random Vectors
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetMinimumSpeed"
                            default_values="0"
                            name="MinimumSpeed"
                            number_of_elements="1">
        <DoubleRangeDomain min="0"
                           name="range" />
        <Documentation>This property specifies the minimum length of the random
        point vectors generated.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMaximumSpeed"
                            default_values="1"
                            name="MaximumSpeed"
                            number_of_elements="1">
        <DoubleRangeDomain min="0"
                           name="range" />
        <Documentation>This property specifies the maximum length of the random
        point vectors generated.</Documentation>
      </DoubleVectorProperty>
      <!-- End BrownianPoints -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPReflectionFilter"
                 label="Reflect"
                 name="ReflectionFilter">
      <Documentation long_help="This filter takes the union of the input and its reflection over an axis-aligned plane."
                     short_help="Reflect input over an axis aligned plane.">The
                     Reflect filter reflects the input dataset across the
                     specified plane. This filter operates on any type of data
                     set and produces an unstructured grid
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Reflect
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPlane"
                         default_values="0"
                         name="Plane"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="X Min"
                 value="0" />
          <Entry text="Y Min"
                 value="1" />
          <Entry text="Z Min"
                 value="2" />
          <Entry text="X Max"
                 value="3" />
          <Entry text="Y Max"
                 value="4" />
          <Entry text="Z Max"
                 value="5" />
          <Entry text="X"
                 value="6" />
          <Entry text="Y"
                 value="7" />
          <Entry text="Z"
                 value="8" />
        </EnumerationDomain>
        <Documentation>The value of this property determines which plane to
        reflect across. If the value is X, Y, or Z, the value of the Center
        property determines where the plane is placed along the specified axis.
        The other six options (X Min, X Max, etc.) place the reflection plane
        at the specified face of the bounding box of the input
        dataset.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetCenter"
                            default_values="0.0"
                            name="Center"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>If the value of the Plane property is X, Y, or Z, then
        the value of this property specifies the center of the reflection
        plane.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetCopyInput"
                         default_values="1"
                         name="CopyInput"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the output will contain
        the union of the input dataset and its reflection. Otherwise the output
        will contain only the reflection of the input data.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetFlipAllInputArrays"
                         default_values="1"
                         name="FlipAllInputArrays"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation> If off, only Vectors, Normals and Tensors will be flipped.
        If on, all 3-component data arrays ( considered as 3D vectors),
        6-component data arrays (considered as symmetric tensors),
        9-component data arrays (considered as tensors ) of signed type will be flipped.
        All other arrays won't be flipped and will only be copied.</Documentation>
      </IntVectorProperty>
      <!-- End ReflectionFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRibbonFilter"
                 label="Ribbon"
                 name="RibbonFilter">
      <Documentation long_help="This filter generates ribbon surface from lines.  It is useful for displaying streamlines."
                     short_help="Create ribbon surfaces from lines.">The Ribbon
                     filter creates ribbons from the lines in the input data
                     set. This filter is useful for visualizing streamlines.
                     Both the input and output of this filter are polygonal
                     data. The input data set must also have at least one
                     point-centered vector array.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array1"
                          number_of_components="3"
                          optional="1" />
        <InputArrayDomain attribute_type="point"
                          name="input_array2"
                          number_of_components="1"
                          optional="1" />
        <Documentation>This property specifies the input to the Ribbon
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array2"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>The value of this property indicates the name of the
        input scalar array used by this filter. The width of the ribbons will
        be varied based on the values in the specified array if the value of
        the Width property is 1.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="1"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <!-- default_values=1, send vectors to the right place -->
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="input_array1"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>The value of this property indicates the name of the
        input vector array used by this filter. If the UseDefaultNormal
        property is set to 0, the normal vectors for the ribbons come from the
        specified vector array.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetWidth"
                            default_values="1"
                            name="Width"
                            number_of_elements="1">
        <BoundsDomain mode="scaled_extent"
                      name="bounds"
                      scale_factor="0.01">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>If the VaryWidth property is set to 1, the value of this
        property is the minimum ribbon width. If the VaryWidth property is set
        to 0, the value of this property is half the width of the
        ribbon.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetAngle"
                            default_values="0"
                            name="Angle"
                            number_of_elements="1">
        <DoubleRangeDomain max="360"
                           min="0"
                           name="range" />
        <Documentation>The value of this property specifies the offset angle
        (in degrees) of the ribbon from the line normal.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetUseDefaultNormal"
                         default_values="0"
                         name="UseDefaultNormal"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 0, and the input contains no
        vector array, then default ribbon normals will be generated
        (DefaultNormal property); if a vector array has been set
        (SelectInputVectors property), the ribbon normals will be set from the
        specified array. If this property is set to 1, the default normal
        (DefaultNormal property) will be used, regardless of whether the
        SelectInputVectors property has been set.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetDefaultNormal"
                            default_values="0 0 1"
                            name="DefaultNormal"
                            number_of_elements="3">
        <DoubleRangeDomain name="range" />
        <Documentation>The value of this property specifies the normal to use
        when the UseDefaultNormal property is set to 1 or the input contains no
        vector array (SelectInputVectors property).</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetVaryWidth"
                         default_values="0"
                         name="VaryWidth"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the ribbon width will be
        scaled according to the scalar array specified in the
        SelectInputScalars property. Toggle the variation of ribbon width with
        scalar value.</Documentation>
      </IntVectorProperty>
      <!-- End RibbonFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRotationalExtrusionFilter"
                 label="Rotational Extrusion"
                 name="RotationalExtrusionFilter">
      <Documentation long_help="This filter generates a swept surface while translating the input along a circular path."
                     short_help="Generates a swept surface using a rotational path.">
                     The Rotational Extrusion filter forms a surface by
                     rotating the input about the Z axis. This filter is
                     intended to operate on 2D polygonal data. It produces
                     polygonal output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Rotational
        Extrusion filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetResolution"
                         default_values="12"
                         name="Resolution"
                         number_of_elements="1">
        <IntRangeDomain min="1"
                        name="range" />
        <Documentation>The value of this property controls the number of
        intermediate node points used in performing the sweep (rotating from 0
        degrees to the value specified by the Angle property.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCapping"
                         default_values="1"
                         name="Capping"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the open ends of the swept
        surface will be capped with a copy of the input dataset. This works
        property if the input is a 2D surface composed of filled polygons. If
        the input dataset is a closed solid (e.g., a sphere), then either two
        copies of the dataset will be drawn or no surface will be drawn. No
        surface is drawn if either this property is set to 0 or if the two
        surfaces would occupy exactly the same 3D space (i.e., the Angle
        property's value is a multiple of 360, and the values of the
        Translation and DeltaRadius properties are 0).</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetAngle"
                            default_values="360"
                            name="Angle"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the angle of rotation in
        degrees. The surface is swept from 0 to the value of this
        property.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTranslation"
                            default_values="0"
                            name="Translation"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>The value of this property specifies the total amount of
        translation along the Z axis during the sweep process. Specifying a
        non-zero value for this property allows you to create a corkscrew
        (value of DeltaRadius &gt; 0) or spring effect.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetDeltaRadius"
                            default_values="0"
                            name="DeltaRadius"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>The value of this property specifies the change in
        radius during the sweep process.</Documentation>
      </DoubleVectorProperty>
      <!-- End RotationalExtrusionFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkShrinkFilter"
                 label="Shrink"
                 name="ShrinkFilter">
      <Documentation long_help="This filter shrinks each input cell so they pull away from their neighbors."
                     short_help="Shrink each input cell.">The Shrink filter
                     causes the individual cells of a dataset to break apart
                     from each other by moving each cell's points toward the
                     centroid of the cell. (The centroid of a cell is the
                     average position of its points.) This filter operates on
                     any type of dataset and produces unstructured grid
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Shrink
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetShrinkFactor"
                            default_values="0.5"
                            name="ShrinkFactor"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>The value of this property determines how far the points
        will move. A value of 0 positions the points at the centroid of the
        cell; a value of 1 leaves them at their original
        positions.</Documentation>
      </DoubleVectorProperty>
      <!-- End ShrinkFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkSmoothPolyDataFilter"
                 label="Smooth"
                 name="SmoothPolyDataFilter">
      <Documentation long_help="This filter smooths a polygonal surface by iteratively moving points toward their neighbors."
                     short_help="Smooth a polygonal surface without adding more points.">
                     The Smooth filter operates on a polygonal data set by
                     iteratively adjusting the position of the points using
                     Laplacian smoothing. (Because this filter only adjusts
                     point positions, the output data set is also polygonal.)
                     This results in better-shaped cells and more evenly
                     distributed points. The Convergence slider limits the
                     maximum motion of any point. It is expressed as a fraction
                     of the length of the diagonal of the bounding box of the
                     data set. If the maximum point motion during a smoothing
                     iteration is less than the Convergence value, the
                     smoothing operation terminates.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Smooth
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="1"
                         command="SetNumberOfIterations"
                         default_values="20"
                         label="Number of Iterations"
                         name="NumberOfIterations"
                         number_of_elements="1">
        <IntRangeDomain min="0"
                        name="range" />
        <Documentation>This property sets the maximum number of smoothing
        iterations to perform. More iterations produce better
        smoothing.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetConvergence"
                            default_values="0.0"
                            name="Convergence"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
        <Documentation>The value of this property limits the maximum motion of
        any point. It is expressed as a fraction of the length of the diagonal
        of the bounding box of the input dataset. If the maximum point motion
        during a smoothing iteration is less than the value of this property,
        the smoothing operation terminates.</Documentation>
      </DoubleVectorProperty>
      <!-- End SmoothPolyDataFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkStripper"
                 label="Triangle Strips"
                 name="Stripper">
      <Documentation long_help="This filter uses a greedy algorithm to convert triangles into triangle strips"
                     short_help="Convert triangles into triangle strips.">The
                     Triangle Strips filter converts triangles into triangle
                     strips and lines into polylines. This filter operates on
                     polygonal data sets and produces polygonal
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Triangle Strips
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetMaximumLength"
                         default_values="1000"
                         name="MaximumLength"
                         number_of_elements="1">
        <IntRangeDomain max="100000"
                        min="4"
                        name="range" />
        <Documentation>This property specifies the maximum number of
        triangles/lines to include in a triangle strip or
        polyline.</Documentation>
      </IntVectorProperty>
      <!-- End Stripper -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPlotEdges"
                 label="Plot On Sorted Lines"
                 name="PlotOnSortedLines">
      <Documentation long_help="The Plot on Sorted Lines filter sorts and orders polylines for graph visualization."
      short_help="">The Plot on Sorted Lines filter sorts and orders
      polylines for graph visualization. See http://www.paraview.org/ParaView3/index.php/Plotting_Over_Curves for more information.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Plot Edges
        filter.</Documentation>
      </InputProperty>
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <!-- Temporary hint to allow the output of this filter to be plotted -->
        <Plotable />
      </Hints>
      <!-- End PlotEdges -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <CompoundSourceProxy label="Plot On Intersection Curves"
                         name="PlotOnIntersectionCurves">
      <Documentation long_help="Extracts the edges in a 2D plane and plots them"
                     short_help="Extracts the edges in a 2D plane and plots them">
                     Extracts the surface, intersect it with a 2D plane. Plot
                     the resulting polylines.</Documentation>
      <Proxy compound_name="ExtractSurface1"
             group="filters"
             id="374"
             servers="1"
             type="DataSetSurfaceFilter">
        <Property id="374.Input"
                  name="Input"
                  number_of_elements="1">
          <Domain id="374.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="374.Input.input_type"
                  name="input_type">
            <DataType value="vtkDataSet" />
          </Domain>
        </Property>
        <Property id="374.PieceInvariant"
                  name="PieceInvariant"
                  number_of_elements="1">
          <Element index="0"
                   value="1" />
          <Domain id="374.PieceInvariant.bool"
                  name="bool" />
        </Property>
      </Proxy>
      <Proxy compound_name="PlotEdges1"
             group="filters"
             id="971"
             servers="1"
             type="PlotOnSortedLines">
        <Property id="971.Input"
                  name="Input"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="667" />
          <Domain id="971.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="971.Input.input_type"
                  name="input_type">
            <DataType value="vtkPolyData" />
          </Domain>
        </Property>
      </Proxy>
      <Proxy compound_name="Slice1"
             group="filters"
             id="667"
             servers="1"
             type="Cut">
        <Property id="667.ContourValues"
                  name="ContourValues"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="667.ContourValues.bounds"
                  name="bounds">
            <Min index="0"
                 value="-0.718069" />
            <Max index="0"
                 value="0.718069" />
          </Domain>
        </Property>
        <Property id="667.CutFunction"
                  name="CutFunction"
                  number_of_elements="1">
          <Proxy value="670" />
          <Domain id="667.CutFunction.groups"
                  name="groups">
            <Group value="implicit_functions" />
          </Domain>
          <Domain id="667.CutFunction.proxy_list"
                  name="proxy_list">
            <Proxy value="670" />
            <Proxy value="671" />
            <Proxy value="672" />
          </Domain>
        </Property>
        <Property id="667.Input"
                  name="Input"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="374" />
          <Domain id="667.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="667.Input.input_type"
                  name="input_type">
            <DataType value="vtkDataSet" />
          </Domain>
        </Property>
        <Property id="667.InputBounds"
                  name="InputBounds">
          <Domain id="667.InputBounds.bounds"
                  name="bounds">
            <Min index="0"
                 value="-0.5" />
            <Min index="1"
                 value="-0.124991" />
            <Min index="2"
                 value="-0.5" />
            <Max index="0"
                 value="0.5" />
            <Max index="1"
                 value="0.124991" />
            <Max index="2"
                 value="0.5" />
          </Domain>
        </Property>
      </Proxy>
      <Proxy compound_name="auto_670"
             group="implicit_functions"
             id="670"
             servers="1"
             type="Plane">
        <Property id="670.Normal"
                  name="Normal"
                  number_of_elements="3">
          <Element index="0"
                   value="1" />
          <Element index="1"
                   value="0" />
          <Element index="2"
                   value="0" />
          <Domain id="670.Normal.range"
                  name="range" />
        </Property>
        <Property id="670.Offset"
                  name="Offset"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="670.Offset.range"
                  name="range">
            <Min index="0"
                 value="0" />
            <Max index="0"
                 value="0" />
          </Domain>
        </Property>
        <Property id="670.Origin"
                  name="Origin"
                  number_of_elements="3">
          <Element index="0"
                   value="0" />
          <Element index="1"
                   value="0" />
          <Element index="2"
                   value="0" />
          <Domain id="670.Origin.range"
                  name="range">
            <Min index="0"
                 value="-0.5" />
            <Min index="1"
                 value="-0.124991" />
            <Min index="2"
                 value="-0.5" />
            <Max index="0"
                 value="0.5" />
            <Max index="1"
                 value="0.124991" />
            <Max index="2"
                 value="0.5" />
          </Domain>
        </Property>
      </Proxy>
      <ExposedProperties>
        <Property exposed_name="Input"
                  name="Input"
                  proxy_name="ExtractSurface1" />
        <Property exposed_name="Slice Type"
                  name="CutFunction"
                  proxy_name="Slice1" />
      </ExposedProperties>
      <OutputPort name="Output"
                  port_index="0"
                  proxy="PlotEdges1" />
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <Plotable />
      </Hints>
    </CompoundSourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkLinearSubdivisionFilter"
                 name="Subdivide">
      <Documentation long_help="This filter iteratively divide triangles into four smaller triangles.  New points are placed linearly so the output surface matches the input surface."
                     short_help="Creates a surface with more triangles than the input.">
                     The Subdivide filter iteratively divides each triangle in
                     the input dataset into 4 new triangles. Three new points
                     are added per triangle -- one at the midpoint of each
                     edge. This filter operates only on polygonal data
                     containing triangles, so run your polygonal data through
                     the Triangulate filter first if it is not composed of
                     triangles. The output of this filter is also
                     polygonal.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This parameter specifies the input to the Subdivide
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetNumberOfSubdivisions"
                         default_values="1"
                         label="Number of Subdivisions"
                         name="NumberOfSubdivisions"
                         number_of_elements="1">
        <IntRangeDomain max="4"
                        min="1"
                        name="range" />
        <Documentation>The value of this property specifies the number of
        subdivision iterations to perform.</Documentation>
      </IntVectorProperty>
      <!-- End Subdivide -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy name="TensorGlyph" class="vtkTensorGlyph" label="Tensor Glyph">

      <Documentation
        long_help="This filter generates an ellipsoid, cuboid, cylinder or superquadric glyph at
                   each point of the input data set. The glyphs are oriented and scaled according
                   to eigenvalues and eigenvectors of tensor point data of the input data set.
                   This filter supports symmetric tensors. Symmetric tensor are expected to have
                   the following order: XX, YY, ZZ, XY, YZ, XZ"
        short_help="This filter generates an ellipsoid, cuboid, cylinder or superquadric glyph at each
                   point of the input data set. The glyphs are oriented and scaled according to eigenvalues
                   and eigenvectors of tensor point data of the input data set.
                   This filter supports symmetric tensors. Symmetric tensor components are expected to have
                   the following order: XX, YY, ZZ, XY, YZ, XZ">

        The Tensor Glyph filter generates an ellipsoid, cuboid, cylinder or superquadric glyph at every point in
        the input data set. The glyphs are oriented and scaled according to eigenvalues and eigenvectors of tensor
        point data of the input data set. The Tensor Glyph filter operates on any type of data set. Its output is
        polygonal. This filter supports symmetric tensors. Symmetric tensor components are expected to have the
        following order: XX, YY, ZZ, XY, YZ, XZ"
      </Documentation>

    <InputProperty
        name="Input"
        command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
      <DataTypeDomain name="input_type">
        <DataType value="vtkDataSet" />
      </DataTypeDomain>
      <InputArrayDomain name="input_array1" attribute_type="point"
            number_of_components="6,9" />
      <InputArrayDomain name="input_array2" attribute_type="point"
            number_of_components="1" optional="1" />
      <Documentation>
        This property specifies the input to the Glyph filter.
      </Documentation>
    </InputProperty>

    <StringVectorProperty
        name="SelectInputTensors"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        label="Tensors"
        >
      <ArrayListDomain name="array_list" attribute_type="Tensors"
          input_domain_name="input_array1">
        <RequiredProperties>
          <Property name="Input" function="Input" />
        </RequiredProperties>
      </ArrayListDomain>
      <Documentation>
              This property indicates the name of the tensor array on which to operate. The indicated array's
              eigenvalues and eigenvectors are used for scaling and orienting the glyphs.
      </Documentation>
    </StringVectorProperty>

    <InputProperty
        name="Source"
        command="SetSourceConnection"
        label="Glyph Type">
      <ProxyGroupDomain name="groups">
        <Group name="sources" />
        <Group name="glyph_sources" />
      </ProxyGroupDomain>
      <DataTypeDomain name="input_type">
        <DataType value="vtkPolyData" />
      </DataTypeDomain>
      <ProxyListDomain name="proxy_list">
        <Proxy group="sources" name="SphereSource" />
        <Proxy group="sources" name="CylinderSource" />
        <Proxy group="sources" name="CubeSource" />
        <Proxy group="sources" name="SuperquadricSource" />
      </ProxyListDomain>
      <Documentation>
        This property determines which type of glyph will be placed at the points in the input dataset.
      </Documentation>
    </InputProperty>

    <IntVectorProperty
        name="ExtractEigenvalues"
        command="SetExtractEigenvalues"
        number_of_elements="1"
        default_values="1"
        >
      <BooleanDomain name="bool" />
      <Documentation>
        Toggle whether to extract eigenvalues from tensor. If false, eigenvalues/eigenvectors are not extracted and
        the columns of the tensor are taken as the eigenvectors (the norm of column, always positive, is the eigenvalue).
        If true, the glyph is scaled and oriented according to eigenvalues and eigenvectors; additionally, eigenvalues
        are provided as new data array.
      </Documentation>
    </IntVectorProperty>

    <IntVectorProperty
        name="ColorGlyphs"
        command="SetColorGlyphs"
        number_of_elements="1"
        default_values="1"
        >
      <BooleanDomain name="bool" />
      <Documentation>
        This property determines whether or not to color the glyphs.
      </Documentation>
    </IntVectorProperty>

    <StringVectorProperty
        name="SelectInputScalars"
        command="SetInputArrayToProcess"
        number_of_elements="5"
        element_types="0 0 0 0 2"
        default_values="1"
        label="Scalars"
        >
           <!-- default_values=1 is important to set here and not in Tensors
                previously. Omitting the setting here would mess up changed
                tensor input being recognized as tensor input and not as
                scalar input and vice versa. -->
      <ArrayListDomain name="array_list" attribute_type="Scalars"
          input_domain_name="input_array2">
        <RequiredProperties>
          <Property name="Input" function="Input" />
        </RequiredProperties>
      </ArrayListDomain>
      <Documentation>
        This property indicates the name of the scalar array to use for coloring
      </Documentation>
    </StringVectorProperty>

    <IntVectorProperty
        name="ColorMode"
        command="SetColorMode"
        number_of_elements="1"
        default_values="0"
        label="Color by"
        >
            <EnumerationDomain name="enum">
              <Entry value="0" text="input scalars" />
              <Entry value="1" text="eigenvalues" />
            </EnumerationDomain>
      <Documentation>
        This property determines whether input scalars or computed eigenvalues at the point should be used
        to color the glyphs. If ThreeGlyphs is set and the eigenvalues are chosen for coloring then each glyph
        is colored by the corresponding eigenvalue and if not set the color corresponding to the largest
        eigenvalue is chosen.
      </Documentation>
   </IntVectorProperty>

    <!-- Disabled as vtkTensorGlyph.cxx does not respect this parameter currently. -->
    <!--
    <IntVectorProperty
        name="Scaling"
        command="SetScaling"
        number_of_elements="1"
        default_values="1"
        >
      <BooleanDomain name="bool" />
      <Documentation>
        This property determines whether or not to scale glyphs with eigenvalues.
      </Documentation>
    </IntVectorProperty>
    -->

    <DoubleVectorProperty
        name="ScaleFactor"
        command="SetScaleFactor"
        number_of_elements="1"
        default_values="1"
        >
      <BoundsDomain name="range" mode="array_scaled_extent">
        <RequiredProperties>
          <Property function="Input" name="Input" />
          <Property function="ArraySelection" name="SelectInputTensors" />
        </RequiredProperties>
      </BoundsDomain>
      <Documentation>
        This property specifies the scale factor to scale every glyph by.
      </Documentation>
    </DoubleVectorProperty>

    <IntVectorProperty
        name="LimitScalingByEigenvalues"
        command="SetClampScaling"
        number_of_elements="1"
        default_values="0"
        >
      <BooleanDomain name="bool" />
      <Documentation>
        This property determines whether scaling of glyphs by ScaleFactor times eigenvalue should be limited.
        This is useful to prevent uncontrolled scaling near singularities.
      </Documentation>
    </IntVectorProperty>

    <DoubleVectorProperty
        name="MaxScaleFactor"
        command="SetMaxScaleFactor"
        number_of_elements="1"
        default_values="10"
        >
      <Documentation>
        If scaling by eigenvalues should be limited, this value sets an upper limit for scale factor times
        eigenvalue.
      </Documentation>
    </DoubleVectorProperty>

    <IntVectorProperty
        name="Symmetric"
        command="SetSymmetric"
        number_of_elements="1"
        default_values="0"
        >
      <BooleanDomain name="bool" />
      <Documentation>
        This property determines whether or not to draw a mirror of each glyph.
      </Documentation>
    </IntVectorProperty>

     <IntVectorProperty
        name="ThreeGlyphs"
        command="SetThreeGlyphs"
        number_of_elements="1"
        default_values="0"
        >
      <BooleanDomain name="bool" />
      <Documentation>
        Toggle whether to produce three glyphs, each of which oriented along an eigenvector and scaled according
        to the corresponding eigenvector.
      </Documentation>
          </IntVectorProperty>
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkTessellatorFilter"
                 label="Tessellate"
                 name="TessellatorFilter">
      <Documentation long_help="Tessellate nonlinear curves, surfaces, and volumes with lines, triangles, and tetrahedra."
                     short_help="Polygonalize a mesh.">The Tessellate filter
                     tessellates cells with nonlinear geometry and/or scalar
                     fields into a simplicial complex with linearly
                     interpolated field values that more closely approximate
                     the original field. This is useful for datasets containing
                     quadratic cells.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
          <DataType value="vtkDataSet" />
          <DataType value="vtkUnstructuredGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Tessellate
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetOutputDimension"
                         default_values="3"
                         name="OutputDimension"
                         number_of_elements="1">
        <IntRangeDomain max="3"
                        min="1"
                        name="range" />
        <Documentation>The value of this property sets the maximum
        dimensionality of the output tessellation. When the value of this
        property is 3, 3D cells produce tetrahedra, 2D cells produce triangles,
        and 1D cells produce line segments. When the value is 2, 3D cells will
        have their boundaries tessellated with triangles. When the value is 1,
        all cells except points produce line segments.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetChordError"
                            default_values="1e-3"
                            name="ChordError"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>This property controls the maximum chord error allowed
        at any edge midpoint in the output tessellation. The chord error is
        measured as the distance between the midpoint of any output edge and
        the original nonlinear geometry.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetFieldCriterion"
                            label="Field Error"
                            name="FieldError2"
                            number_of_elements_per_command="1"
                            repeat_command="1"
                            use_index="1">
        <Documentation>This property controls the maximum field error allowed
        at any edge midpoint in the output tessellation. The field error is
        measured as the difference between a field value at the midpoint of an
        output edge and the value of the corresponding field in the original
        nonlinear geometry.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSubdivisions"
                         default_values="3"
                         label="Maximum Number of Subdivisions"
                         name="MaximumNumberOfSubdivisions"
                         number_of_elements="1">
        <IntRangeDomain max="8"
                        min="0"
                        name="range" />
        <Documentation>This property specifies the maximum number of times an
        edge may be subdivided. Increasing this number allows further
        refinement but can drastically increase the computational and storage
        requirements, especially when the value of the OutputDimension property
        is 3.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMergePoints"
                         default_values="1"
                         name="MergePoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is set to 1, coincident
        vertices will be merged after tessellation has occurred. Only geometry
        is considered during the merge and the first vertex encountered is the
        one whose point attributes will be used. Any discontinuities in point
        fields will be lost. On the other hand, many operations, such as
        streamline generation, require coincident vertices to be merged. Toggle
        whether to merge coincident vertices.</Documentation>
      </IntVectorProperty>
      <Property command="ResetFieldCriteria"
                immediate_update="1"
                name="ResetFieldCriteria"></Property>
      <!-- End TessellatorFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDataSetTriangleFilter"
                 label="Tetrahedralize"
                 name="DataSetTriangleFilter">
      <Documentation long_help="This filter converts 3-d cells to tetrahedrons and polygons to triangles.  The output is always of type unstructured grid."
                     short_help="Convert to tetrahedrons and triangles.">The
                     Tetrahedralize filter converts the 3D cells of any type of
                     dataset to tetrahedrons and the 2D ones to triangles. This
                     filter always produces unstructured grid
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Tetrahedralize
        filter.</Documentation>
      </InputProperty>
      <!-- End DataSetTriangleFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTransformFilter"
                 label="Transform"
                 name="TransformFilter">
      <Documentation long_help="This filter applies transformation to the polygons."
                     short_help="Transform polygonal data.">The Transform
                     filter allows you to specify the position, size, and
                     orientation of polygonal, unstructured grid, and
                     curvilinear data sets.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
          <DataType value="vtkImageData" />
          <DataType value="vtkRectilinearGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Transform
        filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetTransform"
                     name="Transform"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="transforms" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources"
                 name="Transform3" />
        </ProxyListDomain>
        <Documentation>The values in this property allow you to specify the
        transform (translation, rotation, and scaling) to apply to the input
        dataset.</Documentation>
      </ProxyProperty>
      <IntVectorProperty command="SetTransformAllInputVectors"
                         default_values="1"
                         name="TransformAllInputVectors"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation> If off, only Vectors and Normals will be transformed.
        If on, all 3-component data arrays (considered as 3D vectors) will be transformed.
        All other arrays won't be flipped and will only be copied.</Documentation>
      </IntVectorProperty>
      <!-- End TransformFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTriangleFilter"
                 label="Triangulate"
                 name="TriangleFilter">
      <Documentation long_help="This filter converts polygons and triangle strips to basic triangles."
                     short_help="Convert polygonal data to triangles.">The
                     Triangulate filter decomposes polygonal data into only
                     triangles, points, and lines. It separates triangle strips
                     and polylines into individual triangles and lines,
                     respectively. The output is polygonal data. Some filters
                     that take polygonal data as input require that the data be
                     composed of triangles rather than other polygons, so
                     passing your data through this filter first is useful in
                     such situations. You should use this filter in these cases
                     rather than the Tetrahedralize filter because they produce
                     different output dataset types. The filters referenced
                     require polygonal input, and the Tetrahedralize filter
                     produces unstructured grid output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Triangulate
        filter.</Documentation>
      </InputProperty>
      <!-- End TriangleFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTubeFilter"
                 label="Tube"
                 name="TubeFilter">
      <Documentation long_help="Convert lines into tubes. Normals are used to avoid cracks between tube segments."
                     short_help="Convert lines into tubes.">The Tube filter
                     creates tubes around the lines in the input polygonal
                     dataset. The output is also polygonal.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array1"
                          number_of_components="1"
                          optional="1" />
        <InputArrayDomain attribute_type="point"
                          name="input_array2"
                          number_of_components="3"
                          optional="1" />
        <Documentation>This property specifies the input to the Tube
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array1"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property indicates the name of the scalar array on
        which to operate. The indicated array may be used for scaling the
        tubes. (See the VaryRadius property.)</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="1"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <!-- default value=1 so normals go to the right place -->
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="input_array2"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property indicates the name of the vector array on
        which to operate. The indicated array may be used for scaling and/or
        orienting the tubes. (See the VaryRadius property.)</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetNumberOfSides"
                         default_values="6"
                         label="Number of Sides"
                         name="NumberOfSides"
                         number_of_elements="1">
        <IntRangeDomain min="3"
                        name="range" />
        <Documentation>The value of this property indicates the number of faces
        around the circumference of the tube.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCapping"
                         default_values="1"
                         name="Capping"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, endcaps will be drawn on
        the tube. Otherwise the ends of the tube will be open.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetRadius"
                            default_values="1.0"
                            name="Radius"
                            number_of_elements="1">
        <BoundsDomain mode="scaled_extent"
                      name="bounds"
                      scale_factor="0.01">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>The value of this property sets the radius of the tube.
        If the radius is varying (VaryRadius property), then this value is the
        minimum radius.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetVaryRadius"
                         default_values="0"
                         name="VaryRadius"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Off"
                 value="0" />
          <Entry text="By Scalar"
                 value="1" />
          <Entry text="By Vector"
                 value="2" />
          <Entry text="By Absolute Scalar"
                 value="3" />
        </EnumerationDomain>
        <Documentation>The property determines whether/how to vary the radius
        of the tube. If varying by scalar (1), the tube radius is based on the
        point-based scalar values in the dataset. If it is varied by vector,
        the vector magnitude is used in varying the radius.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetRadiusFactor"
                            default_values="10"
                            name="RadiusFactor"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>If varying the radius (VaryRadius property), the
        property sets the maximum tube radius in terms of a multiple of the
        minimum radius. If not varying the radius, this value has no
        effect.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetUseDefaultNormal"
                         default_values="0"
                         name="UseDefaultNormal"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 0, and the input contains no
        vector array, then default ribbon normals will be generated
        (DefaultNormal property); if a vector array has been set
        (SelectInputVectors property), the ribbon normals will be set from the
        specified array. If this property is set to 1, the default normal
        (DefaultNormal property) will be used, regardless of whether the
        SelectInputVectors property has been set.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetDefaultNormal"
                            default_values="0 0 1"
                            name="DefaultNormal"
                            number_of_elements="3">
        <DoubleRangeDomain name="range" />
        <Documentation>The value of this property specifies the normal to use
        when the UseDefaultNormal property is set to 1 or the input contains no
        vector array (SelectInputVectors property).</Documentation>
      </DoubleVectorProperty>
      <!-- End TubeFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkWarpScalar"
                 label="Warp By Scalar"
                 name="WarpScalar">
      <Documentation long_help="This filter moves point coordinates along a vector scaled by a point attribute.  It can be used to produce carpet plots."
                     short_help="Warp point scalars into a spatial elevation plot.">
                     The Warp (scalar) filter translates the points of the
                     input data set along a vector by a distance determined by
                     the specified scalars. This filter operates on polygonal,
                     curvilinear, and unstructured grid data sets containing
                     single-component scalar arrays. Because it only changes
                     the positions of the points, the output data set type is
                     the same as that of the input. Any scalars in the input
                     dataset are copied to the output, so the data can be
                     colored by them.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
          <DataType value="vtkImageData" />
          <DataType value="vtkRectilinearGrid" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input to the Warp (scalar)
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5"
                            panel_visibility="default">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property contains the name of the scalar array by
        which to warp the dataset.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetScaleFactor"
                            default_values="1.0"
                            name="ScaleFactor"
                            number_of_elements="1"
                            panel_visibility="default">
        <BoundsDomain name="range" mode="array_scaled_extent">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="SelectInputScalars" />
          </RequiredProperties>
        </BoundsDomain>
        <Hints>
          <NoDefault/>
        </Hints>
        <Documentation>The scalar value at a given point is multiplied by the
        value of this property to determine the magnitude of the change vector
        for that point.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetNormal"
                            default_values="0 0 1"
                            name="Normal"
                            number_of_elements="3">
        <DoubleRangeDomain name="range" />
        <Documentation>The values of this property specify the direction along
        which to warp the dataset if any normals contained in the input dataset
        are not being used for this purpose. (See the UseNormal
        property.)</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetUseNormal"
                         default_values="0"
                         name="UseNormal"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If point normals are present in the dataset, the value
        of this property toggles whether to use a single normal value (value =
        1) or the normals from the dataset (value = 0).</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetXYPlane"
                         default_values="0"
                         label="XY Plane"
                         name="XYPlane"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is 1, then the
        Z-coordinates from the input are considered to be the scalar values,
        and the displacement is along the Z axis. This is useful for creating
        carpet plots.</Documentation>
      </IntVectorProperty>
      <!-- End WarpScalar -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkWarpVector"
                 label="Warp By Vector"
                 name="WarpVector">
      <Documentation long_help="This filter displaces point coordinates along a vector attribute. It is useful for showing mechanical deformation."
                     short_help="Warp (displace) the geometry with a given vector field.">
                     The Warp (vector) filter translates the points of the
                     input dataset using a specified vector array. The vector
                     array chosen specifies a vector per point in the input.
                     Each point is translated along its vector by a given scale
                     factor. This filter operates on polygonal, curvilinear,
                     and unstructured grid datasets. Because this filter only
                     changes the positions of the points, the output dataset
                     type is the same as that of the input.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
          <DataType value="vtkImageData" />
          <DataType value="vtkRectilinearGrid" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>This property specifies the input to the Warp (vector)
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5"
                            panel_visibility="default">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>The value of this property contains the name of the
        vector array by which to warp the dataset's point
        coordinates.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetScaleFactor"
                            default_values="1.0"
                            name="ScaleFactor"
                            number_of_elements="1"
                            panel_visibility="default">
        <BoundsDomain name="range" mode="array_scaled_extent">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="SelectInputVectors" />
          </RequiredProperties>
        </BoundsDomain>
        <Hints>
          <NoDefault/>
        </Hints>
        <Documentation>Each component of the selected vector array will be
        multiplied by the value of this property before being used to compute
        new point coordinates.</Documentation>
      </DoubleVectorProperty>
      <!-- End WarpVector -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVMetaSliceDataSet"
                 label="Slice"
                 name="Cut">
      <Documentation long_help="This filter slices a data set with a plane. Slicing is similar to a contour. It creates surfaces from volumes and lines from surfaces."
                     short_help="Slice datasets with planes.">This filter
                     extracts the portion of the input dataset that lies along
                     the specified plane. The Slice filter takes any type of
                     dataset or hyper tree grid as input. The output of this filter is polygonal
                     data.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Slice
        filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetDataSetCutFunction"
                     label="Slice Type"
                     name="CutFunction">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="visibility"/>
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
          <Proxy group="implicit_functions"
                 name="Cylinder" />
        </ProxyListDomain>
        <Documentation>This property sets the parameters of the slice
        function.</Documentation>
      </ProxyProperty>
      <ProxyProperty command="SetHyperTreeGridCutFunction"
                     label="Hyper Tree Grid Slicer"
                     name="HyperTreeGridImplicitFunction">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   mode="visibility"/>
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Axis Aligned Plane" />
        </ProxyListDomain>
        <Documentation>This property sets the parameters of the slice
        function.</Documentation>
      </ProxyProperty>
      <DoubleVectorProperty information_only="1"
                            name="InputBounds">
        <BoundsDomain name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetDual"
                         default_values="0"
                         label="Use Dual"
                         name="SetDual"
                         number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="and">
              <PropertyWidgetDecorator type="GenericDecorator"
                                       mode="visibility"
                                       property="HyperTreeGridImplicitFunction"
                                       value="Plane"/>
              <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                       mode="visibility"
                                       name="vtkHyperTreeGrid"/>
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
        <BooleanDomain name="bool" />
        <Documentation>If checked, uses the dual of the hyper tree grid.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="PreserveInputCells"
                         default_values="0"
                         label="Crinkle slice"
                         name="PreserveInputCells"
                         number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="visibility" />
        </Hints>
        <BooleanDomain name="bool" />
        <Documentation>This parameter controls whether to extract the entire
        cells that are sliced by the region or just extract a triangulated
        surface of that region.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetGenerateTriangles"
                         default_values="1"
                         name="Triangulate the slice"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This parameter controls whether to produce triangles in the output.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="and">
              <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                       name="vtkHyperTreeGrid"
                                       mode="visibility"
                                       exclude="1" />
              <PropertyWidgetDecorator type="ShowWidgetDecorator">
                <Property name="PreserveInputCells" function="boolean_invert" />
              </PropertyWidgetDecorator>
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetMergePoints"
                         default_values="1"
                         name="MergePoints"
                         label="Merge duplicated points in the slice"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This parameter controls whether to merge duplicated points in the slice.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="and">
              <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                       name="vtkHyperTreeGrid"
                                       exclude="1"
                                       mode="visibility"/>
              <PropertyWidgetDecorator type="ShowWidgetDecorator">
                <Property name="PreserveInputCells" function="boolean_invert" />
              </PropertyWidgetDecorator>
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetValue"
                            label="Slice Offset Values"
                            name="ContourValues"
                            number_of_elements_per_command="1"
                            repeat_command="1"
                            set_number_command="SetNumberOfContours"
                            use_index="1"
                            panel_visibility="advanced">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator" name="vtkHyperTreeGrid" exclude="1" />
        </Hints>
        <BoundsDomain mode="magnitude"
                      name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>The values in this property specify a list of current
        offset values. This can be used to create multiple slices with
        different centers. Each entry represents a new slice with its center
        shifted by the offset value.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="PreserveInputCells" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End Cut -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCompositeCutter"
                 label="Slice (demand-driven-composite)"
                 name="CutEverything">
      <Documentation long_help="This filter slices a data set with a plane. Slicing is similar to a contour. It creates surfaces from volumes and lines from surfaces."
                     short_help="Slice datasets with planes.">This filter
                     extracts the portion of the input dataset that lies along
                     the specified plane. The Slice filter takes any type of
                     dataset as input. The output of this filter is polygonal
                     data.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Slice
        filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetCutFunction"
                     label="Slice Type"
                     name="CutFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
        </ProxyListDomain>
        <Documentation>This property sets the parameters of the slice
        function.</Documentation>
      </ProxyProperty>
      <DoubleVectorProperty information_only="1"
                            name="InputBounds">
        <BoundsDomain name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetValue"
                            label="Slice Offset Values"
                            name="ContourValues"
                            number_of_elements_per_command="1"
                            repeat_command="1"
                            set_number_command="SetNumberOfContours"
                            use_index="1"
                            panel_visibility="advanced">
        <BoundsDomain mode="magnitude"
                      name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>The values in this property specify a list of current
        offset values. This can be used to create multiple slices with
        different centers. Each entry represents a new slice with its center
        shifted by the offset value.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End Cut -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkPlaneCutter"
                 name="SliceWithPlane"
                 label="Slice With Plane">
      <Documentation long_help="This filter slices a data set with a plane. Slicing is similar to a contour. It creates surfaces from volumes and lines from surfaces. This filter is faster than the standard Slice filter."
                     short_help="Slice datasets with a plane.">This filter
                     extracts the portion of the input dataset that lies along
                     the specified plane. The Slice filter takes any type of
                     dataset as input. The output of this filter is a multiblock of multipiece
                     polygonal data. This is a multithreaded implementation.
                     </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the slice
        filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetPlane"
                     name="Plane">
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
        </ProxyListDomain>
        <Documentation>This property sets the parameters of the plane
        function.</Documentation>
      </ProxyProperty>
      <IntVectorProperty animateable="0"
                         command="SetBuildTree"
                         default_values="1"
                         name="BuildTree"
                         panel_visibility="advanced"
                         number_of_elements="1">
       <BooleanDomain name="bool" />
       <Documentation>
        If enabled and input is not an Image Data, Sphere Tree will be computed, for a faster slice computation.
       </Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetBuildHierarchy"
                         default_values="1"
                         name="BuildHierarchy"
                         panel_visibility="advanced"
                         number_of_elements="1">
       <BooleanDomain name="bool" />
       <Documentation>
        If enabled and input is not an Image Data, Tree hierarchy will be computed, for a faster slice computation.
       </Documentation>
       <Hints>
         <PropertyWidgetDecorator type="ShowWidgetDecorator">
           <Property name="BuildTree" function="boolean" />
         </PropertyWidgetDecorator>
       </Hints>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComputeNormals"
                         default_values="0"
                         name="ComputeNormals"
                         panel_visibility="advanced"
                         number_of_elements="1">
       <BooleanDomain name="bool" />
       <Documentation>
        If enabled, compute the normal on each cell. Since all output cells are coplanar,
        the normal generated is simply the normal of the plane used to slice with.
        By default computing of normals is disabled.
       </Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetInterpolateAttributes"
                         default_values="1"
                         name="InterpolateAttributes"
                         panel_visibility="advanced"
                         number_of_elements="1">
       <BooleanDomain name="bool" />
       <Documentation>
        If enabled, interpolate attribute data. By default this is
        enabled. Point data is always interpolated. Cell data is transferred
        unless input is an image data.
       </Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetGeneratePolygons"
                         default_values="1"
                         name="GeneratePolygons"
                         panel_visibility="advanced"
                         number_of_elements="1">
       <BooleanDomain name="bool" />
       <Documentation>
        If enabled and input is a Structured Grid or a Rectilinear Grid,
        output slice will consist of polygons instead of only triangles.
       </Documentation>
      </IntVectorProperty>

      <!-- End SliceWithPlane -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractGeometry"
                 label="Extract Cells By Region"
                 name="ExtractGeometry">
      <Documentation long_help="This filter extracts cells that are inside/outside a region or at a region boundary."
                     short_help="Extract cells that are inside/outside a region or at a region boundary.">
      This filter extracts from its input dataset all cells that are either
      completely inside or outside of a specified region (implicit function).
      On output, the filter generates an unstructured grid. To use this filter
      you must specify a region (implicit function). You must also specify
      whether to extract cells lying inside or outside of the region. An
      option exists to extract cells that are neither inside or outside (i.e.,
      boundary).</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Slice
        filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetImplicitFunction"
                     label="Intersect With"
                     name="ImplicitFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
        </ProxyListDomain>
        <Documentation>This property sets the region used to extract
        cells.</Documentation>
      </ProxyProperty>
      <DoubleVectorProperty information_only="1"
                            name="InputBounds">
        <BoundsDomain name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetExtractInside"
                         default_values="1"
                         label="Extraction Side"
                         name="ExtractInside"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="outside"
                 value="0" />
          <Entry text="inside"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This parameter controls whether to extract cells that
        are inside or outside the region.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetExtractOnlyBoundaryCells"
                         default_values="0"
                         name="Extract only intersected"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This parameter controls whether to extract only cells
        that are on the boundary of the region. If this parameter is set, the
        Extraction Side parameter is ignored. If Extract Intersected is off,
        this parameter has no effect.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetExtractBoundaryCells"
                         default_values="0"
                         name="Extract intersected"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This parameter controls whether to extract cells that
        are on the boundary of the region.</Documentation>
      </IntVectorProperty>
      <!-- End ExtractGeometry -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVMetaClipDataSet"
                 name="Clip">
      <Documentation long_help="Clip with an implicit function (an implicit description). Clipping does not reduce the dimensionality of the data set. The output data type of this filter is always an unstructured grid."
                     short_help="Clip with an implicit function.">The Clip filter
                     cuts away a portion of the input data set using an
                     implicit function (an implicit description).
                     This filter operates on all types of data
                     sets, and it returns unstructured grid data on
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array"
                          number_of_components="1"
                          optional="1" />
        <Documentation>This property specifies the dataset on which the Clip
        filter will operate.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetDataSetClipFunction"
                     label="Clip Type"
                     name="ClipFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
          <Proxy group="implicit_functions"
                 name="Cylinder" />
          <Proxy group="implicit_functions"
                 name="Scalar" />
        </ProxyListDomain>
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="visibility"/>
        </Hints>
        <Documentation>This property specifies the parameters of the clip
        function (an implicit description) used to clip the dataset.</Documentation>
      </ProxyProperty>
      <ProxyProperty command="SetHyperTreeGridClipFunction"
                     label="Hyper Tree Grid Clipper"
                     name="HyperTreeGridClipFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Axis Aligned Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
          <Proxy group="implicit_functions"
                 name="Cylinder" />
          <Proxy group="implicit_functions"
                 name="Quadric" />
          <Proxy group="implicit_functions"
                 name="Scalar" />
        </ProxyListDomain>
        <Documentation>This property specifies the parameters of the clip
        function (an implicit description) used to clip the hyper tree grid.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   mode="visibility"/>
        </Hints>
      </ProxyProperty>
      <DoubleVectorProperty information_only="1"
                            name="InputBounds">
        <BoundsDomain name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>If clipping with scalars, this property specifies the
        name of the scalar array on which to perform the clip
        operation.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="or">
              <PropertyWidgetDecorator type="GenericDecorator"
                                       mode="visibility"
                                       property="ClipFunction"
                                       value="Scalar" />
              <PropertyWidgetDecorator type="GenericDecorator"
                                       mode="visibility"
                                       property="HyperTreeGridClipFunction"
                                       value="Scalar" />
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetValue"
                            default_values="0.0"
                            name="Value"
                            number_of_elements="1">
        <ArrayRangeDomain name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputScalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>If clipping with scalars, this property sets the scalar
        value about which to clip the dataset based on the scalar array chosen.
        (See SelectInputScalars.) If clipping with a clip function, this
        property specifies an offset from the clip function to use in the
        clipping operation. Neither functionality is currently available in
        ParaView's user interface.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="or">
              <PropertyWidgetDecorator type="GenericDecorator"
                                       mode="visibility"
                                       property="ClipFunction"
                                       value="Scalar" />
              <PropertyWidgetDecorator type="GenericDecorator"
                                       mode="visibility"
                                       property="HyperTreeGridClipFunction"
                                       value="Scalar" />
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetInsideOut"
                         default_values="1"
                         name="Invert"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Invert which part of the geometry is clipped.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseValueAsOffset"
                         default_values="0"
                         name="UseValueAsOffset"
                         number_of_elements="1"
                         panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>If UseValueAsOffset is true, Value is used as an offset
        parameter to the implicit function. Otherwise, Value is used only when
        clipping using a scalar array.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="PreserveInputCells"
                         default_values="0"
                         label="Crinkle clip"
                         name="PreserveInputCells"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This parameter controls whether to extract entire cells
        in the given region or clip those cells so all of the output will stay
        only on that side of region.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="and">
              <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                       mode="visibility"
                                       exclude="1"
                                       name="vtkHyperTreeGrid" />
              <PropertyWidgetDecorator type="GenericDecorator"
                                       mode="visibility"
                                       property="ClipFunction"
                                       value="Scalar"
                                       inverse="1" />
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetExactBoxClip"
                         default_values="0"
                         name="Exact"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1 it will clip to the exact specifications
        for the **Box** option only, otherwise the clip will only approximate the box geometry. The
        exact clip is very expensive as it requires generating 6 plane clips. Additionally,
        **Invert** must be checked and **Crinkle clip** must be unchecked.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="and">
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="ClipFunction" value="Box" inverse="0" />
              <PropertyWidgetDecorator type="GenericDecorator" mode="enabled_state" property="Invert" value="1" />
              <PropertyWidgetDecorator type="GenericDecorator" mode="enabled_state" property="PreserveInputCells" value="0" />
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
      </IntVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End Clip -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVClipClosedSurface"
                 label="Clip Closed Surface"
                 name="ClipClosedSurface">
      <Documentation long_help="Clip a polygonal dataset with a plane to produce closed surfaces"
                     short_help="Clip a polygonal dataset with a plane to produce closed surfaces">
      This clip filter cuts away a portion of the input polygonal dataset using
      a plane to generate a new polygonal dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1"
                          optional="1" />
        <Documentation>This property specifies the dataset on which the Clip
        filter will operate.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetClippingPlane"
                     label="Clipping Plane"
                     name="ClippingPlane">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
        </ProxyListDomain>
        <Documentation>This property specifies the parameters of the clipping
        plane used to clip the polygonal data.</Documentation>
      </ProxyProperty>
      <IntVectorProperty command="SetGenerateFaces"
                         default_values="1"
                         name="GenerateFaces"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Generate polygonal faces in the output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetGenerateOutline"
                         default_values="0"
                         name="GenerateOutline"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Generate clipping outlines in the output wherever an
        input face is cut by the clipping plane.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetScalarMode"
                         default_values="0"
                         label="Generate Cell Origins"
                         name="ScalarMode"
                         number_of_elements="1">
                         <EnumerationDomain name="enum">
                           <Entry text="None"
                                  value="0" />
                           <Entry text="Color"
                                  value="1" />
                           <Entry text="Label"
                                  value="2" />
                         </EnumerationDomain>
        <Documentation>Generate (cell) data for coloring purposes such that the
        newly generated cells (including capping faces and clipping outlines)
        can be distinguished from the input cells.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetInsideOut"
                         default_values="0"
                         name="InsideOut"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this flag is turned off, the clipper will return the
        portion of the data that lies within the clipping plane. Otherwise, the
        clipper will return the portion of the data that lies outside the
        clipping plane.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetTolerance"
                            default_values="0.000001"
                            label="Clipping Tolerance"
                            name="Tolerance"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Specify the tolerance for creating new points. A small
        value might incur degenerate triangles.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetBaseColor"
                            default_values="0.10 0.10 1.00"
                            label="Base Color"
                            name="BaseColor"
                            number_of_elements="3">
        <DoubleRangeDomain max="1 1 1"
                           min="0 0 0"
                           name="range" />
        <Documentation>Specify the color for the faces from the
        input.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetClipColor"
                            default_values="1.00 0.11 0.10"
                            label="Clip Color"
                            name="ClipColor"
                            number_of_elements="3">
        <DoubleRangeDomain max="1 1 1"
                           min="0 0 0"
                           name="range" />
        <Documentation>Specify the color for the capping faces (generated on
        the clipping interface).</Documentation>
      </DoubleVectorProperty>
      <!-- End Clip -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVThreshold"
                 name="Threshold">
      <Documentation long_help="This filter extracts cells that have point or cell scalars in the specified range."
                     short_help="Extract cells that satisfy a threshold criterion.">
                     The Threshold filter extracts the portions of the input
                     dataset whose scalars lie within the specified range. This
                     filter operates on either point-centered or cell-centered
                     data. This filter operates on any type of dataset and
                     produces unstructured grid output. To select between these
                     two options, select either Point Data or Cell Data from
                     the Attribute Mode menu. Once the Attribute Mode has been
                     selected, choose the scalar array from which to threshold
                     the data from the Scalars menu. The Lower Threshold and
                     Upper Threshold sliders determine the range of the scalars
                     to retain in the output. The All Scalars check box only
                     takes effect when the Attribute Mode is set to Point Data.
                     If the All Scalars option is checked, then a cell will
                     only be passed to the output if the scalar values of all
                     of its points lie within the range indicated by the Lower
                     Threshold and Upper Threshold sliders. If unchecked, then
                     a cell will be added to the output if the specified scalar
                     value for any of its points is within the chosen
                     range.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array"
                          number_of_components="1">
        </InputArrayDomain>
        <Documentation>This property specifies the input to the Threshold
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>The value of this property contains the name of the
        scalar array from which to perform thresholding.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="ThresholdBetween"
                            default_values="0 0"
                            label="Threshold Range"
                            name="ThresholdBetween"
                            number_of_elements="2"
                            panel_widget="double_range">
        <ArrayRangeDomain name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputScalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>The values of this property specify the upper and lower
        bounds of the thresholding operation.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetAllScalars"
                         default_values="1"
                         name="AllScalars"
                         number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                         name="vtkHyperTreeGrid"
                                         exclude="1"
                                         mode="enabled_state" />
        </Hints>
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is 1, then a cell is only
        included in the output if the value of the selected array for all its
        points is within the threshold. This is only relevant when thresholding
        by a point-centered array.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseContinuousCellRange"
                         default_values="0"
                         name="UseContinuousCellRange"
                         number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="enabled_state" />
        </Hints>
        <BooleanDomain name="bool" />
        <Documentation>
          If off, the vertex scalars are treated as a discrete set. If on, they
          are treated as a continuous interval over the minimum and maximum. One
          important "on" use case: When setting lower and upper threshold
          equal to some value and turning AllScalars off, the results are
          cells containing the isosurface for that value.  WARNING: Whether on
          or off, for higher order input, the filter will not give accurate
          results.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetInvert"
                         default_values="0"
                         name="Invert"
                         number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="enabled_state"/>
        </Hints>
        <BooleanDomain name="bool" />
        <Documentation>Invert the threshold results. That is, cells that would have been in the
          output with this option off are excluded, while cells that would have been excluded from
          the output are included.
        </Documentation>
      </IntVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End Threshold -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkIsoVolume"
                 label="Iso Volume"
                 name="IsoVolume">
      <Documentation long_help="This filter extracts cells by clipping cells that have point
       scalars not in the specified range."
                     short_help="Extract cells that satisfy a threshold criterion.">
                     This filter clip away the cells using lower and upper
                     thresholds.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array"
                          number_of_components="1">
        </InputArrayDomain>
        <Documentation>This property specifies the input to the Threshold
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Input Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>The value of this property contains the name of the
        scalar array from which to perform thresholding.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="ThresholdBetween"
                            default_values="0 0"
                            label="Threshold Range"
                            name="ThresholdBetween"
                            number_of_elements="2"
                            panel_widget="double_range">
        <ArrayRangeDomain name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputScalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>The values of this property specify the upper and lower
        bounds of the thresholding operation.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End Iso Volume -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVContourFilter"
                 name="Contour">
      <Documentation long_help="Generate isolines or isosurfaces using point scalars."
                     short_help="Generate isolines or isosurfaces.">The Contour
                     filter computes isolines or isosurfaces using a selected
                     point-centered scalar array. The Contour filter operates
                     on any type of data set, but the input is required to have
                     at least one point-centered scalar (single-component)
                     array. The output of this filter is
                     polygonal.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input dataset to be used by
        the contour filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Contour By"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies the name of the scalar array
        from which the contour filter will compute isolines and/or
        isosurfaces.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComputeNormals"
                         default_values="1"
                         name="ComputeNormals"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkPolyData vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="enabled_state" />
        </Hints>
        <Documentation>If this property is set to 1, a scalar array containing
        a normal value at each point in the isosurface or isoline will be
        created by the contour filter; otherwise an array of normals will not
        be computed. This operation is fairly expensive both in terms of
        computation time and memory required, so if the output dataset produced
        by the contour filter will be processed by filters that modify the
        dataset's topology or geometry, it may be wise to set the value of this
        property to 0. Select whether to compute normals.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComputeGradients"
                         default_values="0"
                         name="ComputeGradients"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="or">
              <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                       name="Structured"
                                       mode="enabled_state"/>
              <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                       name="vtkHyperTreeGrid"
                                       mode="enabled_state"
                                       exclude="1"/>
            </Expression>
          </PropertyWidgetDecorator>
        </Hints>
        <Documentation>If this property is set to 1, a scalar array containing
        a gradient value at each point in the isosurface or isoline will be
        created by this filter; otherwise an array of gradients will not be
        computed. This operation is fairly expensive both in terms of
        computation time and memory required, so if the output dataset produced
        by the contour filter will be processed by filters that modify the
        dataset's topology or geometry, it may be wise to set the value of this
        property to 0. Not that if ComputeNormals is set to 1, then gradients
        will have to be calculated, but they will only be stored in the output
        dataset if ComputeGradients is also set to 1.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComputeScalars"
                         default_values="1"
                         name="ComputeScalars"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="enabled_state"/>
        </Hints>
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, an array of scalars
        (containing the contour value) will be added to the output dataset. If
        set to 0, the output will not contain this array.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetOutputPointsPrecision"
                         default_values="2"
                         name="OutputPointsPrecision"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="enabled_state"/>
        </Hints>
        <EnumerationDomain name="enum">
          <Entry text="Single"
                 value="0" />
          <Entry text="Double"
                 value="1" />
          <Entry text="Same as input"
                 value="2" />
        </EnumerationDomain>
        <Documentation>
Select the output precision of the coordinates. **Single** sets the
output to single-precision floating-point (i.e., float), **Double**
sets it to double-precision floating-point (i.e., double), and
**Default** sets it to the same precision as the precision of the
points in the input. Defaults to ***Single***.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetGenerateTriangles"
                         default_values="1"
                         name="GenerateTriangles"
                         number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkHyperTreeGrid"
                                   exclude="1"
                                   mode="enabled_state"/>
        </Hints>
        <BooleanDomain name="bool" />
        <Documentation>This parameter controls whether to produce triangles in the output.
        Warning: Many filters do not properly handle non-triangular polygons.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetValue"
                            label="Isosurfaces"
                            name="ContourValues"
                            number_of_elements="0"
                            number_of_elements_per_command="1"
                            repeat_command="1"
                            set_number_command="SetNumberOfContours"
                            use_index="1">
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputScalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>This property specifies the values at which to compute
        isosurfaces/isolines and also the number of such
        values.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- incremental point locator begin -->
      <ProxyProperty command="SetLocator"
                     label="Point Merge Method"
                     name="Locator"
                     panel_visibility="advanced" >
        <ProxyGroupDomain name="groups">
          <Group name="incremental_point_locators" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="incremental_point_locators"
                 name="MergePoints" />
          <Proxy group="incremental_point_locators"
                 name="IncrementalOctreeMergePoints" />
          <Proxy group="incremental_point_locators"
                 name="NonMergingPointLocator" />
        </ProxyListDomain>
        <Documentation>This property specifies an incremental point locator for
        merging duplicate / coincident points.</Documentation>
      </ProxyProperty>
      <!-- incremental point locator end -->

      <PropertyGroup label="Isosurfaces">
        <Property name="ContourValues" />
      </PropertyGroup>
      <PropertyGroup label="Point Locator">
        <Property name="Locator" />
      </PropertyGroup>

      <!-- End Contour -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVGlyphFilter"
                 name="Glyph">
      <Documentation long_help="This filter produces a glyph at points or cell centers in an input data set. The glyphs can be oriented and scaled by point or cell attributes of the input dataset."
                     short_help="Generate glyphs that represent attributes in the input data set.">
The Glyph filter generates a glyph (i.e., an arrow, cone, cube, cylinder, line,
sphere, or 2D glyph) at each point or cell in the input dataset. The glyphs can be
oriented and scaled by the input scalar and vector arrays. If the arrays are
point-centered, glyphs are placed at points in the input dataset. If the arrays
are cell-centered, glyphs are placed at the center of cells in the input dataset.
A transform that applies to the glyph source can be modified to change the shape
of the glyph. This filter operates on any type of data set. Its output is a polygonal
dataset.

To use this filter, select the **Orientation Array** to orient the glyphs and the
**Scale Array** to control glyph scaling if desired - each array
can be set to 'No array' if orientation or scaling is not desired. When scaling
by a 3-element vector array, the **Vector Scale Mode** can be set to either
'Scale by Magnitude', which scales glyphs according to the vector magnitude,
or 'Scale by Components', which treats each component as a separate scaling
factor in the corresponding dimension, i.e., the first component is the
scaling factor in the x-dimension, the second component scales the y-dimension,
and the third component scales the z-dimension. An overall constant **Scale Factor**
is applied following the scaling controlled by other properties of this filter.

The **Glyph Mode** property controls which points in the input dataset
are selected for glyphing since in most cases, glyphing all points in
the input dataset can be both performance impeding as well as visually
cluttered.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="scale_array"
                          number_of_components="1,3"
                          optional="1" />
        <InputArrayDomain name="vector_array"
                          number_of_components="3"
                          optional="1" />
        <Documentation>
This property specifies the input to this filter. This is the
dataset from which the locations are selected to be glyphed.
        </Documentation>
      </InputProperty>
      <InputProperty command="SetSourceConnection"
                     label="Glyph Type"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="glyph_sources" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="sources" name="ArrowSource" />
          <Proxy group="sources" name="ConeSource" />
          <Proxy group="sources" name="CubeSource" />
          <Proxy group="sources" name="CylinderSource" />
          <Proxy group="sources" name="LineSource" />
          <Proxy group="sources" name="SphereSource" />
          <Proxy group="sources" name="GlyphSource2D" />
        </ProxyListDomain>
        <Hints>
          <ProxyPropertyWidget selected_proxy_panel_visibility="advanced" />
          <!-- show the selected proxy's panel, only in advanced mode. -->
        </Hints>
        <Documentation>
This property determines which type of glyph will be placed at the
points in the input dataset.
        </Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="1"
                            element_types="0 0 0 0 2"
                            name="OrientationArray"
                            number_of_elements="5">
        <!-- default value=1 so normals go to the right place -->
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="vector_array"
                         name="array_list"
                         none_string="No orientation array">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
Select the input array to use for orienting the glyphs.
        </Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="0"
                            element_types="0 0 0 0 2"
                            name="ScaleArray"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="scale_array"
                         name="array_list"
                         none_string="No scale array">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
Select the input array to be used for scaling the glyphs. If the scale
array is a vector array, you can control how the glyphs are scaled with
the **Vector Scale Mode** property.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetVectorScaleMode"
                         default_values="0"
                         name="VectorScaleMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Scale by Magnitude"
                 value="0" />
          <Entry text="Scale by Components"
                 value="1" />
        </EnumerationDomain>
        <Documentation>
Select the mode when the scaling array is a vector. **Scale by Magnitude** scales the glyph by
the vector magnitude. **Scale by Components** scales glyphs by each vector component in the dimension
that component represents, e.g., the x-direction is scaled by component 0, the y-direction is
scaled by component 1, and so on.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="ScaleArray"
                                   number_of_components="3"
                                   index="4" />
        </Hints>
      </IntVectorProperty>

      <IntVectorProperty information_only="1"
                         name="ComponentSelection"
                         default_values="4"
                         number_of_elements="1"
                         panel_visibility="never">
        <Documentation>
Specifies array component to use. Fixed at 4 to ensure the
ArrayRangeDomain is set to the vector magnitude for up to 3-component
arrays.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetScaleFactor"
                            default_values="1.0"
                            name="ScaleFactor"
                            number_of_elements="1"
                            panel_widget="glyph_scale_factor">
        <BoundsDomain mode="scaled_extent" name="bounds" scale_factor="0.1">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="ScaleArray" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <ArrayRangeDomain name="vector_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="OrientationArray" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>Specify the constant multiplier to use to scale the glyphs.
        </Documentation>
      </DoubleVectorProperty>
      <ProxyProperty command="SetSourceTransform"
                     name="GlyphTransform"
                     panel_visibility="advanced">
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources"
                 name="Transform2" />
        </ProxyListDomain>
        <Documentation>
The values in this property allow you to specify the transform
(translation, rotation, and scaling) to apply to the glyph
source.</Documentation>
      </ProxyProperty>

      <IntVectorProperty command="SetGlyphMode"
                         default_values="2"
                         name="GlyphMode"
                         number_of_elements="1"
                         panel_visibility="default">
        <EnumerationDomain name="enum">
          <Entry text="All Points" value="0"/>
          <Entry text="Every Nth Point" value="1"/>
          <Entry text="Uniform Spatial Distribution (Bounds Based)" value="2"/>
          <Entry text="Uniform Spatial Distribution (Surface Sampling)" value="3"/>
          <Entry text="Uniform Spatial Distribution (Volume Sampling)" value="4"/>
        </EnumerationDomain>
        <Documentation>
This property indicates the mode that will be used to generate
glyphs from the dataset.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSamplePoints"
                        number_of_elements="1"
                        default_values="5000"
                        name="MaximumNumberOfSamplePoints">
        <IntRangeDomain min="1" name="range" />
        <Documentation>
This property specifies the maximum number of sample points to use
when sampling the space when Uniform Spatial Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="or">
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="GlyphMode" value="2" inverse="0" />
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="GlyphMode" value="3" inverse="0" />
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="GlyphMode" value="4" inverse="0" />
            </Expression>
          </PropertyWidgetDecorator>
          <!-- show this widget when GlyphMode==2||3||4 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetSeed"
                        number_of_elements="1"
                        default_values="10339"
                        name="Seed">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
This property specifies the seed that will be used for generating a
uniform distribution of glyph points when a Uniform Spatial
Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="CompositeDecorator">
            <Expression type="or">
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="GlyphMode" value="2" inverse="0" />
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="GlyphMode" value="3" inverse="0" />
              <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="GlyphMode" value="4" inverse="0" />
            </Expression>
          </PropertyWidgetDecorator>
          <!-- show this widget when GlyphMode==2||3||4 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetStride"
                         number_of_elements="1"
                         default_values="1"
                         name="Stride">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
This property specifies the stride that will be used when glyphing by
Every Nth Point.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="1" />
          <!-- show this widget when GlyphMode==1 -->
        </Hints>
     </IntVectorProperty>

      <PropertyGroup label="Glyph Source">
        <Property name="Source" />
      </PropertyGroup>
      <PropertyGroup label="Orientation">
        <Property name="OrientationArray" />
      </PropertyGroup>
      <PropertyGroup label="Scale">
        <Property name="ScaleArray" />
        <Property name="VectorScaleMode" />
        <Property name="ScaleFactor" />
      </PropertyGroup>
      <PropertyGroup label="Glyph Transform">
        <Property name="GlyphTransform" />
      </PropertyGroup>
      <PropertyGroup label="Masking">
        <Property name="GlyphMode" />
        <Property name="MaximumNumberOfSamplePoints" />
        <Property name="Seed" />
        <Property name="Stride" />
      </PropertyGroup>

      <Hints>
        <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
        <Visibility replace_input="0" />
      </Hints>
      <!-- End Glyph -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVGlyphFilterLegacy"
                 name="GlyphLegacy">
      <Deprecated deprecated_in="5.6" to_remove_in="5.7">
        It has been replaced by 'GlyphWithCustomSource'. Please consider using that instead.
      </Deprecated>
      <Documentation long_help="This filter produces a glyph at each point of in input data set.  The glyphs can be oriented and scaled by point attributes of the input dataset."
                     short_help="Generate a glyph at each point of the input data set.">
The Glyph filter generates a glyph (i.e., an arrow, cone, cube,
cylinder, line, sphere, or 2D glyph) at each point in the input
dataset. The glyphs can be oriented and scaled by the input
point-centered scalars and vectors. The Glyph filter operates on any
type of data set. Its output is polygonal

To use this filter, you first select the arrays to use for as the
**Scalars** and **Vectors**, if any.  To orient the glyphs using the
selected **Vectors**, use **Orient** property.  To scale the glyphs using
the selected **Scalars** or **Vectors**, use the **Scale Mode** property.

The **Glyph Mode** property controls which points in the input dataset
are selected for glyphing (since in most cases, glyphing all points in
the input dataset can be both performance impeding as well as visually
cluttered.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array1"
                          number_of_components="1"
                          optional="1" />
        <InputArrayDomain name="input_array2"
                          number_of_components="3"
                          optional="1" />
        <Documentation>
This property specifies the input to the Glyph filter.  This is the
dataset from which the points are selected to be glyphed.
        </Documentation>
      </InputProperty>
      <InputProperty command="SetSourceConnection"
                     label="Glyph Type"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="glyph_sources" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="sources" name="ArrowSource" />
          <Proxy group="sources" name="ConeSource" />
          <Proxy group="sources" name="CubeSource" />
          <Proxy group="sources" name="CylinderSource" />
          <Proxy group="sources" name="LineSource" />
          <Proxy group="sources" name="SphereSource" />
          <Proxy group="sources" name="GlyphSource2D" />
        </ProxyListDomain>
        <Hints>
          <ProxyPropertyWidget selected_proxy_panel_visibility="advanced" />
          <!-- show the selected proxy's panel, only in advanced mode. -->
        </Hints>
        <Documentation>This property determines which type of glyph will be
        placed at the points in the input dataset.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="0"
                            element_types="0 0 0 0 2"
                            name="Scalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array1"
                         name="array_list"
                         none_string="None">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
Select the input array to be treated as the active **Scalars**.  You
can scale the glyphs using the selected scalars by setting the **Scale
Mode** property to **scalar**.
        </Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="1"
                            element_types="0 0 0 0 2"
                            name="Vectors"
                            number_of_elements="5">
        <!-- default value=1 so normals go to the right place -->
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="input_array2"
                         name="array_list"
                         none_string="None">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
Select the input array to be treated as the active **Vectors**.  You can
scale the glyphs using the selected vectors by setting the **Scale
Mode** property to **vector** or **vector_components**. You can orient the
glyphs using the selected vectors by checking the **Orient** property.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetOrient"
                         default_values="1"
                         name="Orient"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>
If this property is set to 1, the glyphs will be oriented based on the
vectors selected using the **Vectors** property.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetScaleMode"
                         default_values="3"
                         name="ScaleMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="scalar"
                 value="0" />
          <Entry text="vector"
                 value="1" />
          <Entry text="vector_components"
                 value="2" />
          <Entry text="off"
                 value="3" />
        </EnumerationDomain>
        <Documentation>
Select how to scale the glyphs. Set to **off** to disable scaling
entirely. Set to **scalar** to scale the glyphs using the array selected
using the **Scalars** property. Set to **vector** to scale the glyphs
using the magnitude of the array selected using the **Vectors**
property.  Set to **vector_components** to scale using the **Vectors**,
scaling each component individually.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetScaleFactor"
                            default_values="1.0"
                            name="ScaleFactor"
                            number_of_elements="1"
                            panel_widget="glyph_scale_factor">
        <BoundsDomain mode="scaled_extent" name="bounds" scale_factor="0.1">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="Scalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <ArrayRangeDomain name="vector_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="Vectors" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>Specify the constant multiplier to use to scale the glyphs.
        </Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetGlyphMode"
                         default_values="2"
                         name="GlyphMode"
                         number_of_elements="1"
                         panel_visibility="default">
        <EnumerationDomain name="enum">
          <Entry text="All Points" value="0"/>
          <Entry text="Every Nth Point" value="1"/>
          <Entry text="Uniform Spatial Distribution" value="2"/>
        </EnumerationDomain>
        <Documentation>
          This property indicates the mode that will be used to generate
          glyphs from the dataset.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSamplePoints"
                        number_of_elements="1"
                        default_values="5000"
                        name="MaximumNumberOfSamplePoints">
        <IntRangeDomain min="1" name="range" />
        <Documentation>
This property specifies the maximum number of sample points to use
when sampling the space when Uniform Spatial Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="2" />
          <!-- show this widget when GlyphMode==2 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetSeed"
                        number_of_elements="1"
                        default_values="10339"
                        name="Seed">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
This property specifies the seed that will be used for generating a
uniform distribution of glyph points when a Uniform Spatial
Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="2" />
          <!-- show this widget when GlyphMode==2 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetStride"
                         number_of_elements="1"
                         default_values="1"
                         name="Stride">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
This property specifies the stride that will be used when glyphing by
Every Nth Point.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="1" />
          <!-- show this widget when GlyphMode==1 -->
        </Hints>
     </IntVectorProperty>

     <ProxyProperty command="SetSourceTransform"
                     name="GlyphTransform"
                     panel_visibility="advanced">
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources"
                 name="Transform2" />
        </ProxyListDomain>
        <Documentation>
The values in this property allow you to specify the transform
(translation, rotation, and scaling) to apply to the glyph
source.</Documentation>
      </ProxyProperty>

      <PropertyGroup label="Glyph Source">
        <Property name="Source" />
      </PropertyGroup>
      <PropertyGroup label="Active Attributes">
        <Property name="Scalars" />
        <Property name="Vectors" />
      </PropertyGroup>
      <PropertyGroup label="Glyph Transform">
        <Property name="GlyphTransform" />
      </PropertyGroup>
      <PropertyGroup label="Orientation">
        <Property name="Orient" />
      </PropertyGroup>
      <PropertyGroup label="Scaling">
        <Property name="ScaleMode"/>
        <Property name="ScaleFactor"/>
      </PropertyGroup>
      <PropertyGroup label="Masking">
        <Property name="GlyphMode" />
        <Property name="MaximumNumberOfSamplePoints" />
        <Property name="Seed" />
        <Property name="Stride" />
      </PropertyGroup>

      <Hints>
        <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
        <Visibility replace_input="0" />
      </Hints>
      <!-- End Glyph -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVGlyphFilter"
                 name="GlyphWithCustomSource"
                 label="Glyph With Custom Source">
                 The glyph is provided as the **Source** input to this filter.
      <Documentation long_help="This filter produces a glyph at points or cell centers in an input data set. The glyphs can be oriented and scaled by point or cell attributes of the input dataset."
                     short_help="Generate glyphs that represent attributes in the input data set.">
The **Glyph With Custom Source** filter generates a glyph specified as the **Source**
input to this filter at each point in the input dataset. The glyphs can be
oriented and scaled by the input scalar and vector arrays. If the arrays are
point-centered, glyphs are placed at points in the input dataset. If the arrays
are cell-centered, glyphs are placed at the center of cells in the input dataset.
A transform that applies to the glyph source can be modified to change the shape
of the glyph. This filter operates on any type of data set. Its output is a polygonal
dataset.

To use this filter, select the **Orientation Array** to orient the glyphs and the
**Scale Array** to control glyph scaling if desired - each array
can be set to 'No array' if orientation or scaling is not desired. When scaling
by a 3-element vector array, the **Vector Scale Mode** can be set to either
'Scale by Magnitude', which scales glyphs according to the vector magnitude,
or 'Scale by Components', which treats each component as a separate scaling
factor in the corresponding dimension, i.e., the first component is the
scaling factor in the x-dimension, the second component scales the y-dimension,
and the third component scales the z-dimension. An overall constant **Scale Factor**
is applied following the scaling controlled by other properties of this filter.

The **Glyph Mode** property controls which points in the input dataset
are selected for glyphing since in most cases, glyphing all points in
the input dataset can be both performance impeding as well as visually
cluttered.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="scale_array"
                          number_of_components="1,3"
                          optional="1" />
        <InputArrayDomain name="vector_array"
                          number_of_components="3"
                          optional="1" />
        <Documentation>
This property specifies the input to this filter. This is the
dataset from which the locations are selected to be glyphed.
        </Documentation>
      </InputProperty>
      <InputProperty command="SetSourceConnection"
                     label="Glyph Source"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="glyph_sources" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>
This property determines the glyph geometry source that will be
placed at the points in the input dataset.
        </Documentation>
        <Hints>
          <ProxyPropertyWidget selected_proxy_panel_visibility="advanced" />
          <!-- show the selected proxy's panel, only in advanced mode. -->
        </Hints>
        <Documentation>
This property determines which glyph will be placed at the
points in the input dataset.
        </Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="1"
                            element_types="0 0 0 0 2"
                            name="OrientationArray"
                            number_of_elements="5">
        <!-- default value=1 so normals go to the right place -->
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="vector_array"
                         name="array_list"
                         none_string="No orientation array">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
Select the input array to use for orienting the glyphs.
        </Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="0"
                            element_types="0 0 0 0 2"
                            name="ScaleArray"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="scale_array"
                         name="array_list"
                         none_string="No scale array">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
Select the input array to be used for scaling the glyphs. If the scale
array is a vector array, you can control how the glyphs are scaled with
the **Vector Scale Mode** property.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetVectorScaleMode"
                         default_values="0"
                         name="VectorScaleMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Scale by Magnitude"
                 value="0" />
          <Entry text="Scale by Components"
                 value="1" />
        </EnumerationDomain>
        <Documentation>
Select the mode when the scaling array is a vector. **Scale by Magnitude** scales the glyph by
the vector magnitude. **Scale by Components** scales glyphs by each vector component in the dimension
that component represents, e.g., the x-direction is scaled by component 0, the y-direction is
scaled by component 1, and so on.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="ScaleArray"
                                   number_of_components="3"
                                   index="4" />
        </Hints>
      </IntVectorProperty>

      <IntVectorProperty information_only="1"
                         name="ComponentSelection"
                         default_values="4"
                         number_of_elements="1"
                         panel_visibility="never">
        <Documentation>
Specifies array component to use. Fixed at 4 to ensure the
ArrayRangeDomain is set to the vector magnitude for up to 3-component
arrays.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetScaleFactor"
                            default_values="1.0"
                            name="ScaleFactor"
                            number_of_elements="1"
                            panel_widget="glyph_scale_factor">
        <BoundsDomain mode="scaled_extent" name="bounds" scale_factor="0.1">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="ScaleArray" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <ArrayRangeDomain name="vector_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="OrientationArray" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>Specify the constant multiplier to use to scale the glyphs.
        </Documentation>
      </DoubleVectorProperty>
      <ProxyProperty command="SetSourceTransform"
                     name="GlyphTransform"
                     panel_visibility="advanced">
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources"
                 name="Transform2" />
        </ProxyListDomain>
        <Documentation>
The values in this property allow you to specify the transform
(translation, rotation, and scaling) to apply to the glyph
source.</Documentation>
      </ProxyProperty>

      <IntVectorProperty command="SetGlyphMode"
                         default_values="2"
                         name="GlyphMode"
                         number_of_elements="1"
                         panel_visibility="default">
        <EnumerationDomain name="enum">
          <Entry text="All Points" value="0"/>
          <Entry text="Every Nth Point" value="1"/>
          <Entry text="Uniform Spatial Distribution" value="2"/>
        </EnumerationDomain>
        <Documentation>
This property indicates the mode that will be used to generate
glyphs from the dataset.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSamplePoints"
                        number_of_elements="1"
                        default_values="5000"
                        name="MaximumNumberOfSamplePoints">
        <IntRangeDomain min="1" name="range" />
        <Documentation>
This property specifies the maximum number of sample points to use
when sampling the space when Uniform Spatial Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="2" />
          <!-- show this widget when GlyphMode==2 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetSeed"
                        number_of_elements="1"
                        default_values="10339"
                        name="Seed">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
This property specifies the seed that will be used for generating a
uniform distribution of glyph points when a Uniform Spatial
Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="2" />
          <!-- show this widget when GlyphMode==2 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetStride"
                         number_of_elements="1"
                         default_values="1"
                         name="Stride">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
This property specifies the stride that will be used when glyphing by
Every Nth Point.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="1" />
          <!-- show this widget when GlyphMode==1 -->
        </Hints>
     </IntVectorProperty>

      <PropertyGroup label="Glyph Source">
        <Property name="Source" />
      </PropertyGroup>
      <PropertyGroup label="Orientation">
        <Property name="OrientationArray" />
      </PropertyGroup>
      <PropertyGroup label="Scale">
        <Property name="ScaleArray" />
        <Property name="VectorScaleMode" />
        <Property name="ScaleFactor" />
      </PropertyGroup>
      <PropertyGroup label="Glyph Transform">
        <Property name="GlyphTransform" />
      </PropertyGroup>
      <PropertyGroup label="Masking">
        <Property name="GlyphMode" />
        <Property name="MaximumNumberOfSamplePoints" />
        <Property name="Seed" />
        <Property name="Stride" />
      </PropertyGroup>

      <Hints>
        <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
        <Visibility replace_input="0" />
      </Hints>
      <!-- End Glyph -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVGlyphFilterLegacy"
                 label="Glyph With Custom Source Legacy"
                 name="GlyphWithCustomSourceLegacy">
      <Documentation long_help="This filter generates a glyph at each point of the input data set.  The glyphs can be oriented and scaled by point attributes of the input dataset."
                     short_help="Generate a glyph symbol at each point of the input data set.">
      The Glyph filter generates a glyph at each point in the input dataset.
      The glyphs can be oriented and scaled by the input point-centered scalars
      and vectors. The Glyph filter operates on any type of data set. Its
      output is polygonal. This filter is available on the
      Toolbar.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array1"
                          number_of_components="1"
                          optional="1" />
        <InputArrayDomain attribute_type="point"
                          name="input_array2"
                          number_of_components="3"
                          optional="1" />
        <Documentation>This property specifies the input to the Glyph filter.
        This is the dataset from which the points are selected to be glyphed.
        </Documentation>
      </InputProperty>
      <InputProperty command="SetSourceConnection"
                     label="Glyph Type"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="glyph_sources" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property determines which type of glyph will be
        placed at the points in the input dataset.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="Scalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array1"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Select the input array to be treated as the active "Scalars".
          You can scale the glyphs using the selected scalars by setting the
          "Scale Mode" property to "scalar"
        </Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="1"
                            element_types="0 0 0 0 2"
                            name="Vectors"
                            number_of_elements="5">
        <!-- default value=1 so normals go to the right place -->
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="input_array2"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Select the input array to be treated as the active "Vectors".
          You can scale the glyphs using the selected vectors by setting the "Scale Mode"
          property to "vector" or "vector_components". You can orient the glyphs using the
          selected vectors by checking the "Orient" property.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetOrient"
                         default_values="1"
                         name="Orient"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the glyphs will be
          oriented based on the vectors selected using the "Vectors" property.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetScaleMode"
                         default_values="3"
                         name="ScaleMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="scalar"
                 value="0" />
          <Entry text="vector"
                 value="1" />
          <Entry text="vector_components"
                 value="2" />
          <Entry text="off"
                 value="3" />
        </EnumerationDomain>
        <Documentation>Select how to scale the glyphs. Set to "off" to disable
          scaling entirely. Set to "scalar" to scale the glyphs using the
          array selected using the "Scalars" property. Set to "vector" to scale the
          glyphs using the magnitude of the array selected using the "Vectors" property.
          Set to "vector_components" to scale using the "Vectors", scaling each component
          individually.
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetScaleFactor"
                            default_values="1.0"
                            name="ScaleFactor"
                            number_of_elements="1"
                            panel_widget="glyph_scale_factor">
        <BoundsDomain mode="scaled_extent" name="bounds" scale_factor="0.1">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="Scalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <ArrayRangeDomain name="vector_range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
            <Property function="ArraySelection" name="Vectors" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>Specify the constant multiplier to use to scale the glyphs.
        </Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetGlyphMode"
                         default_values="2"
                         name="GlyphMode"
                         number_of_elements="1"
                         panel_visibility="default">
        <EnumerationDomain name="enum">
          <Entry text="All Points" value="0"/>
          <Entry text="Every Nth Point" value="1"/>
          <Entry text="Uniform Spatial Distribution" value="2"/>
        </EnumerationDomain>
        <Documentation>
          This property indicates the mode that will be used to generate
          glyphs from the dataset.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSamplePoints"
                        number_of_elements="1"
                        default_values="5000"
                        name="MaximumNumberOfSamplePoints">
        <IntRangeDomain min="1" name="range" />
        <Documentation>
          This property specifies the maximum number of sample points to use
          when sampling the space when Uniform Spatial Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="2" />
          <!-- show this widget when GlyphMode==2 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetSeed"
                        number_of_elements="1"
                        default_values="10339"
                        name="Seed">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
          This property specifies the seed that will be used for generating
          a uniform distribution of glyph points when a Uniform Spatial
          Distribution is used.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="2" />
          <!-- show this widget when GlyphMode==2 -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetStride"
                         number_of_elements="1"
                         default_values="1"
                         name="Stride">
        <IntRangeDomain min="1" name="range"/>
        <Documentation>
          This property specifies the stride that will be used when glyphing
          by Every Nth Point.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="GlyphMode"
                                   value="1" />
          <!-- show this widget when GlyphMode==1 -->
        </Hints>
     </IntVectorProperty>

     <ProxyProperty command="SetSourceTransform"
                     name="GlyphTransform"
                     panel_visibility="advanced">
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources"
                 name="Transform2" />
        </ProxyListDomain>
        <Documentation>The values in this property allow you to specify the
        transform (translation, rotation, and scaling) to apply to the glyph
        source.</Documentation>
      </ProxyProperty>

      <PropertyGroup label="Glyph Source">
        <Property name="Source" />
      </PropertyGroup>
      <PropertyGroup label="Active Attributes">
        <Property name="Scalars" />
        <Property name="Vectors" />
      </PropertyGroup>
      <PropertyGroup label="Glyph Transform">
        <Property name="GlyphTransform" />
      </PropertyGroup>
      <PropertyGroup label="Orientation">
        <Property name="Orient" />
      </PropertyGroup>
      <PropertyGroup label="Scaling">
        <Property name="ScaleMode"/>
        <Property name="ScaleFactor"/>
      </PropertyGroup>
      <PropertyGroup label="Masking">
        <Property name="GlyphMode" />
        <Property name="MaximumNumberOfSamplePoints" />
        <Property name="Seed" />
        <Property name="Stride" />
      </PropertyGroup>

      <Hints>
        <!-- Visibility Element can be used to suggest the GUI about
          visibility of this filter (or its input) on creation.
          replace_input="0" implies that the input visibility is not
            changed on creation of this filter (defaults to "1")
       -->
        <Visibility replace_input="0" />
      </Hints>
      <!-- End GlyphWithCustomSource -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVExtractVOI"
                 label="Extract Subset"
                 name="ExtractGrid">
      <Documentation long_help="Extract a subgrid from a structured grid with the option of setting subsample strides."
                     short_help="Extract a subgrid or subsample.">The Extract
                     Grid filter returns a subgrid of a structured input data
                     set (uniform rectilinear, curvilinear, or nonuniform
                     rectilinear). The output data set type of this filter is
                     the same as the input type.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
          <DataType value="vtkRectilinearGrid" />
          <DataType value="vtkStructuredPoints" />
          <DataType value="vtkStructuredGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Extract Grid
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetVOI"
                         default_values="0 0 0 0 0 0"
                         name="VOI"
                         number_of_elements="6"
                         panel_visibility="default">
        <ExtentDomain name="extent">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ExtentDomain>
        <Documentation>This property specifies the minimum and maximum point
        indices along each of the I, J, and K axes; these values indicate the
        volume of interest (VOI). The output will have the (I,J,K) extent
        specified here.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetSampleRateI"
                         default_values="1"
                         name="SampleRateI"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <IntRangeDomain min="1"
                        name="range" />
        <Documentation>This property indicates the sampling rate in the I
        dimension. A value greater than 1 results in subsampling; every nth
        index will be included in the output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetSampleRateJ"
                         default_values="1"
                         name="SampleRateJ"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <IntRangeDomain min="1"
                        name="range" />
        <Documentation>This property indicates the sampling rate in the J
        dimension. A value greater than 1 results in subsampling; every nth
        index will be included in the output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetSampleRateK"
                         default_values="1"
                         name="SampleRateK"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <IntRangeDomain min="1"
                        name="range" />
        <Documentation>This property indicates the sampling rate in the K
        dimension. A value greater than 1 results in subsampling; every nth
        index will be included in the output.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIncludeBoundary"
                         default_values="0"
                         name="IncludeBoundary"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>If the value of this property is 1, then if the sample
        rate in any dimension is greater than 1, the boundary indices of the
        input dataset will be passed to the output even if the boundary extent
        is not an even multiple of the sample rate in a given
        dimension.</Documentation>
      </IntVectorProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
      <!-- End ExtractGrid -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkHybridProbeFilter"
                 label="Extract Location"
                 name="ExtractLocation">
      <Documentation long_help="Sample or extract cells at a point."
        short_help="Sample or extracy cells at a point.">
        This filter allows you to specify a location and then either interpolate
        the data attributes from the input dataset at that location or extract the
        cell(s) at the location.
      </Documentation>
      <InputProperty command="SetInputConnection" name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>Set the input dataset producer</Documentation>
      </InputProperty>

      <IntVectorProperty name="Mode"
        command="SetMode"
        number_of_elements="1"
        default_values="1">
        <EnumerationDomain name="enum">
          <Entry text="Interpolate At Location" value="0" />
          <Entry text="Extract Cell At Location" value="1" />
        </EnumerationDomain>
        <Documentation>
          Select whether to interpolate (probe) data attributes at the specified
          location, or to extract cell(s) containing the specified location.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty command="SetLocation"
                            default_values="0.0 0.0 0.0"
                            name="Location"
                            number_of_elements="3">
        <Documentation>Select the location of interest in 3D space.</Documentation>
        <BoundsDomain default_mode="mid"
                      mode="normal"
                      name="range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <PropertyGroup label="Location Parameters" panel_widget="InteractiveHandle">
        <Property function="WorldPosition" name="Location" />
        <Property function="Input" name="Input" />
      </PropertyGroup>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>

      <!-- End ProbePoint -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPProbeFilter"
                 label="Probe Location"
                 name="ProbePoint">
      <Documentation long_help="Sample data attributes at the points in a point cloud."
                     short_help="Sample data values at the points in a point cloud.">
                     The Probe filter samples the data set attributes of the
                     current data set at the points in a point cloud. The Probe
                     filter uses interpolation to determine the values at the
                     selected point, whether or not it lies at an input point.
                     The Probe filter operates on any type of data and produces
                     polygonal output (a point cloud).</Documentation>
      <InputProperty command="SetSourceConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>This property specifies the dataset from which to obtain
        probe values.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     label="Probe Type"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources"
                 name="FixedRadiusPointSource" />
        </ProxyListDomain>
        <Documentation>This property specifies the dataset whose geometry will
        be used in determining positions to probe.</Documentation>
      </InputProperty>

      <IntVectorProperty command="SetPassFieldArrays"
                         default_values="1"
                         name="PassFieldArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to pass the field-data arrays from the Input i.e. the input
        providing the geometry to the output. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty command="SetComputeTolerance"
                         default_values="1"
                         name="ComputeTolerance"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to compute the tolerance or to use a user provided
        value. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <DoubleVectorProperty command="SetTolerance"
                            default_values="2.2204460492503131e-16"
                            name="Tolerance"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain min="2.2204460492503131e-16"
                           name="range" />
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="ComputeTolerance" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
        <Documentation>Set the tolerance to use for
        vtkDataSet::FindCell</Documentation>
      </DoubleVectorProperty>

      <Hints>
        <Visibility replace_input="0" />
        <View type="SpreadSheetView" />
      </Hints>
      <!-- End ProbePoint -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <CompoundSourceProxy label="Plot Over Line"
                         name="ProbeLine">
      <Documentation long_help="Sample data attributes at the points along a line.  Probed lines will be displayed in a graph of the attributes."
                     short_help="Sample data values at the points along a line.">
                     The Plot Over Line filter samples the data set attributes
                     of the current data set at the points along a line. The
                     values of the point-centered variables along that line
                     will be displayed in an XY Plot. This filter uses
                     interpolation to determine the values at the selected
                     point, whether or not it lies at an input point. The Probe
                     filter operates on any type of data and produces polygonal
                     output (a line).</Documentation>
      <Proxy compound_name="PlotOverLine1"
             group="internal_filters"
             id="491"
             servers="1"
             type="ProbeLine" />
      <Proxy compound_name="AppendArcLength1"
             group="filters"
             id="588"
             servers="1"
             type="AppendArcLength">
        <Property id="588.Input"
                  name="Input"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="491" />
        </Property>
      </Proxy>
      <ExposedProperties>
        <Property exposed_name="Input"
                  name="Input"
                  proxy_name="PlotOverLine1" />
        <Property exposed_name="Source"
                  name="Source"
                  proxy_name="PlotOverLine1" />
        <Property exposed_name="PassPartialArrays"
                  name="PassPartialArrays"
                  proxy_name="PlotOverLine1" />
        <Property exposed_name="ComputeTolerance"
                  name="ComputeTolerance"
                  proxy_name="PlotOverLine1" />
        <Property exposed_name="Tolerance"
                  name="Tolerance"
                  proxy_name="PlotOverLine1" />
      </ExposedProperties>
      <OutputPort name="Output"
                  port_index="0"
                  proxy="AppendArcLength1" />
      <Hints>
        <Visibility replace_input="0" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" also_show_in_current_view="1" />
        <Plotable />
      </Hints>
      <!-- End ProbeLine -->
    </CompoundSourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPProbeFilter"
                 label="Legacy Resample With Dataset"
                 name="Probe">
      <Documentation long_help="Sample data attributes at the points of a dataset."
                     short_help="Sample data values at the points of a dataset.">
                     Probe is a filter that computes point attributes at
                     specified point positions. The filter has two inputs: the
                     Input and Source.  The 'Source' geometric structure is passed
                     through the filter. The point attributes are computed at
                     the 'Source' point positions by interpolating into the
                     'Input' data. For example, we can compute data values on a plane
                     (plane specified as Source) from a volume (Input). The
                     cell data of the Input data is copied to the output based
                     on in which Input cell each Source point is. If an array
                     of the same name exists both in Input's point and cell
                     data, only the one from the point data is
                     probed. This is the implementation of the
                     'Resample With Dataset' filter available in ParaView
                     version 5.1 and earlier. </Documentation>
      <Deprecated deprecated_in="5.2" to_remove_in="5.3">
        This has been replaced by 'Resample With Dataset'. Please consider
        using that instead.
      </Deprecated>
      <InputProperty command="SetSourceConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>This property specifies the dataset from which to obtain
        probe values. The data attributes come from this dataset.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the dataset whose geometry will
        be used in determining positions to probe. The mesh comes from this
        dataset.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPassCellArrays"
                         default_values="0"
                         name="PassCellArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        When set the input's cell data arrays are shallow copied to the output.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetPassPointArrays"
                         default_values="0"
                         name="PassPointArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        When set the input's point data arrays are shallow copied to the output.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty command="SetPassFieldArrays"
                         default_values="1"
                         name="PassFieldArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to pass the field-data arrays from the Input i.e. the input
        providing the geometry to the output. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty command="SetComputeTolerance"
                         default_values="1"
                         name="ComputeTolerance"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to compute the tolerance or to use a user provided
        value. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <DoubleVectorProperty command="SetTolerance"
                            default_values="2.2204460492503131e-16"
                            name="Tolerance"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain min="2.2204460492503131e-16"
                           name="range" />
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="ComputeTolerance" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
        <Documentation>Set the tolerance to use for
        vtkDataSet::FindCell</Documentation>
      </DoubleVectorProperty>

      <Hints>
        <Visibility replace_input="1" />
      </Hints>
      <!-- End Probe -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPResampleFilter"
                 name="ImageResampling">
      <Documentation long_help="Sample data attributes using a 3D image as probing mesh."
                     short_help="Sample data values using a 3D image."/>
      <Deprecated deprecated_in="5.1" to_remove_in="5.2">Please use "Resample To Image" instead instead of "ImageResampling" filter.</Deprecated>
      <InputProperty command="SetInputConnection" name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the dataset whose data will
        be probed</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetSamplingDimension"
                         default_values="10 10 10"
                         name="SamplingDimension"
                         number_of_elements="3"
                         panel_visibility="default">
                         <IntRangeDomain name="range" min="2 2 2" max="10000 10000 10000"/>
        <Documentation>
        How many linear resampling we want along each axis
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseInputBounds"
                         default_values="1"
                         name="UseInputBounds"
                         number_of_elements="1"
                         panel_visibility="default">
        <Documentation>
        Do we use input bounds or custom ones?
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <DoubleVectorProperty command="SetCustomSamplingBounds"
                         default_values="0 1 0 1 0 1"
                         name="CustomSamplingBounds"
                         number_of_elements="6"
                         panel_visibility="default">
        <Documentation>
        Custom probing bounds if needed
        </Documentation>
      </DoubleVectorProperty>

      <!-- End Probe -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkStreamTracer"
                 label="Stream Tracer"
                 name="StreamTracer">
      <Documentation long_help="Integrate streamlines in a vector field."
                     short_help="Integrate streamlines in a vector field.">The
                     Stream Tracer filter generates streamlines in a vector
                     field from a collection of seed points. Production of
                     streamlines terminates if a streamline crosses the
                     exterior boundary of the input dataset
                     (ReasonForTermination=1). Other reasons for termination
                     include an initialization issue (ReasonForTermination=2),
                     computing an unexpected value (ReasonForTermination=3),
                     reached the Maximum Streamline Length input value
                     (ReasonForTermination=4), reached the Maximum Steps
                     input value (ReasonForTermination=5), and velocity was
                     lower than the Terminal Speed input value
                     (ReasonForTermination=6). This filter operates on any
                     type of dataset, provided it has point-centered vectors.
                     The output is polygonal data containing polylines.
      </Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array"
                          number_of_components="3" />
        <Documentation>This property specifies the input to the Stream Tracer
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property contains the name of the vector array from
        which to generate streamlines.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetInterpolatorType"
                         default_values="0"
                         name="InterpolatorType"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <EnumerationDomain name="enum">
          <Entry text="Interpolator with Point Locator"
                 value="0" />
          <Entry text="Interpolator with Cell Locator"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This property determines which interpolator to use for
        evaluating the velocity vector field. The first is faster though the
        second is more robust in locating cells during streamline
        integration.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetSurfaceStreamlines"
                         default_values="0"
                         name="Surface Streamlines"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute surface
        streamlines.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegrationDirection"
                         default_values="2"
                         name="IntegrationDirection"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="FORWARD"
                 value="0" />
          <Entry text="BACKWARD"
                 value="1" />
          <Entry text="BOTH"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines in which direction(s) a
        streamline is generated.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegratorType"
                         default_values="2"
                         name="IntegratorType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Runge-Kutta 2"
                 value="0" />
          <Entry text="Runge-Kutta 4"
                 value="1" />
          <Entry text="Runge-Kutta 4-5"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines which integrator (with
        increasing accuracy) to use for creating streamlines.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegrationStepUnit"
                         default_values="2"
                         label="Integration Step Unit"
                         name="IntegrationStepUnit"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Length"
                 value="1" />
          <Entry text="Cell Length"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property specifies the unit for
        Minimum/Initial/Maximum integration step size. The Length unit refers
        to the arc length that a particle travels/advects within a single step.
        The Cell Length unit represents the step size as a number of
        cells.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetInitialIntegrationStep"
                            default_values="0.2"
                            label="Initial Step Length"
                            name="InitialIntegrationStep"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the initial integration step
        size. For non-adaptive integrators (Runge-Kutta 2 and Runge-Kutta 4),
        it is fixed (always equal to this initial value) throughout the
        integration. For an adaptive integrator (Runge-Kutta 4-5), the actual
        step size varies such that the numerical error is less than a specified
        threshold.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMinimumIntegrationStep"
                            default_values="0.01"
                            label="Minimum Step Length"
                            name="MinimumIntegrationStep"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>When using the Runge-Kutta 4-5 integrator, this property
        specifies the minimum integration step size.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMaximumIntegrationStep"
                            default_values="0.5"
                            label="Maximum Step Length"
                            name="MaximumIntegrationStep"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>When using the Runge-Kutta 4-5 integrator, this property
        specifies the maximum integration step size.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSteps"
                         default_values="2000"
                         label="Maximum Steps"
                         name="MaximumNumberOfSteps"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <IntRangeDomain name="range" />
        <Documentation>This property specifies the maximum number of steps,
        beyond which streamline integration is terminated.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetMaximumPropagation"
                            default_values="1.0"
                            label="Maximum Streamline Length"
                            name="MaximumPropagation"
                            number_of_elements="1">
        <BoundsDomain default_mode="max"
                      mode="scaled_extent"
                      name="bounds"
                      scale_factor="1.0">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>This property specifies the maximum streamline length
        (i.e., physical arc length), beyond which line integration is
        terminated.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetTerminalSpeed"
                            default_values="0.000000000001"
                            label="Terminal Speed"
                            name="TerminalSpeed"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the terminal speed, below which
        particle advection/integration is terminated.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMaximumError"
                            default_values="0.000001"
                            name="MaximumError"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the maximum error (for
        Runge-Kutta 4-5) tolerated throughout streamline integration. The
        Runge-Kutta 4-5 integrator tries to adjust the step size such that the
        estimated error is less than this threshold.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetComputeVorticity"
                         default_values="1"
                         name="ComputeVorticity"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute
        vorticity.</Documentation>
      </IntVectorProperty>

      <InputProperty command="SetSourceConnection"
                     label="Seed Type"
                     name="Source"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Group name="seed_sources"/>
        </ProxyListDomain>
        <Documentation>The value of this property determines how the seeds for
        the streamlines will be generated.</Documentation>
      </InputProperty>

      <PropertyGroup label="Seeds">
        <Property name="Source" />
      </PropertyGroup>

      <PropertyGroup label="Integration Parameters">
        <Property name="IntegrationDirection" />
        <Property name="IntegratorType" />
        <Property name="IntegrationStepUnit" />
        <Property name="InitialIntegrationStep" />
        <Property name="MinimumIntegrationStep" />
        <Property name="MaximumIntegrationStep" />
        <Property name="MaximumError" />
      </PropertyGroup>

      <PropertyGroup label="Streamline Parameters" >
        <Property name="MaximumNumberOfSteps" />
        <Property name="MaximumPropagation" />
        <Property name="TerminalSpeed" />
      </PropertyGroup>

      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End StreamTracer -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkEvenlySpacedStreamlines2D"
                 label="Evenly Spaced Streamlines 2D"
                 name="EvenlySpacedStreamlines2D">
      <Documentation long_help="Produce evenly spaced streamlines in a 2D vector field."
                     short_help="Produce evenly spaced streamlines in a 2D vector field.">
                     This filter generates evenly spaced streamlines in a 2D
                     vector field from a start position. Production of
                     streamlines terminates if a streamline crosses the
                     exterior boundary of the input dataset
                     (ReasonForTermination=1), an initialization issue (ReasonForTermination=2),
                     computing an unexpected value (ReasonForTermination=3),
                     reached the Maximum Streamline Length input value
                     (ReasonForTermination=4), reached the Maximum Steps
                     input value (ReasonForTermination=5), velocity was
                     lower than the Terminal Speed input value
                     (ReasonForTermination=6), a streamline formed a loop
                     (ReasonForTermination=7), and the streamline was too close to
                     other streamlines (ReasonForTermination=8). This filter
                     operates on a 2D dataset aligned with plane XY with
                     point-centered vectors aligned with plane XY.
                     The output is polygonal data containing polylines.
      </Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array"
                          number_of_components="3" />
        <Documentation>This property specifies the input to the filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property contains the name of the vector array from
        which to generate streamlines.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetInterpolatorType"
                         default_values="0"
                         name="InterpolatorType"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <EnumerationDomain name="enum">
          <Entry text="Interpolator with Point Locator"
                 value="0" />
          <Entry text="Interpolator with Cell Locator"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This property determines which interpolator to use for
        evaluating the velocity vector field. The first is faster though the
        second is more robust in locating cells during streamline
        integration.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegratorType"
                         default_values="1"
                         name="IntegratorType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Runge-Kutta 2"
                 value="0" />
          <Entry text="Runge-Kutta 4"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This property determines which integrator (with
        increasing accuracy) to use for creating streamlines.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegrationStepUnit"
                         default_values="2"
                         label="Integration Step Unit"
                         name="IntegrationStepUnit"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Length"
                 value="1" />
          <Entry text="Cell Length"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property specifies the unit for
        Initial integration step size. The Length unit refers
        to the arc length that a particle travels/advects within a single step.
        The Cell Length unit represents the step size as a number of
        cells.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetInitialIntegrationStep"
                            default_values="0.2"
                            label="Initial Step Length"
                            name="InitialIntegrationStep"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the initial integration step
        size. For non-adaptive integrators (Runge-Kutta 2 and Runge-Kutta 4),
        it is fixed (always equal to this initial value) throughout the
        integration.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSteps"
                         default_values="2000"
                         label="Maximum Steps"
                         name="MaximumNumberOfSteps"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <IntRangeDomain name="range" />
        <Documentation>This property specifies the maximum number of steps,
        beyond which streamline integration is terminated.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetSeparatingDistance"
                            default_values="2"
                            label="Separating Distance"
                            name="SeparatingDistance"
                            number_of_elements="1"
                            panel_visibility="default" >
        <DoubleRangeDomain name="range" />
        <Documentation>Specify the separating distance between
        streamlines expressed in IntegrationStepUnit.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetSeparatingDistanceRatio"
                            default_values="0.4"
                            label="Separating Distance Ratio"
                            name="SeparatingDistanceRatio"
                            number_of_elements="1"
                            panel_visibility="default" >
        <DoubleRangeDomain name="range" />
        <Documentation>Specifies SeparatingDistanceRatio. If streamlines
        get closer than SeparatingDistance * SeparatingDistanceRatio to
        other streamlines integration stops.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetClosedLoopMaximumDistance"
                            default_values="0.2"
                            label="Closed Loop Maximum Distance"
                            name="ClosedLoopMaximumDistance"
                            number_of_elements="1"
                            panel_visibility="default" >
        <DoubleRangeDomain name="range" />
        <Documentation>Loops are considered closed if the have two points at
        distance less than this. This is expressed in IntegrationStepUnit.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetStartPosition"
                            default_values="0 0 0 "
                            label="Start Position"
                            name="StartPosition"
                            number_of_elements="3"
                            panel_visibility="default" >
        <BoundsDomain default_mode="mid" mode="normal" name="range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>Specify the starting point (seed) of the first streamline
        in the global coordinate system.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetTerminalSpeed"
                            default_values="0.000000000001"
                            label="Terminal Speed"
                            name="TerminalSpeed"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the terminal speed, below which
        particle advection/integration is terminated.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetComputeVorticity"
                         default_values="1"
                         name="ComputeVorticity"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute
        vorticity.</Documentation>
      </IntVectorProperty>

      <PropertyGroup label="Streamline Parameters">
        <Property name="StartPosition" />
        <Property name="SeparatingDistance" />
        <Property name="SeparatingDistanceRatio" />
        <Property name="ClosedLoopMaximumDistance" />
        <Property name="IntegratorType" />
        <Property name="IntegrationStepUnit" />
        <Property name="InitialIntegrationStep" />
        <Property name="MaximumNumberOfSteps" />
        <Property name="TerminalSpeed" />
      </PropertyGroup>

      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End EvenlySpacedStreamlines2D -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkStreamTracer"
                 label="Stream Tracer With Custom Source"
                 name="ArbitrarySourceStreamTracer">
      <Documentation long_help="Integrate streamlines in a vector field."
                     short_help="Integrate streamlines in a vector field.">The
                     Stream Tracer With Custom Source filter generates streamlines
                     in a vector field from a collection of seed points. Production
                     of streamlines terminates if a streamline crosses the
                     exterior boundary of the input dataset
                     (ReasonForTermination=1). Other reasons for termination
                     include an initialization issue (ReasonForTermination=2),
                     computing an unexpected value (ReasonForTermination=3),
                     reached the Maximum Streamline Length input value
                     (ReasonForTermination=4), reached the Maximum Steps
                     input value (ReasonForTermination=5), and velocity was
                     lower than the Terminal Speed input value
                     (ReasonForTermination=6). This filter operates on any
                     type of dataset, provided it has point-centered vectors.
                     The output is polygonal data containing polylines.
                     This filter takes a Source input
                     that provides the seed points.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>This property specifies the input to the Stream Tracer
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property contains the name of the vector array from
        which to generate streamlines.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetInterpolatorType"
                         default_values="0"
                         name="InterpolatorType"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <EnumerationDomain name="enum">
          <Entry text="Interpolator with Point Locator"
                 value="0" />
          <Entry text="Interpolator with Cell Locator"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This property determines which interpolator to use for
        evaluating the velocity vector field. The first is faster though the
        second is more robust in locating cells during streamline
        integration.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetSurfaceStreamlines"
                         default_values="0"
                         name="Surface Streamlines"
                         number_of_elements="1"
                         panel_visibility="advanced" >
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute surface
        streamlines.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegrationDirection"
                         default_values="2"
                         name="IntegrationDirection"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="FORWARD"
                 value="0" />
          <Entry text="BACKWARD"
                 value="1" />
          <Entry text="BOTH"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines in which direction(s) a
        streamline is generated.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegratorType"
                         default_values="2"
                         name="IntegratorType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Runge-Kutta 2"
                 value="0" />
          <Entry text="Runge-Kutta 4"
                 value="1" />
          <Entry text="Runge-Kutta 4-5"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines which integrator (with
        increasing accuracy) to use for creating streamlines.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegrationStepUnit"
                         default_values="2"
                         label="Integration Step Unit"
                         name="IntegrationStepUnit"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Length"
                 value="1" />
          <Entry text="Cell Length"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property specifies the unit for
        Minimum/Initial/Maximum integration step size. The Length unit refers
        to the arc length that a particle travels/advects within a single step.
        The Cell Length unit represents the step size as a number of
        cells.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetInitialIntegrationStep"
                            default_values="0.2"
                            label="Initial Step Length"
                            name="InitialIntegrationStep"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the initial integration step
        size. For non-adaptive integrators (Runge-Kutta 2 and Runge-Kutta 4),
        it is fixed (always equal to this initial value) throughout the
        integration. For an adaptive integrator (Runge-Kutta 4-5), the actual
        step size varies such that the numerical error is less than a specified
        threshold.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMinimumIntegrationStep"
                            default_values="0.01"
                            label="Minimum Step Length"
                            name="MinimumIntegrationStep"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>When using the Runge-Kutta 4-5 integrator, this property
        specifies the minimum integration step size.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMaximumIntegrationStep"
                            default_values="0.5"
                            label="Maximum Step Length"
                            name="MaximumIntegrationStep"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>When using the Runge-Kutta 4-5 integrator, this property
        specifies the maximum integration step size.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSteps"
                         default_values="2000"
                         label="Maximum Steps"
                         name="MaximumNumberOfSteps"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <IntRangeDomain name="range" />
        <Documentation>This property specifies the maximum number of steps,
        beyond which streamline integration is terminated.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetMaximumPropagation"
                            default_values="1.0"
                            label="Maximum Streamline Length"
                            name="MaximumPropagation"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <BoundsDomain mode="scaled_extent"
                      name="bounds"
                      scale_factor="1.0">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>This property specifies the maximum streamline length
        (i.e., physical arc length), beyond which line integration is
        terminated.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetTerminalSpeed"
                            default_values="0.000000000001"
                            label="Terminal Speed"
                            name="TerminalSpeed"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the terminal speed, below which
        particle advection/integration is terminated.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMaximumError"
                            default_values="0.000001"
                            name="MaximumError"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the maximum error (for
        Runge-Kutta 4-5) tolerated throughout streamline integration. The
        Runge-Kutta 4-5 integrator tries to adjust the step size such that the
        estimated error is less than this threshold.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetComputeVorticity"
                         default_values="1"
                         name="ComputeVorticity"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not to compute
        vorticity.</Documentation>
      </IntVectorProperty>
      <InputProperty command="SetSourceConnection"
                     label="Seed Source"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the input used to obtain the
        seed points.</Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End StreamTracer -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTemporalDataSetCache"
                 label="Temporal Cache"
                 name="TemporalCache">
      <Documentation long_help="Saves a copy of the data set for a fixed number of time steps."
                     short_help="Caches data per time step.">The Temporal Cache
                     can be used to save multiple copies of a data set at
                     different time steps to prevent thrashing in the pipeline
                     caused by downstream filters that adjust the requested
                     time step. For example, assume that there is a downstream
                     Temporal Interpolator filter. This filter will (usually)
                     request two time steps from the upstream filters, which in
                     turn (usually) causes the upstream filters to run twice,
                     once for each time step. The next time the interpolator
                     requests the same two time steps, they might force the
                     upstream filters to re-evaluate the same two time steps.
                     The Temporal Cache can keep copies of both of these time
                     steps and provide the requested data without having to run
                     upstream filters.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the Temporal Cache
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetCacheSize"
                         default_values="2"
                         name="CacheSize"
                         number_of_elements="1">
        <IntRangeDomain max="10"
                        min="2"
                        name="range" />
        <Documentation>The cache size determines the number of time steps that
        can be cached at one time. The maximum number is 10. The minimum is 2
        (since it makes little sense to cache less than that).</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <!-- End TemporalCache -->
    </SourceProxy>
    <SourceProxy class="vtkTemporalInterpolator"
                 label="Temporal Interpolator"
                 name="TemporalInterpolator">
      <Documentation long_help="Interpolate between time steps."
                     short_help="Interpolate between time steps.">The Temporal
                     Interpolator converts data that is defined at discrete
                     time steps to one that is defined over a continuum of time
                     by linearly interpolating the data's field data between
                     two adjacent time steps. The interpolated values are a
                     simple approximation and should not be interpreted as
                     anything more. The Temporal Interpolator assumes that the
                     topology between adjacent time steps does not
                     change.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the Temporal
        Interpolator.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetDiscreteTimeStepInterval"
                            default_values="0.0"
                            name="DiscreteTimeStepInterval"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>If Discrete Time Step Interval is set to 0, then the
        Temporal Interpolator will provide a continuous region of time on its
        output. If set to anything else, then the output will define a finite
        set of time points on its output, each spaced by the Discrete Time Step
        Interval. The output will have (time range)/(discrete time step
        interval) time steps. (Note that the time range is defined by the time
        range of the data of the input filter, which may be different from
        other pipeline objects or the range defined in the animation
        inspector.) This is a useful option to use if you have a dataset with
        one missing time step and wish to 'fill in' the missing data with an
        interpolated value from the steps on either side.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimeRange">
        <TimeRangeInformationHelper />
      </DoubleVectorProperty>
      <!-- End TemporalInterpolator -->
    </SourceProxy>
    <SourceProxy class="vtkTemporalSnapToTimeStep"
                 label="Temporal Snap-to-Time-Step"
                 name="TemporalSnapToTimeStep">
      <Documentation long_help="Modifies the time range/steps of temporal data."
                     short_help="Modifies the time range/steps of temporal data.">
                     This file modifies the time range or time steps of the
                     data without changing the data itself. The data is not
                     resampled by this filter, only the information
                     accompanying the data is modified.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetSnapMode"
                         default_values="0"
                         name="SnapMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Nearest"
                 value="0" />
          <Entry text="NextBelowOrEqual"
                 value="1" />
          <Entry text="NextAboveOrEqual"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Determine which time step to snap to.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <!-- End TemporalSnapToTimeStep -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTemporalShiftScale"
                 label="Temporal Shift Scale"
                 name="TemporalShiftScale">
      <Documentation long_help="Shift and scale time values."
                     short_help="Shift and scale time values.">The Temporal
                     Shift Scale filter linearly transforms the time values of
                     a pipeline object by applying a shift and then scale.
                     Given a data at time t on the input, it will be
                     transformed to time t*Shift + Scale on the output.
                     Inversely, if this filter has a request for time t, it
                     will request time (t-Shift)/Scale on its
                     input.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>The input to the Temporal Shift Scale
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetPreShift"
                            default_values="0.0"
                            name="PreShift"
                            number_of_elements="1"
                            panel_visibility="default">
        <DoubleRangeDomain name="range" />
        <Documentation>Apply a translation to the data before scaling. To
        convert T{5,100} to T{0,1} use Preshift=-5, Scale=1/95, PostShift=0 To
        convert T{5,105} to T{5,10} use Preshift=-5, Scale=5/100,
        PostShift=5</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetPostShift"
                            default_values="0.0"
                            name="PostShift"
                            number_of_elements="1"
                            panel_visibility="default">
        <DoubleRangeDomain name="range" />
        <Documentation>The amount of time the input is shifted.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetScale"
                            default_values="1.0"
                            name="Scale"
                            number_of_elements="1"
                            panel_visibility="default">
        <DoubleRangeDomain name="range" />
        <Documentation>The factor by which the input time is
        scaled.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetPeriodic"
                         default_values="0"
                         name="Periodic"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If Periodic is true, requests for time will be wrapped
        around so that the source appears to be a periodic time source. If data
        exists for times {0,N-1}, setting periodic to true will cause time 0 to
        be produced when time N, 2N, 2N etc is requested. This effectively
        gives the source the ability to generate time data indefinitely in a
        loop. When combined with Shift/Scale, the time becomes periodic in the
        shifted and scaled time frame of reference. Note: Since the input time
        may not start at zero, the wrapping of time from the end of one period
        to the start of the next, will subtract the initial time - a source
        with T{5..6} repeated periodically will have output time {5..6..7..8}
        etc.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPeriodicEndCorrection"
                         default_values="1"
                         name="PeriodicEndCorrection"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If Periodic time is enabled, this flag determines if the
        last time step is the same as the first. If PeriodicEndCorrection is
        true, then it is assumed that the input data goes from 0-1 (or whatever
        scaled/shifted actual time) and time 1 is the same as time 0 so that
        steps will be 0,1,2,3...N,1,2,3...N,1,2,3 where step N is the same as 0
        and step 0 is not repeated. When this flag is false the data is assumed
        to be literal and output is of the form 0,1,2,3...N,0,1,2,3... By
        default this flag is ON</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetMaximumNumberOfPeriods"
                            default_values="1.0"
                            name="MaximumNumberOfPeriods"
                            number_of_elements="1">
        <DoubleRangeDomain max="100"
                           min="0"
                           name="range" />
        <Documentation>If Periodic time is enabled, this controls how many time
        periods time is reported for. A filter cannot output an infinite number
        of time steps and therefore a finite number of periods is generated
        when reporting time.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <!-- End TemporalShiftScale -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTemporalStatistics"
                 label="Temporal Statistics"
                 name="TemporalStatistics">
      <Documentation long_help="Loads in all time steps of a data set and computes some statistics about how each point and cell variable changes over time."
                     short_help="Compute Temporal Statistics">Given an input
                     that changes over time, vtkTemporalStatistics looks at the
                     data for each time step and computes some statistical
                     information of how a point or cell variable changes over
                     time. For example, vtkTemporalStatistics can compute the
                     average value of "pressure" over time of each point. Note
                     that this filter will require the upstream filter to be
                     run on every time step that it reports that it can
                     compute. This may be a time consuming operation.
                     vtkTemporalStatistics ignores the temporal spacing. Each
                     timestep will be weighted the same regardless of how long
                     of an interval it is to the next timestep. Thus, the
                     average statistic may be quite different from an
                     integration of the variable if the time spacing
                     varies.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Temporal Statistics
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetComputeAverage"
                         default_values="1"
                         name="ComputeAverage"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute the average of each point and cell variable over
        time.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetComputeMinimum"
                         default_values="1"
                         name="ComputeMinimum"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute the minimum of each point and cell variable over
        time.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetComputeMaximum"
                         default_values="1"
                         name="ComputeMaximum"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute the maximum of each point and cell variable over
        time.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetComputeStandardDeviation"
                         default_values="1"
                         name="ComputeStandardDeviation"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute the standard deviation of each point and cell
        variable over time.</Documentation>
      </IntVectorProperty>
      <Hints>
        <WarnOnCreate title="Potentially slow operation">
          **Temporal Statistics** filter needs to process all timesteps
          available in your dataset and can potentially take a long time to complete.
          Do you want to continue?
        </WarnOnCreate>
      </Hints>

      <!-- End TemporalStatistics -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkParticleTracer"
                 name="ParticleTracer">
      <Documentation long_help="Trace Particles through time in a vector field."
                     short_help="Trace Particles through time in a vector field.">
                     The Particle Trace filter generates pathlines in a vector
                     field from a collection of seed points. The vector field
                     used is selected from the Vectors menu, so the input data
                     set is required to have point-centered vectors. The Seed
                     portion of the interface allows you to select whether the
                     seed points for this integration lie in a point cloud or
                     along a line. Depending on which is selected, the
                     appropriate 3D widget (point or line widget) is displayed
                     along with traditional user interface controls for
                     positioning the point cloud or line within the data set.
                     Instructions for using the 3D widgets and the
                     corresponding manual controls can be found in section 7.4.
                     This filter operates on any type of data set, provided it
                     has point-centered vectors. The output is polygonal data
                     containing polylines. This filter is available on the
                     Toolbar.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>Specify which is the Input of the StreamTracer
        filter.</Documentation>
      </InputProperty>
      <InputProperty clean_command="RemoveAllSources"
                     command="AddSourceConnection"
                     label="Seed Source"
                     multiple_input="1"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Specify the seed dataset. Typically from where the
        vector field integration should begin. Usually a point/radius or a line
        with a given resolution.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetStaticSeeds"
                         default_values="0"
                         name="StaticSeeds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the input seeds are not changing, then this
        can be set to 1 to avoid having to do a repeated grid search
        that would return the exact same result.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetStaticMesh"
                         default_values="0"
                         name="StaticMesh"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the input grid is not changing, then this
        can be set to 1 to avoid having to create cell locators for
        each update.
        </Documentation>
      </IntVectorProperty>
      <!--
     <DoubleVectorProperty
        name="TimeStepResolution"
        command="SetTimeStepResolution"
        number_of_elements="1"
        default_values="1.0" >
       <DoubleRangeDomain name="range"/>
     </DoubleVectorProperty>
-->
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <!-- <IntVectorProperty -->
      <!--       name="StaticSeeds" -->
      <!--       command="SetStaticSeeds" -->
      <!--       number_of_elements="1" -->
      <!--       default_values="1" > -->
      <!--   <BooleanDomain name="bool"/> -->
      <!--   <Documentation> -->
      <!--        Force the use of static seed optimizations -->
      <!--  </Documentation> -->
      <!-- </IntVectorProperty> -->
      <!-- <IntVectorProperty -->
      <!--       name="StaticMesh" -->
      <!--       command="SetStaticMesh" -->
      <!--       number_of_elements="1" -->
      <!--       default_values="0" > -->
      <!--   <BooleanDomain name="bool"/> -->
      <!--   <Documentation> -->
      <!--        Force the use of static mesh optimizations -->
      <!--   </Documentation> -->
      <!-- </IntVectorProperty> -->
      <!-- <DoubleVectorProperty -->
      <!--      name="InitialIntegrationStep" -->
      <!--      command="SetInitialIntegrationStep" -->
      <!--      number_of_elements="1" -->
      <!--      default_values="0.25" > -->
      <!--      <DoubleRangeDomain name="range"/> -->
      <!--      <Documentation> -->
      <!--        Specify the Initial step size used for line integration, expressed in: -->
      <!--        LENGTH_UNIT      = 1 -->
      <!--        CELL_LENGTH_UNIT = 2 -->
      <!--        (either the starting size for an adaptive integrator, e.g., RK45, -->
      <!--        or the constant / fixed size for non-adaptive ones, i.e., RK2 and RK4) -->
      <!--      </Documentation> -->
      <!-- </DoubleVectorProperty> -->
      <IntVectorProperty command="SetForceReinjectionEveryNSteps"
                         default_values="0"
                         name="ForceReinjectionEveryNSteps"
                         number_of_elements="1">
        <IntRangeDomain name="range" />
        <Documentation>When animating particles, it is nice to inject new ones
        every Nth step to produce a continuous flow. Setting
        ForceReinjectionEveryNSteps to a non zero value will cause the particle
        source to reinject particles every Nth step even if it is otherwise
        unchanged. Note that if the particle source is also animated, this flag
        will be redundant as the particles will be reinjected whenever the
        source changes anyway</Documentation>
      </IntVectorProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputVectors"
                            number_of_elements="5"
                            panel_visibility="default">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Specify which vector array should be used for the
        integration through that filter.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeVorticity"
                         default_values="1"
                         name="ComputeVorticity"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute vorticity and angular rotation of particles as
        they progress</Documentation>
      </IntVectorProperty>
      <!-- End ParticleTracer -->
    </SourceProxy>
    <SourceProxy class="vtkParticlePathFilter"
                 name="ParticlePath">
      <Documentation long_help="Trace Particle Paths through time in a vector field."
                     short_help="Trace Particle Paths through time in a vector field.">
                     The Particle Trace filter generates pathlines in a vector
                     field from a collection of seed points. The vector field
                     used is selected from the Vectors menu, so the input data
                     set is required to have point-centered vectors. The Seed
                     portion of the interface allows you to select whether the
                     seed points for this integration lie in a point cloud or
                     along a line. Depending on which is selected, the
                     appropriate 3D widget (point or line widget) is displayed
                     along with traditional user interface controls for
                     positioning the point cloud or line within the data set.
                     Instructions for using the 3D widgets and the
                     corresponding manual controls can be found in section 7.4.
                     This filter operates on any type of data set, provided it
                     has point-centered vectors. The output is polygonal data
                     containing polylines. This filter is available on the
                     Toolbar.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>Specify which is the Input of the StreamTracer
        filter.</Documentation>
      </InputProperty>
      <InputProperty clean_command="RemoveAllSources"
                     command="AddSourceConnection"
                     label="Seed Source"
                     multiple_input="1"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Specify the seed dataset. Typically from where the
        vector field integration should begin. Usually a point/radius or a line
        with a given resolution.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetTerminationTime"
                            default_values="0.0"
                            name="TerminationTime"
                            number_of_elements="1"
                            panel_visibility="default">
        <DoubleRangeDomain name="range" />
        <Documentation>Setting TerminationTime to a positive value will cause
        particles to terminate when the time is reached. The units of time
        should be consistent with the primary time variable.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <IntVectorProperty command="SetForceReinjectionEveryNSteps"
                         default_values="0"
                         name="ForceReinjectionEveryNSteps"
                         number_of_elements="1">
        <IntRangeDomain name="range" />
        <Documentation>When animating particles, it is nice to inject new ones
        every Nth step to produce a continuous flow. Setting
        ForceReinjectionEveryNSteps to a non zero value will cause the particle
        source to reinject particles every Nth step even if it is otherwise
        unchanged. Note that if the particle source is also animated, this flag
        will be redundant as the particles will be reinjected whenever the
        source changes anyway</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetStaticSeeds"
                         default_values="0"
                         name="StaticSeeds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the input seeds are not changing, then this
        can be set to 1 to avoid having to do a repeated grid search
        that would return the exact same result.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetStaticMesh"
                         default_values="0"
                         name="StaticMesh"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the input grid is not changing, then this
        can be set to 1 to avoid having to create cell locators for
        each update.
        </Documentation>
      </IntVectorProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputVectors"
                            number_of_elements="5"
                            panel_visibility="default">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Specify which vector array should be used for the
        integration through that filter.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeVorticity"
                         default_values="1"
                         name="ComputeVorticity"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute vorticity and angular rotation of particles as
        they progress</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetTerminalSpeed"
                            default_values="0.000000000001"
                            label="Terminal Speed"
                            name="TerminalSpeed"
                            number_of_elements="1"
                            panel_visibility="advanced" >
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the terminal speed, below which
        particle advection/integration is terminated.</Documentation>
      </DoubleVectorProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkStreaklineFilter"
                 name="StreakLine">
      <Documentation long_help="Trace Streak lines through time in a vector field."
                     short_help="Trace Streak lines through time in a vector field.">
                     The Particle Trace filter generates pathlines in a vector
                     field from a collection of seed points. The vector field
                     used is selected from the Vectors menu, so the input data
                     set is required to have point-centered vectors. The Seed
                     portion of the interface allows you to select whether the
                     seed points for this integration lie in a point cloud or
                     along a line. Depending on which is selected, the
                     appropriate 3D widget (point or line widget) is displayed
                     along with traditional user interface controls for
                     positioning the point cloud or line within the data set.
                     Instructions for using the 3D widgets and the
                     corresponding manual controls can be found in section 7.4.
                     This filter operates on any type of data set, provided it
                     has point-centered vectors. The output is polygonal data
                     containing polylines. This filter is available on the
                     Toolbar.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>Specify which is the Input of the StreamTracer
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetStaticSeeds"
                         default_values="0"
                         name="StaticSeeds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the input seeds are not changing, then this
        can be set to 1 to avoid having to do a repeated grid search
        that would return the exact same result.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetStaticMesh"
                         default_values="0"
                         name="StaticMesh"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If the input grid is not changing, then this
        can be set to 1 to avoid having to create cell locators for
        each update.
        </Documentation>
      </IntVectorProperty>
      <InputProperty clean_command="RemoveAllSources"
                     command="AddSourceConnection"
                     label="Seed Source"
                     multiple_input="1"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Specify the seed dataset. Typically from where the
        vector field integration should begin. Usually a point/radius or a line
        with a given resolution.</Documentation>
      </InputProperty>
      <DoubleVectorProperty command="SetTerminationTime"
                            default_values="0.0"
                            name="TerminationTime"
                            number_of_elements="1"
                            panel_visibility="default">
        <DoubleRangeDomain name="range" />
        <Documentation>Setting TerminationTime to a positive value will cause
        particles to terminate when the time is reached. The units of time
        should be consistent with the primary time variable.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <IntVectorProperty command="SetForceReinjectionEveryNSteps"
                         default_values="1"
                         name="ForceReinjectionEveryNSteps"
                         number_of_elements="1">
        <IntRangeDomain name="range" />
        <Documentation>When animating particles, it is nice to inject new ones
        every Nth step to produce a continuous flow. Setting
        ForceReinjectionEveryNSteps to a non zero value will cause the particle
        source to reinject particles every Nth step even if it is otherwise
        unchanged. Note that if the particle source is also animated, this flag
        will be redundant as the particles will be reinjected whenever the
        source changes anyway</Documentation>
      </IntVectorProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputVectors"
                            number_of_elements="5"
                            panel_visibility="default">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Specify which vector array should be used for the
        integration through that filter.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetComputeVorticity"
                         default_values="1"
                         name="ComputeVorticity"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute vorticity and angular rotation of particles as
        they progress</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetDisableResetCache"
                         default_values="0"
                         name="DisableResetCache"
                         number_of_elements="1"
                         panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>Prevents cache from getting reset so that new computation
          always start from previous results.</Documentation>
      </IntVectorProperty>
    </SourceProxy>
    <!-- ==================================================================== -->

    <!-- Legacy filter (renamed from "Particle Pathlines" to handle temporal
         particle data. We should consider writing a generic "sweep" filter
         that handles temporal particles, lines and surfaces.
     - Leo 12/30/2012  -->

    <SourceProxy name="ParticlePathLines"
        class="vtkTemporalPathLineFilter"
        label="Temporal Particles To Pathlines">
      <Documentation
        long_help="Creates polylines representing pathlines of animating particles"
        short_help="Particle Pathlines">
        Particle Pathlines takes any dataset as input, it extracts the
        point locations of all cells over time to build up a polyline
        trail.  The point number (index) is used as the 'key' if the points
        are randomly changing their respective order in the points list,
        then you should specify a scalar that represents the unique
        ID. This is intended to handle the output of a filter such as the
        TemporalStreamTracer.
      </Documentation>

      <OutputPort name="Pathlines" index="0" />
      <OutputPort name="Particles" index="1" />

      <InputProperty name="Input" command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet"/>
        </DataTypeDomain>
        <InputArrayDomain name="input_array" attribute_type="point"
              optional="1"/>
        <Documentation>
          The input cells to create pathlines for.
        </Documentation>
      </InputProperty>

      <InputProperty name="Selection" command="SetSelectionConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
        <Hints>
          <Optional />
        </Hints>
        <Documentation>
          Set a second input, which is a selection. Particles with the same
          Id in the selection as the primary input will be chosen for
          pathlines Note that you must have the same IdChannelArray in the
          selection as the input
        </Documentation>
      </InputProperty>

      <IntVectorProperty name="MaskPoints"
                         command="SetMaskPoints"
                         number_of_elements="1"
                         default_values="100" >
        <Documentation>
          Set the number of particles to track as a ratio of the input.
          Example: setting MaskPoints to 10 will track every 10th point.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="MaxTrackLength"
                         command="SetMaxTrackLength"
                         number_of_elements="1"
                         default_values="25" >
        <Documentation>
          If the Particles being traced animate for a long time, the trails
          or traces will become long and stringy. Setting the
          MaxTraceTimeLength will limit how much of the trace is
          displayed. Tracks longer then the Max will disappear and the
          trace will appear like a snake of fixed length which progresses
          as the particle moves.  This length is given with respect to
          timesteps.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="MaxStepDistance"
                            command="SetMaxStepDistance"
                            number_of_elements="3"
                            animateable="1"
                            default_values="1.0 1.0 1.0" >
          <DoubleRangeDomain name="range"/>
          <Documentation>
            If a particle disappears from one end of a simulation and
            reappears on the other side, the track left will be
            unrepresentative.  Set a MaxStepDistance{x,y,z} which acts as a
            threshold above which if a step occurs larger than the value (for
            the dimension), the track will be dropped and restarted after the
            step. (ie the part before the wrap around will be dropped and the
            newer part kept).
          </Documentation>
      </DoubleVectorProperty>

      <StringVectorProperty name="IdChannelArray"
                            command="SetIdChannelArray"
                            number_of_elements="1"
                            default_values="Global or Local IDs"
                            animateable="0">
            <ArrayListDomain
              name="array_list" attribute_type="Scalars"
              none_string="Global or Local IDs">
              <RequiredProperties>
                <Property name="Input" function="Input"/>
              </RequiredProperties>
            </ArrayListDomain>
          <Documentation>
            Specify the name of a scalar array which will be used to fetch
            the index of each point. This is necessary only if the particles
            change position (Id order) on each time step. The Id can be used
            to identify particles at each step and hence track them properly.
            If this array is set to "Global or Local IDs", the global point
            ids are used if they exist or the point index is otherwise.
          </Documentation>
      </StringVectorProperty>

   </SourceProxy>

   <!-- End TemporalPathLineFilter -->

   <!-- ==================================================================== -->

    <SourceProxy class="vtkStructuredGridOutlineFilter"
                 label="Outline Curvilinear DataSet"
                 name="StructuredGridOutlineFilter">
      <Documentation long_help="This filter generates an outline representation of the input."
                     short_help="Generates an outline.">The Outline filter
                     generates an outline of the outside edges of the input
                     dataset, rather than the dataset's bounding box. This
                     filter operates on structured grid datasets and produces
                     polygonal output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkStructuredGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the outline
        (curvilinear) filter.</Documentation>
      </InputProperty>
      <!-- End StructuredGridOutlineFilter -->
    </SourceProxy>
    <SourceProxy class="vtkGenericClip"
                 label="Clip Generic Dataset"
                 name="GenericClip">
      <Documentation long_help="Clip with an implicit plane, sphere or with scalars. Clipping does not reduce the dimensionality of the data set.  This output data type of this filter is always an unstructured grid."
                     short_help="Clip with an implicit plane, sphere or with scalars.">
                     The Generic Clip filter cuts away a portion of the input
                     data set using a plane, a sphere, a box, or a scalar
                     value. The menu in the Clip Function portion of the
                     interface allows the user to select which implicit
                     function to use or whether to clip using a scalar value.
                     Making this selection loads the appropriate user
                     interface. For the implicit functions, the appropriate 3D
                     widget (plane, sphere, or box) is also displayed. The use
                     of these 3D widgets, including their user interface
                     components, is discussed in section 7.4. If an implicit
                     function is selected, the clip filter returns that portion
                     of the input data set that lies inside the function. If
                     Scalars is selected, then the user must specify a scalar
                     array to clip according to. The clip filter will return
                     the portions of the data set whose value in the selected
                     Scalars array is larger than the Clip value. Regardless of
                     the selection from the Clip Function menu, if the Inside
                     Out option is checked, the opposite portions of the data
                     set will be returned. This filter operates on all types of
                     data sets, and it returns unstructured grid data on
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkGenericDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          optional="1" />
        <Documentation>Set the input to the Generic Clip
        filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetClipFunction"
                     label="Clip Type"
                     name="ClipFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
          <Proxy group="implicit_functions"
                 name="Scalar" />
        </ProxyListDomain>
        <Documentation>Set the parameters of the clip function.</Documentation>
      </ProxyProperty>
      <DoubleVectorProperty information_only="1"
                            name="InputBounds">
        <BoundsDomain name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>If clipping with scalars, this property specifies the
        name of the scalar array on which to perform the clip
        operation.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetInsideOut"
                         default_values="0"
                         name="InsideOut"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Choose which portion of the dataset should be clipped
        away.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetValue"
                            default_values="0.0"
                            name="Value"
                            number_of_elements="1">
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputScalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <DoubleRangeDomain name="range" />
        <Documentation>If clipping with a scalar array, choose the clipping
        value.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End GenericClip -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGenericContourFilter"
                 label="Contour Generic Dataset"
                 name="GenericContour">
      <Documentation long_help="Generate isolines or isosurfaces using point scalars."
                     short_help="Generate isolines or isosurfaces.">The Generic
                     Contour filter computes isolines or isosurfaces using a
                     selected point-centered scalar array. The available scalar
                     arrays are listed in the Scalars menu. The scalar range of
                     the selected array will be displayed. The interface for
                     adding contour values is very similar to the one for
                     selecting cut offsets (in the Cut filter). To add a single
                     contour value, select the value from the New Value slider
                     in the Add value portion of the interface and click the
                     Add button, or press Enter. To instead add several evenly
                     spaced contours, use the controls in the Generate range of
                     values section. Select the number of contour values to
                     generate using the Number of Values slider. The Range
                     slider controls the interval in which to generate the
                     contour values. Once the number of values and range have
                     been selected, click the Generate button. The new values
                     will be added to the Contour Values list. To delete a
                     value from the Contour Values list, select the value and
                     click the Delete button. (If no value is selected, the
                     last value in the list will be removed.) Clicking the
                     Delete All button removes all the values in the list. If
                     no values are in the Contour Values list when Accept is
                     pressed, the current value of the New Value slider will be
                     used. In addition to selecting contour values, you can
                     also select additional computations to perform. If any of
                     Compute Normals, Compute Gradients, or Compute Scalars is
                     selected, the appropriate computation will be performed,
                     and a corresponding point-centered array will be added to
                     the output. The Generic Contour filter operates on a
                     generic data set, but the input is required to have at
                     least one point-centered scalar (single-component) array.
                     The output of this filter is polygonal.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkGenericDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1"
                          optional="1" />
        <Documentation>Set the input to the Generic Contour
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Contour By"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies the name of the scalar array
        from which the contour filter will compute isolines and/or
        isosurfaces.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComputeNormals"
                         default_values="1"
                         name="ComputeNormals"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Hints>
          <PropertyWidgetDecorator type="InputDataTypeDecorator"
                                   name="vtkPolyData"
                                   mode="enabled_state"
                                   exclude="1" />
        </Hints>
        <Documentation>Select whether to compute normals.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComputeGradients"
                         default_values="0"
                         name="ComputeGradients"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Hints>
          <PropertyWidgetDecorator type="StructuredInputDecorator" />
        </Hints>
        <Documentation>Select whether to compute gradients.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComputeScalars"
                         default_values="0"
                         name="ComputeScalars"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Select whether to compute scalars.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetValue"
                            label="Isosurfaces"
                            name="ContourValues"
                            number_of_elements="0"
                            number_of_elements_per_command="1"
                            repeat_command="1"
                            set_number_command="SetNumberOfContours"
                            use_index="1">
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputScalars" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Documentation>This property specifies the values at which to compute
        isosurfaces/isolines and also the number of such
        values.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
      <!-- incremental point locator begin -->
      <ProxyProperty command="SetLocator"
                     label="Point Merge Method"
                     name="Locator">
        <ProxyGroupDomain name="groups">
          <Group name="incremental_point_locators" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="incremental_point_locators"
                 name="MergePoints" />
          <Proxy group="incremental_point_locators"
                 name="IncrementalOctreeMergePoints" />
          <Proxy group="incremental_point_locators"
                 name="NonMergingPointLocator" />
        </ProxyListDomain>
        <Documentation>This property specifies an incremental point locator for
        merging duplicate / coincident points.</Documentation>
      </ProxyProperty>
      <!-- incremental point locator end -->

      <PropertyGroup label="Isosurfaces">
        <Property name="ContourValues" />
      </PropertyGroup>
      <PropertyGroup label="Point Locator">
        <Property name="Locator" />
      </PropertyGroup>

      <!-- End GenericContour -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGenericCutter"
                 label="Slice Generic Dataset"
                 name="GenericCut">
      <Documentation long_help="This filter cuts a data set with a plane or sphere.  Cutting is similar to a contour.  It creates surfaces from volumes and lines from surfaces."
                     short_help="Cut datasets with planes or spheres.">The
                     Generic Cut filter extracts the portion of the input data
                     set that lies along the specified plane or sphere. From
                     the Cut Function menu, you can select whether cutting will
                     be performed with a plane or a sphere. The appropriate 3D
                     widget (plane widget or sphere widget) will be displayed.
                     The parameters of the cut function can be specified
                     interactively using the 3D widget or manually using the
                     traditional user interface controls. Instructions for
                     using these 3D widgets and their corresponding user
                     interfaces are found in section 7.4. By default, the cut
                     lies on the specified plane or sphere. Using the Cut
                     Offset Values portion of the interface, it is also
                     possible to cut the data set at some offset from the
                     original cut function. The Cut Offset Values are in the
                     spatial units of the data set. To add a single offset,
                     select the value from the New Value slider in the Add
                     value portion of the interface and click the Add button,
                     or press Enter. To instead add several evenly spaced
                     offsets, use the controls in the Generate range of values
                     section. Select the number of offsets to generate using
                     the Number of Values slider. The Range slider controls the
                     interval in which to generate the offsets. Once the number
                     of values and range have been selected, click the Generate
                     button. The new offsets will be added to the Offset Values
                     list. To delete a value from the Cut Offset Values list,
                     select the value and click the Delete button. (If no value
                     is selected, the last value in the list will be removed.)
                     Clicking the Delete All button removes all the values in
                     the list. The Generic Cut filter takes a generic dataset
                     as input. Use the Input menu to choose a data set to cut.
                     The output of this filter is polygonal
                     data.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkGenericDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Generic Cut filter.</Documentation>
      </InputProperty>
      <ProxyProperty command="SetCutFunction"
                     label="Cut Type"
                     name="CutFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
        </ProxyListDomain>
        <Documentation>Set the parameters to the implicit function used for
        cutting.</Documentation>
      </ProxyProperty>
      <DoubleVectorProperty information_only="1"
                            name="InputBounds">
        <BoundsDomain name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetValue"
                            label="Slice Offset Values"
                            name="ContourValues"
                            number_of_elements_per_command="1"
                            repeat_command="1"
                            set_number_command="SetNumberOfContours"
                            use_index="1"
                            panel_visibility="advanced">
        <BoundsDomain mode="magnitude"
                      name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>The values in this property specify a list of current
        offset values. This can be used to create multiple slices with
        different centers. Each entry represents a new slice with its center
        shifted by the offset value.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End GenericCut -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGenericGeometryFilter"
                 label="Extract Generic Dataset Surface"
                 name="GenericGeometryFilter">
      <Documentation long_help="Extract geometry from a higher-order dataset"
                     short_help="Extract geometry from a higher-order dataset">
                     Extract geometry from a higher-order
                     dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkGenericDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Generic Geometry
        Filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="0"
                         command="SetPassThroughCellIds"
                         default_values="1"
                         name="PassThroughCellIds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Select whether to forward original ids.</Documentation>
      </IntVectorProperty>
      <!-- End GenericGeometryFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGenericOutlineFilter"
                 label="Outline Generic DataSet"
                 name="GenericOutlineFilter">
      <Documentation long_help="This filter generates a bounding box representation of the input."
                     short_help="Generates a bounding box.">The Generic Outline
                     filter generates an axis-aligned bounding box for the
                     input data set. The Input menu specifies the data set for
                     which to create a bounding box. This filter operates on
                     generic data sets and produces polygonal
                     output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkGenericDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Generic Outline
        filter.</Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
      </Hints>
      <!-- End  GenericOutlineFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGenericStreamTracer"
                 label="Stream Tracer For Generic Datasets"
                 name="GenericStreamTracer">
      <Documentation long_help="Integrate streamlines in a vector field."
                     short_help="Integrate streamlines in a vector field.">The
                     Generic Stream Tracer filter generates streamlines in a
                     vector field from a collection of seed points. The vector
                     field used is selected from the Vectors menu, so the input
                     data set is required to have point-centered vectors. The
                     Seed portion of the interface allows you to select whether
                     the seed points for this integration lie in a point cloud
                     or along a line. Depending on which is selected, the
                     appropriate 3D widget (point or line widget) is displayed
                     along with traditional user interface controls for
                     positioning the point cloud or line within the data set.
                     Instructions for using the 3D widgets and the
                     corresponding manual controls can be found in section 7.4.
                     The Max. Propagation entry box allows you to specify the
                     maximum length of the streamlines. From the Max.
                     Propagation menu, you can select the units to be either
                     Time (the time a particle would travel with steady flow)
                     or Length (in the data set's spatial coordinates). The
                     Init. Step Len. menu and entry specify the initial step
                     size for integration. (For non-adaptive integrators,
                     Runge-Kutta 2 and 4, the initial step size is used
                     throughout the integration.) The menu allows you to
                     specify the units. Time and Length have the same meaning
                     as for Max. Propagation. Cell Length specifies the step
                     length as a number of cells. The Integration Direction
                     menu determines in which direction(s) the stream trace
                     will be generated: FORWARD, BACKWARD, or BOTH. The
                     Integrator Type section of the interface determines which
                     calculation to use for integration: Runge-Kutta 2,
                     Runge-Kutta 4, or Runge-Kutta 4-5. If Runge-Kutta 4-5 is
                     selected, controls are displayed for specifying the
                     minimum and maximum step length and the maximum error. The
                     controls for specifying Min. Step Len. and Max. Step Len.
                     are the same as those for Init. Step Len. The Runge-Kutta
                     4-5 integrator tries to choose the step size so that the
                     estimated error is less than the value of the Maximum
                     Error entry. If the integration takes more than Max. Steps
                     to complete, if the speed goes below Term. Speed, if Max.
                     Propagation is reached, or if a boundary of the input data
                     set is crossed, integration terminates. This filter
                     operates on any type of data set, provided it has
                     point-centered vectors. The output is polygonal data
                     containing polylines.</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkGenericDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="3" />
        <Documentation>Set the input to the Generic Stream Tracer
        filter.</Documentation>
      </InputProperty>
      <InputProperty command="SetSourceConnection"
                     label="Seed Type"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Group name="seed_sources"/>
        </ProxyListDomain>
        <Documentation>The value of this property determines how the seeds for
        the streamlines will be generated.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Vectors"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property contains the name of the vector array from
        which to generate streamlines.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetMaximumPropagation"
                            default_values="1.0"
                            name="MaximumPropagation"
                            number_of_elements="1">
        <BoundsDomain mode="scaled_extent"
                      name="bounds"
                      scale_factor="1.0">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>Specify the maximum streamline length.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetInitialIntegrationStep"
                            default_values="0.5"
                            name="InitialIntegrationStep"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Specify the initial integration step.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetIntegrationDirection"
                         default_values="2"
                         name="IntegrationDirection"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="FORWARD"
                 value="0" />
          <Entry text="BACKWARD"
                 value="1" />
          <Entry text="BOTH"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines in which direction(s) a
        streamline is generated.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetIntegratorType"
                         default_values="2"
                         name="IntegratorType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Runge-Kutta 2"
                 value="0" />
          <Entry text="Runge-Kutta 4"
                 value="1" />
          <Entry text="Runge-Kutta 4-5"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines which integrator (with
        increasing accuracy) to use for creating streamlines.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetMaximumError"
                            default_values="0.000001"
                            name="MaximumError"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Set the maximum error allowed in the integration. The
        meaning of this value depends on the integrator chosen.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetMinimumIntegrationStep"
                            default_values="0.01"
                            name="MinimumIntegrationStep"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Specify the minimum integration step.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetIntegrationStepUnit"
                         default_values="2"
                         name="IntegrationStepUnit"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Time"
                 value="0" />
          <Entry text="Length"
                 value="1" />
          <Entry text="Cell Length"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Choose the unit to use for the integration
        step.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetMaximumIntegrationStep"
                            default_values="0.01"
                            name="MaximumIntegrationStep"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Specify the maximum integration step.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfSteps"
                         default_values="2000"
                         name="MaximumNumberOfSteps"
                         number_of_elements="1">
        <IntRangeDomain name="range" />
        <Documentation>Specify the maximum number of steps used in the
        integration.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetTerminalSpeed"
                            default_values="0.000000000001"
                            name="TerminalSpeed"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>If at any point the speed is below this value, the
        integration is terminated.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
      <!-- End GenericStreamTracer -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGenericDataSetTessellator"
                 label="Tessellate Generic Dataset"
                 name="GenericTessellator">
      <Documentation long_help="Tessellate a higher-order dataset"
                     short_help="Tessellate a higher-order dataset">Tessellate
                     a higher-order dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkGenericDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Generic Tessellator
        filter.</Documentation>
      </InputProperty>
      <!-- End GenericTessellator -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkMultiBlockDataGroupFilter"
                 label="Group Datasets"
                 name="GroupDataSets">
      <Documentation long_help="Group data sets."
                     short_help="Group multiple inputs into one collection.">
                     Groups multiple datasets to create a multiblock
                     dataset</Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="1"
                        name="input_type">
          <DataType value="vtkDataObject" />
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <Documentation>This property indicates the the inputs to the Group
        Datasets filter.</Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="1" />
      </Hints>
      <!-- End GroupDataSets -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkMultiBlockFromTimeSeriesFilter"
                 label="Group Time Steps"
                 name="GroupTimeSteps">
      <Documentation long_help="Group data set over time."
                     short_help="Group all the time steps in the input into one collection with no time.">
                     Groups all the time steps in the input into a collection with no time information.
                     Each timestep will become one block of the output.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the input dataset.</Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="1" />
      </Hints>
      <!-- End GroupDataSets -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkBlockIdScalars"
                 label="Block Scalars"
                 name="BlockIdScalars">
      <Documentation long_help="The Level Scalars filter uses colors to show levels of a multiblock dataset."
                     short_help="Generate point scalars from level.">The Level
                     Scalars filter uses colors to show levels of a multiblock
                     dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Level Scalars
        filter.</Documentation>
      </InputProperty>
      <!-- End GroupIdScalars -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkOverlappingAMRLevelIdScalars"
                 label="Level Scalars(Overlapping AMR)"
                 name="OverlappingLevelIdScalars">
      <Documentation long_help="The Level Scalars filter uses colors to show levels of a hierarchical dataset."
                     short_help="Generate point scalars from level.">The Level
                     Scalars filter uses colors to show levels of a
                     hierarchical dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkOverlappingAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Level Scalars
        filter.</Documentation>
      </InputProperty>
      <!-- End GroupIdScalars -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkNonOverlappingAMRLevelIdScalars"
                 label="Level Scalars(Non-Overlapping AMR)"
                 name="NonOverlappingLevelIdScalars">
      <Documentation long_help="The Level Scalars filter uses colors to show levels of a hierarchical dataset."
                     short_help="Generate point scalars from level.">The Level
                     Scalars filter uses colors to show levels of a
                     hierarchical dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkNonOverlappingAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Level Scalars
        filter.</Documentation>
      </InputProperty>
      <!-- End GroupIdScalars -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVGeometryFilter"
                 name="GeometryFilter">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <!-- Does this have any data type domain? -->
        <Documentation>Set the input to the Geometry Filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="0"
                         command="SetUseStrips"
                         default_values="0"
                         is_internal="1"
                         name="UseStrips"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Toggle whether to generate faces containing triangle
        strips. This should render faster and use less memory, but no cell data
        is copied.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetForceUseStrips"
                         default_values="0"
                         is_internal="1"
                         name="ForceStrips"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This makes UseStrips call Modified() after changing its
        setting to ensure that the filter's output is immediately
        changed.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetUseOutline"
                         default_values="0"
                         name="UseOutline"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Toggle whether to generate an outline or a
        surface.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetNonlinearSubdivisionLevel"
                         default_values="1"
                         name="NonlinearSubdivisionLevel"
                         number_of_elements="1">
        <IntRangeDomain max="4"
                        min="0"
                        name="range" />
        <Documentation>Nonlinear faces are approximated with flat polygons.
        This parameter controls how many times to subdivide nonlinear surface
        cells. Higher subdivisions generate closer approximations but take more
        memory and rendering time. Subdivision is recursive, so the number of
        output polygons can grow exponentially with this
        parameter.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetPassThroughCellIds"
                         default_values="1"
                         name="PassThroughIds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If on, the output polygonal dataset will have a cell data
        array that holds the cell index of the original 3D cell that produced
        each output cell. This is useful for cell picking.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetPassThroughPointIds"
                         default_values="1"
                         name="PassThroughPointIds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If on, the output polygonal dataset will have a
        point data array that holds the point index of the original 3D vertex
        that produced each output vertex. This is useful for
        picking.</Documentation>
      </IntVectorProperty>
      <!-- End GeometryFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageDataToPointSet"
                 label="Image Data to Point Set"
                 name="ImageDataToPointSet">
      <Documentation long_help="Converts an Image Data to a Point Set"
      short_help="Converts an Image Data to a Point Set">The Image
      Data to Point Set filter takes an image data (uniform
      rectilinear grid) object and outputs an equivalent structured
      grid (which as a type of point set). This brings the data to a
      broader category of data storage but only adds a small amount of
      overhead. This filter can be helpful in applying filters that
      expect or manipulate point coordinates.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
      </InputProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRectilinearGridToPointSet"
                 label="Rectilinear Data to Point Set"
                 name="RectilinearGridToPointSet">
      <Documentation short_help="Converts a rectilinear grid to an
      equivalend structured grid">The Rectilinear Grid to Point Set
      filter takes an rectilinear grid object and outputs an
      equivalent Structured Grid (which is a type of point set). This
      brings the data to a broader category of data storage but only
      adds a small amount of overhead. This filter can be helpful in
      applying filters that expect or manipulate point
      coordinates.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkRectilinearGrid" />
        </DataTypeDomain>
      </InputProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRemoveGhosts"
                 label="Remove Ghost Information"
                 name="RemoveGhostInformation">
      <Documentation long_help="Removes ghost information."
                     short_help="Removes ghost information.">Removes ghost
      cells and point data and cell data ghost arrays.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
          <DataType value="vtkUnstructuredGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the remove ghost
        information filter.</Documentation>
      </InputProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkMergeCompositeDataSet"
                 name="FlattenFilter">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
          <DataType value="vtkGraph" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Flatten Filter.</Documentation>
      </InputProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkOrderedCompositeDistributor"
                 name="OrderedCompositeDistributor">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>Set the input to the Ordered Composite Distributor
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="0"
                         command="SetPassThrough"
                         default_values="0"
                         name="PassThrough"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Toggle whether to pass the data through without
        compositing.</Documentation>
      </IntVectorProperty>
      <ProxyProperty command="SetPKdTree"
                     name="PKdTree">
        <ProxyGroupDomain name="groups">
          <Group name="locators" />
        </ProxyGroupDomain>
        <Documentation>Set the vtkPKdTree to distribute with.</Documentation>
      </ProxyProperty>
      <StringVectorProperty command="SetOutputType"
                            name="OutputType"
                            number_of_elements="1">
        <Documentation>When not empty, the output will be converted to the
        given type.</Documentation>
      </StringVectorProperty>
      <!-- End OrderedCompositeDistributor -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkMPIMoveData"
                 name="MPIMoveData">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <!-- Does this have any data type domain? -->
        <Documentation>Set the input to the MPI Move Data
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="0"
                         command="SetMoveMode"
                         default_values="0"
                         name="MoveMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="PassThrough"
                 value="0" />
          <Entry text="Collect"
                 value="1" />
          <Entry text="Clone"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Specify how the data is to be
        redistributed.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetOutputDataType"
                         default_values="none"
                         name="OutputDataType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="PolyData"
                 value="0" />
          <Entry text="Unstructured Grid"
                 value="4" />
          <Entry text="ImageData"
                 value="6" />
        </EnumerationDomain>
        <Documentation>Specify the type of the dataset.</Documentation>
      </IntVectorProperty>
      <!-- End MPIMoveData -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkClientServerMoveData"
                 name="ClientServerMoveData"
                 processes="client|dataserver">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>Set the input to the Client Server Move Data
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty animateable="0"
                         command="SetOutputDataType"
                         default_values="0"
                         name="OutputDataType"
                         number_of_elements="1"></IntVectorProperty>
      <IntVectorProperty command="SetWholeExtent"
                         default_values="0 -1 0 -1 0 -1"
                         name="WholeExtent"
                         number_of_elements="6"></IntVectorProperty>
      <!-- End ClientServerMoveData -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkReductionFilter"
                 name="AppendReductionFilter"
                 label="Append Reduce">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain composite_data_supported="0"
                        name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Reduction filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetPostGatherHelperName"
                            name="PostGatherHelperName"
                            panel_visibility="never"
                            default_values="vtkAppendFilter"
                            number_of_elements="1">
        <Documentation>Set the algorithm that takes multiple inputs and
        produces a single reduced output.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetReductionMode"
                         default_values="2"
                         name="ReductionMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Reduce all data to one processor"
                 value="0" />
          <Entry text="Move all data to one processor"
                 value="1" />
          <Entry text="Reduce all data to all processors"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Set the reduction mode. Reducing all data to one
        processor means that the destination process will have all data while
        each other process will still have it's own data. Moving all to one processor means
        that the destination process will have all data while other process have no data
        anymore. Reduce all data to all processors is self explanatory.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetReductionProcessId"
                         default_values="0"
                         name="ReduceTo"
                         number_of_elements="1">
        <IntRangeDomain min="0"
                        name="range" />
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="ReductionMode"
                                   value="2"
                                   inverse="1"/>
          <!-- show this widget when ReductionMode is not 2 -->
        </Hints>
        <Documentation>Set the process to reduce to.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPassThrough"
                         default_values="-1"
                         name="OnlyFrom"
                         number_of_elements="1">
        <IntRangeDomain min="-1"
                        name="range" />
        <Documentation>If set to a non-negative value, then produce results
        using only the node Id specified.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetGenerateProcessIds"
                         default_values="0"
                         name="GenerateProcessIds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If true, the filter will generate vtkOriginalProcessIds
        arrays indicating the process id on which the cell/point was
        generated.</Documentation>
      </IntVectorProperty>
      <!-- End ReductionFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkReductionFilter"
                 name="ReductionFilter">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>Set the input to the Reduction filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetReductionMode"
                         default_values="0"
                         name="ReductionMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Move all data to one processor"
                 value="0" />
          <Entry text="Reduce all data to one processor"
                 value="1" />
          <Entry text="Reduce all data to all processors"
                 value="2" />
        </EnumerationDomain>
      </IntVectorProperty>
      <IntVectorProperty command="SetReductionProcessId"
                         default_values="0"
                         name="ReduceTo"
                         number_of_elements="1">
      </IntVectorProperty>

      <StringVectorProperty command="SetPreGatherHelperName"
                            name="PreGatherHelperName"
                            number_of_elements="1">
        <Documentation>Set the algorithm that runs on each node in
        parallel.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetPostGatherHelperName"
                            name="PostGatherHelperName"
                            number_of_elements="1">
        <Documentation>Set the algorithm that takes multiple inputs and
        produces a single reduced output.</Documentation>
      </StringVectorProperty>
      <ProxyProperty command="SetPostGatherHelper"
                     name="PostGatherHelper" />
      <ProxyProperty command="SetPreGatherHelper"
                     name="PreGatherHelper" />
      <IntVectorProperty command="SetPassThrough"
                         default_values="-1"
                         name="PassThrough"
                         number_of_elements="1">
        <IntRangeDomain min="-1"
                        name="range" />
        <Documentation>If set to a non-negative value, then produce results
        using only the node Id specified.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetGenerateProcessIds"
                         default_values="0"
                         name="GenerateProcessIds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If true, the filter will generate vtkOriginalProcessIds
        arrays indicating the process id on which the cell/point was
        generated.</Documentation>
      </IntVectorProperty>
      <!-- End ReductionFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractLevel"
                 label="Extract Level"
                 name="ExtractHierarchicalLevel">
      <Documentation long_help="This filter extracts a range of groups from a hierarchical dataset."
                     short_help="Extract level.">This filter extracts a range
                     of levels from a hierarchical dataset</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUniformGridAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Extract Group
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty clean_command="RemoveAllLevels"
                         command="AddLevel"
                         name="Levels"
                         number_of_elements_per_command="1"
                         panel_visibility="default"
                         repeat_command="1">
        <CompositeTreeDomain mode="amr"
                             name="tree">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </CompositeTreeDomain>
        <Documentation>This property lists the levels to extract from the input
        hierarchical dataset.</Documentation>
      </IntVectorProperty>
      <!-- End ExtractHierarchicalLevel -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractBlock"
                 label="Extract Block"
                 name="ExtractBlock">
      <Documentation long_help="This filter extracts a range of blocks from a multiblock dataset."
                     short_help="Extract block.">This filter extracts a range
                     of groups from a multiblock dataset</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet" />
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Extract Group
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty clean_command="RemoveAllIndices"
                         command="AddIndex"
                         name="BlockIndices"
                         number_of_elements_per_command="1"
                         panel_visibility="default"
                         repeat_command="1">
        <CompositeTreeDomain mode="all"
                             name="tree">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </CompositeTreeDomain>
        <Hints>
          <WidgetHeight number_of_rows="20" />
        </Hints>
        <Documentation>This property lists the ids of the blocks to extract
        from the input multiblock dataset.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPruneOutput"
                         default_values="1"
                         name="PruneOutput"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>When set, the output multiblock dataset will be pruned
        to remove empty nodes. On by default.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMaintainStructure"
                         default_values="0"
                         name="MaintainStructure"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This is used only when PruneOutput is ON. By default,
        when pruning the output i.e. remove empty blocks, if node has only 1
        non-null child block, then that node is removed. To preserve these
        parent nodes, set this flag to true.</Documentation>
      </IntVectorProperty>
      <!-- End ExtractBlock -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVExtractComponent"
                 name="ExtractComponent"
                 label="Extract Component">
      <Documentation long_help="This filter extracts a component of a multi-component attribute array."
                     short_help="Extract Component."/>
      <InputProperty command="SetInputConnection" name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array">
        </InputArrayDomain>
        <Documentation>
          This property specifies the input of the Extract Component filter.
        </Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputArray"
                            label="Input Array"
                            number_of_elements="5">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>
          This property indicates the name of the array to be extracted.
        </Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetInputArrayComponent"
                         default_values="0"
                         name="Component"
                         number_of_elements="1">
        <NumberOfComponentsDomain name="comps">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputArray" />
          </RequiredProperties>
        </NumberOfComponentsDomain>
        <Documentation>
          This property indicates the component of the array to be extracted.
        </Documentation>
      </IntVectorProperty>
      <StringVectorProperty command="SetOutputArrayName"
                            name="OutputArrayName"
                            label="Output Array Name"
                            default_values="Result"
                            number_of_elements="1">
        <Documentation>
          This property indicates the name of the output scalar array.
        </Documentation>
      </StringVectorProperty>
      <!-- End ExtractComponent -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractDataSets"
                 label="Extract AMR Blocks"
                 name="ExtractHierarchicalDataSets">
      <Documentation long_help="This filter extracts a list of datasets from hierarchical datasets."
                     short_help="Extract datasets.">This filter extracts a list
                     of datasets from hierarchical datasets.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkUniformGridAMR" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Extract
        Datasets filter.</Documentation>
      </InputProperty>
      <IntVectorProperty clean_command="ClearDataSetList"
                         command="AddDataSet"
                         name="SelectedDataSets"
                         number_of_elements_per_command="2"
                         repeat_command="1">
        <CompositeTreeDomain mode="amr"
                             name="tree">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </CompositeTreeDomain>
        <Documentation>This property provides a list of datasets to
        extract.</Documentation>
      </IntVectorProperty>
      <!-- End ExtractDataSets -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageMapToColors"
                 label="Color By Array"
                 name="ColorByArray">
      <Documentation long_help="This filter generate a color based image data based on a selected data scalar"
                     short_help="This filter generate a color based image data based on a selected data scalar"/>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1" />
      </InputProperty>
      <ProxyProperty command="SetLookupTable"
                     name="LookupTable">
      </ProxyProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Color By"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies the name of the scalar array
        from which we will color by.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetNaNColor"
                         name="NaNColor"
                         label="RGBA NaN Color"
                         default_values="0 0 0 255"
                         number_of_elements="4">
        <IntRangeDomain max="255 255 255 255"
                        min="0 0 0 0"
                        name="range" />
      </IntVectorProperty>
      <IntVectorProperty command="SetOutputFormat"
                         name="OutputFormat"
                         default_values="3"
                         number_of_elements="1">
                         <EnumerationDomain name="enum">
                           <Entry text="Luminance"
                                  value="1" />
                           <Entry text="Luminance Alpha"
                                  value="2" />
                           <Entry text="RGB"
                                  value="3" />
                           <Entry text="RGBA"
                                  value="4" />
                         </EnumerationDomain>
      </IntVectorProperty>
      <!-- End vtkExtractColor -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPExtractHistogram"
                 label="Histogram"
                 name="ExtractHistogram">
      <Documentation long_help="Extract a histogram from field data."
                     short_help="Extract a histogram from field data.">
                     </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array">
        </InputArrayDomain>
        <Documentation>This property specifies the input to the Histogram
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputArray"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property indicates the name of the array from which
        to compute the histogram.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetBinCount"
                         default_values="10"
                         name="BinCount"
                         number_of_elements="1">
        <IntRangeDomain max="256"
                        min="1"
                        name="range" />
        <Documentation>The value of this property specifies the number of bins
        for the histogram.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetComponent"
                         default_values="0"
                         name="Component"
                         number_of_elements="1">
        <NumberOfComponentsDomain name="comps" enable_magnitude="1">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputArray" />
          </RequiredProperties>
        </NumberOfComponentsDomain>
        <Documentation>The value of this property specifies the array component
        from which the histogram should be computed.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCalculateAverages"
                         default_values="0"
                         name="CalculateAverages"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>This option controls whether the algorithm calculates
        averages of variables other than the primary variable that fall into
        each bin.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseCustomBinRanges"
                         default_values="0"
                         name="UseCustomBinRanges"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When set to true, CustomBinRanges will be used instead
        of using the full range for the selected array. By default, set to
        false.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetCenterBinsAroundMinAndMax"
                         default_values="0"
                         name="CenterBinsAroundMinAndMax"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>When set to true, first and last bin will be centered
          around the minimum and the maximum values of the data.
          By default, set to false.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="UseCustomBinRanges" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetCustomBinRanges"
                            default_values="0.0 100.0"
                            name="CustomBinRanges"
                            number_of_elements="2"
                            panel_visibility="advanced">
        <Documentation>Set custom bin ranges to use. These are used only when
        UseCustomBinRanges is set to true.</Documentation>
        <ArrayRangeDomain name="scalar_range">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="ArraySelection"
                      name="SelectInputArray" />
          </RequiredProperties>
        </ArrayRangeDomain>
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="UseCustomBinRanges" function="boolean" />
          </PropertyWidgetDecorator>
        </Hints>
      </DoubleVectorProperty>
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYBarChartView" />
        <Plotable />
      </Hints>
      <!-- End ExtractHistogram -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkComputeQuartiles"
                 label="Compute Quartiles"
                 name="ComputeQuartiles">
      <Documentation long_help="Compute the quartiles table from a dataset or table."
                     short_help="Compute the quartiles table from a dataset or table.">
                     </Documentation>
      <InputProperty command="SetInputConnection"
                    name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the
        filter.</Documentation>
      </InputProperty>
      <!-- View can be used to specify the preferred view for the proxy -->
      <Hints>
        <View type="BoxChartView" />
        <Plotable />
      </Hints>
      <!-- End ComputeQuartiles -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVTransposeTable"
                 label="Transpose Table"
                 name="TransposeTable">
      <Documentation long_help="Transpose a table."
                     short_help="Transpose a table.">
                     </Documentation>
      <InputProperty command="SetInputConnection"
                    name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="row"
                          name="input_aray"
                          number_of_components="1"/>
        <Documentation>This property specifies the input to the
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty clean_command="ClearAttributeArrays"
                            command="EnableAttributeArray"
                            label="Variables of Interest"
                            name="SelectArrays"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Choose arrays whose entries will be used to form
        observations for statistical analysis.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetAddIdColumn"
                         default_values="1"
                         name="AddIdColumn"
                         label="Add a column with original columns name"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This flag indicates if a column must be inserted
          at index 0 with the names (ids) of the input columns.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseIdColumn"
                         default_values="0"
                         name="UseIdColumn"
                         label="Use the column with original columns name"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This flag indicates if the output column must be
          named using the names listed in the index 0 column.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetDoNotTranspose"
                         default_values="0"
                         name="DoNotTranspose"
                         label="Only extract selected columns"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>This flag indicates if the sub-table must be
        effectively transposed or not.</Documentation>
      </IntVectorProperty>
      <!-- End TransposeTable -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPassThrough"
                 label="Scatter Plot"
                 name="ScatterPlot">
      <Documentation long_help="Creates a scatter plot from a dataset."
                     short_help="Creates a scatter plot from a dataset.">This
                     filter creates a scatter plot from a
                     dataset.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the
        filter.</Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="PlotMatrixView" />
        <Plotable />
      </Hints>
      <!-- End ScatterPlot -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRectilinearGridGeometryFilter"
                 name="RectilinearGridGeometryFilter">
      <Documentation long_help="Extracts geometry for a rectilinear grid.  Output is a polydata dataset."
                     short_help="Extracts geometry for a rectilinear grid.">
                     RectilinearGridGeometryFilter is a filter that extracts
                     geometry from a rectilinear grid. By specifying
                     appropriate i-j-k indices, it is possible to extract a
                     point, a curve, a surface, or a "volume". The volume is
                     actually a (n x m x o) region of points. The extent
                     specification is zero-offset. That is, the first k-plane
                     in a 50x50x50 rectilinear grid is given by (0,49, 0,49,
                     0,0).</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Rectilinear Grid Geometry
        filter.</Documentation>
      </InputProperty>
      <!-- End RectilinearGridGeometryFilter -->
    </SourceProxy>
    <SourceProxy class="vtkTextureMapToPlane"
                 label="Texture Map to Plane"
                 name="TextureMapToPlane">
      <Documentation long_help="Generate texture coordinates by mapping points to plane."
                     short_help="Generate texture coordinates by mapping points to plane.">
                     TextureMapToPlane is a filter that generates 2D texture
                     coordinates by mapping input dataset points onto a plane.
                     The plane is generated automatically. A least squares
                     method is used to generate the plane
                     automatically.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Texture Map to Plane
        filter.</Documentation>
      </InputProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetOrigin"
                            default_values="0.0 0.0 0.0"
                            name="Origin"
                            number_of_elements="3"
                            panel_visibility="default">
        <Documentation>This property specifies the 3D coordinates for the
        origin of the plane. Set all to zero if you want to use automatic
        generation.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetPoint1"
                            default_values="0.0 0.0 0.0"
                            name="Point1"
                            number_of_elements="3"
                            panel_visibility="default">
        <Documentation>This property specifies the 3D coordinates for
        Point1 of the plane. Set all to zero if you want to use automatic
        generation.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetPoint2"
                            default_values="0.0 0.0 0.0"
                            name="Point2"
                            number_of_elements="3"
                            panel_visibility="default">
        <Documentation>This property specifies the 3D coordinates for
        Point2 of the plane. Set all to zero if you want to use automatic
        generation.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetAutomaticPlaneGeneration"
                         default_values="1"
                         name="Automatic"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If set the plane values will be automatically generated.
        Note that for this to work all the Origin, Point1 and Point2 must all
        be set to zero.</Documentation>
      </IntVectorProperty>
      <!-- End TextureMapToPlane -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTextureMapToSphere"
                 label="Texture Map to Sphere"
                 name="TextureMapToSphere">
      <Documentation long_help="Generate texture coordinates by mapping points to sphere."
                     short_help="Generate texture coordinates by mapping points to sphere.">
                     This is a filter that generates 2D texture coordinates by
                     mapping input dataset points onto a sphere. The sphere is
                     generated automatically. The sphere is generated
                     automatically by computing the center i.e. averaged
                     coordinates, of the sphere. Note that the generated
                     texture coordinates range between (0,1). The s-coordinate
                     lies in the angular direction around the z-axis, measured
                     counter-clockwise from the x-axis. The t-coordinate lies
                     in the angular direction measured down from the north pole
                     towards the south pole.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Texture Map to Sphere
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPreventSeam"
                         default_values="1"
                         name="PreventSeam"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Control how the texture coordinates are generated. If
        Prevent Seam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0
        corresponding to the theta angle variation between 0-&gt;180 and
        180-&gt;0 degrees. Otherwise, the s-coordinate ranges from 0-&gt;1
        between 0-&gt;360 degrees.</Documentation>
      </IntVectorProperty>
      <!-- End TextureMapToSphere -->
    </SourceProxy>
    <SourceProxy class="vtkTextureMapToCylinder"
                 label="Texture Map to Cylinder"
                 name="TextureMapToCylinder">
      <Documentation long_help="Generate texture coordinates by mapping points to cylinder."
                     short_help="Generate texture coordinates by mapping points to cylinder.">
                     This is a filter that generates 2D texture coordinates by
                     mapping input dataset points onto a cylinder. The cylinder
                     is generated automatically. The cylinder is generated
                     automatically by computing the axis of the cylinder. Note
                     that the generated texture coordinates for the
                     s-coordinate ranges from (0-1) (corresponding to angle of
                     0-&gt;360 around axis), while the mapping of the
                     t-coordinate is controlled by the projection of points
                     along the axis.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Texture Map to Cylinder
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetPreventSeam"
                         default_values="1"
                         name="PreventSeam"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Control how the texture coordinates are generated. If
        Prevent Seam is set, the s-coordinate ranges from 0-&gt;1 and 1-&gt;0
        corresponding to the theta angle variation between 0-&gt;180 and
        180-&gt;0 degrees. Otherwise, the s-coordinate ranges from 0-&gt;1
        between 0-&gt;360 degrees.</Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="GenerateCylinderAutomatically"
        command="SetAutomaticCylinderGeneration"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          When set, the filter will try to determine the size and orientation of the cylinder
          used for texture mapping using data bounds.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Point1"
        command="SetPoint1"
        number_of_elements="3"
        default_values="0 0 0">
        <BoundsDomain name="bounds" mode="normal" default_mode="mid,mid,min">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          When **GenerateCylinderAutomatically** is not set, specify the first point defining
          the axis of the cylinder through its center.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="enabled_state"
                                   property="GenerateCylinderAutomatically"
                                   value="0" />
        </Hints>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Point2"
        command="SetPoint2"
        number_of_elements="3"
        default_values="0 0 0">
        <BoundsDomain name="bounds" mode="normal" default_mode="mid,mid,max">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          When **GenerateCylinderAutomatically** is not set, specify the second point defining
          the axis of the cylinder through its center.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="enabled_state"
                                   property="GenerateCylinderAutomatically"
                                   value="0" />
        </Hints>
      </DoubleVectorProperty>

      <!-- End TextureMapToCylinder -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPolyLineToRectilinearGridFilter"
                 label="PolyLine To Rectilinear Grid"
                 name="PolyLineToRectilinearGrid">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>Set the input to the Polyline to Rectilinear Grid
        filter.</Documentation>
      </InputProperty>
      <!-- End PolyLineToRectilinearGrid -->
    </SourceProxy>
    <SourceProxy class="vtkMinMax"
                 name="MinMax">
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Set the input to the Min Max filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetOperation"
                            default_values="MIN"
                            name="Operation"
                            number_of_elements="1">
        <StringListDomain name="operation">
          <String value="MIN" />
          <String value="MAX" />
          <String value="SUM" />
        </StringListDomain>
        <Documentation>Select whether to perform a min, max, or sum operation
        on the data.</Documentation>
      </StringVectorProperty>
      <!-- End MinMax -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVExtractSelection"
                 label="Extract Selection (internal)"
                 name="PVExtractSelection">
      <Documentation>
        This filter extracts a given set of cells or points given
        a selection. The selection can be obtained from a rubber-band selection
        (either point, cell, visible or in a frustum) and passed to the filter or
        specified by providing an ID list. This is an internal filter, use
        "ExtractSelection" instead.
      </Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>
          The input from which the selection is
          extracted.
        </Documentation>
      </InputProperty>
      <InputProperty clean_command="RemoveAllSelectionsInputs"
                     command="SetSelectionConnection"
                     name="Selection">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkSelection" />
        </DataTypeDomain>
        <Documentation>
          The input that provides the selection
          object.
        </Documentation>
      </InputProperty>
      <!-- End ExtractSelection -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTimeToTextConvertor"
                 label="Annotate Time Filter"
                 name="TimeToTextConvertor">
      <Documentation long_help="Shows input data time as text annnotation in the view."
                     short_help="Show data time as text.">The Annotate Time
                     filter can be used to show the data time in a text
                     annotation.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the input dataset for which to
        display the time.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetFormat"
                            default_values="Time: %f"
                            name="Format"
                            number_of_elements="1"
                            panel_visibility="default">
        <Documentation>The value of this property is a format string used to
        display the input time. The format string is specified using printf
        style.</Documentation>
      </StringVectorProperty>
      <DoubleVectorProperty command="SetShift"
                            default_values="0.0"
                            name="Shift"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>The amount of time the input is shifted (after
        scaling).</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetScale"
                            default_values="1.0"
                            name="Scale"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>The factor by which the input time is
        scaled.</Documentation>
      </DoubleVectorProperty>
      <Hints>
        <Visibility replace_input="0" />
        <OutputPort index="0"
                    name="Output-0"
                    type="text" />
      </Hints>
      <!-- End of TimeToTextConvertor -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTimeStepProgressFilter"
                 label="Time Step Progress Bar"
                 name="TimeStepProgressFilter">
      <Documentation long_help="Shows input data time as progress bar in the view."
                     short_help="Show data time step as progress bar.">The Time Step Progress Bar
                     filter can be used to show the relative position of the actual time step/value
                     relatively to the number of timesteps/data time range in a progress bar.
                     </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <Documentation>This property specifies the input dataset for which to
        display the time step.</Documentation>
      </InputProperty>
      <Hints>
        <Visibility replace_input="0" />
        <OutputPort index="0"
                    name="Output-0"
                    type="progress" />
      </Hints>
      <!-- End of TimeToTextConvertor -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkCellDerivatives"
                 label="Compute Derivatives"
                 name="CellDerivatives">
      <Documentation long_help="This filter computes derivatives of scalars and vectors."
                     short_help="Computes derivatives of scalars/vectors.">
                     CellDerivatives is a filter that computes derivatives of
                     scalars and vectors at the center of cells. You can choose
                     to generate different output including the scalar gradient
                     (a vector), computed tensor vorticity (a vector), gradient
                     of input vectors (a tensor), and strain matrix of the
                     input vectors (a tensor); or you may choose to pass data
                     through to the output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array1"
                          number_of_components="1"
                          optional="1" />
        <InputArrayDomain attribute_type="point"
                          name="input_array2"
                          number_of_components="3"
                          optional="1" />
        <Documentation>This property specifies the input to the
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Scalars"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array1"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property indicates the name of the scalar array to
        differentiate.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            default_values="1"
                            element_types="0 0 0 0 2"
                            label="Vectors"
                            name="SelectInputVectors"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="input_array2"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property indicates the name of the vector array to
        differentiate.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetVectorMode"
                         default_values="1"
                         name="OutputVectorType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Nothing"
                 value="0" />
          <Entry text="Scalar Gradient"
                 value="1" />
          <Entry text="Vorticity"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property Controls how the filter works to generate
        vector cell data. You can choose to compute the gradient of the input
        scalars, or extract the vorticity of the computed vector gradient
        tensor. By default, the filter will take the gradient of the input
        scalar data.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetTensorMode"
                         default_values="1"
                         name="OutputTensorType"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Nothing"
                 value="0" />
          <Entry text="Vector Gradient"
                 value="1" />
          <Entry text="Strain"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property controls how the filter works to generate
        tensor cell data. You can choose to compute the gradient of the input
        vectors, or compute the strain tensor of the vector gradient tensor. By
        default, the filter will take the gradient of the vector data to
        construct a tensor.</Documentation>
      </IntVectorProperty>
      <!-- End CellDerivatives -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPVSingleOutputExtractSelection"
                 label="Extract Selection"
                 name="ExtractSelection">
      <Documentation long_help="Extract different type of selections."
                     short_help="Extract different type of selections.">This
                     filter extracts a set of cells/points given a selection.
                     The selection can be obtained from a rubber-band selection
                     (either cell, visible or in a frustum) or threshold
                     selection and passed to the filter or specified by
                     providing an ID list.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkTable" />
        </DataTypeDomain>
        <Documentation>This property specifies the input from which the
        selection is extracted.</Documentation>
      </InputProperty>
      <InputProperty command="SetSelectionConnection"
                     name="Selection"
                     panel_visibility="default">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkSelection" />
        </DataTypeDomain>
        <Documentation>The input that provides the selection
        object.</Documentation>
        <Hints>
          <!-- This tag alerts the auto-generated panels and input selection
              that this input is a selection.  It should use the special
              selection GUI. -->
          <SelectionInput />
        </Hints>
      </InputProperty>
      <IntVectorProperty command="SetPreserveTopology"
                         default_values="0"
                         name="PreserveTopology"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1 the output preserves the
        topology of its input and adds an insidedness array to mark which cells
        are inside or out. If 0 then the output is an unstructured grid which
        contains only the subset of cells that are inside.</Documentation>
      </IntVectorProperty>
      <Hints>
        <InitializationHelper class="vtkSMExtractSelectionProxyInitializationHelper" />
      </Hints>
      <!-- End of ExtractSelection -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPConvertSelection"
                 name="ConvertSelection">
      <Documentation>Converts a selection from one type to
      another.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="DataInput"
                     port_index="1">
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>Set the vtkDataObject input used to convert the
        selection.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="0">
        <DataTypeDomain name="input_type">
          <DataType value="vtkSelection" />
        </DataTypeDomain>
        <Documentation>Set the selection to convert.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetOutputType"
                         default_values="5"
                         name="OutputType"
                         number_of_elements="1">
        <Documentation>Set the ContentType for the output.</Documentation>
        <EnumerationDomain name="enum">
          <Entry text="SELECTIONS"
                 value="0" />
          <Entry text="GLOBALIDs"
                 value="1" />
          <Entry text="PEDIGREEIDS"
                 value="2" />
          <Entry text="VALUES"
                 value="3" />
          <Entry text="INDICES"
                 value="4" />
          <Entry text="FRUSTUM"
                 value="5" />
          <Entry text="LOCATION"
                 value="6" />
          <Entry text="THRESHOLDS"
                 value="7" />
        </EnumerationDomain>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearArrayNames"
                            command="AddArrayName"
                            element_types="2"
                            name="ArrayNames"
                            number_of_elements_per_command="1"
                            repeat_command="1" />
      <IntVectorProperty command="SetMatchAnyValues"
                         default_values="0"
                         name="MatchAnyValues"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetAllowMissingArray"
                         default_values="0"
                         name="AllowMissingArray"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <!-- End of ConvertSelection -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDataObjectTreeToPointSetFilter"
                 label="Merge Blocks"
                 name="MergeBlocks">
      <Documentation short_help="Appends vtkCompositeDataSet leaves into a single vtkUnstructuredGrid or vtkPolyData">
      Merge Blocks appends all vtkDataSet leaves of the input composite dataset to a single
      unstructured grid (or polydata if all leaves are polydata). The subtree to
      be combined can be chosen using the SubTreeCompositeIndex. If the SubTreeCompositeIndex
      is a leaf node, then no appending is required nor performed.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObjectTree" />
        </DataTypeDomain>
        <Documentation>Set the input composite dataset.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetOutputDataSetType"
                         default_values="4"
                         number_of_elements="1"
                         name="OutputDataSetType"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Polygonal Mesh"
                 value="0" />
          <Entry text="Unstructured Grid"
                 value="4" />
        </EnumerationDomain>
        <Documentation>Determines the output type produced by this filter. Only blocks compatible
        with the output type will be merged in the output. For example, if the output type is
        "Polygonal Mesh", then blocks of type "Image Data", "Structured Grid", etc. will not be merged.
        If the output type is "UnstructuredGrid", then blocks of any type will be merged in the output.
        Defaults to "Unstructured Grid".
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetSubTreeCompositeIndex"
                         default_values="0"
                         is_internal="1"
                         name="SubTreeCompositeIndex"
                         number_of_elements="1">
        <CompositeTreeDomain mode="all"
                             name="tree">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </CompositeTreeDomain>
        <Documentation>Select the index of the subtree to be appended. For now,
        this property is internal.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMergePoints"
                         default_values="1"
                         label="Merge Points"
                         name="MergePoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Merge points within a distance specified by the **Tolerance**
        property.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetTolerance"
                            default_values="0"
                            label="Tolerance"
                            name="Tolerance"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <Documentation>Set the tolerance for merging points if **Merge Points** is enabled.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="MergePoints"
                                   value="1" />
          <!-- show this widget when MergePoints==1 and showing advanced options -->
        </Hints>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetToleranceIsAbsolute"
                         default_values="0"
                         name="ToleranceIsAbsolute"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>This property determines whether to treat the **Tolerance**
        property as absolute (points closer than Tolerance are merged) or relative
        (points closer than a fraction of the input data's bounding box diagonal length)
        when performing point merging.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="MergePoints"
                                   value="1" />
          <!-- show this widget when MergePoints==1 and showing advanced options -->
        </Hints>
      </IntVectorProperty>
      <!-- End of MergeBlocks -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <CompoundSourceProxy label="Normal Glyphs"
                         name="NormalGlyphs">
      <Documentation long_help="Filter computing surface normals."
                     short_help="Filter computing surface normals.">Filter
                     computing surface normals.</Documentation>
      <Proxy compound_name="ExtractSurface2"
             group="filters"
             id="1013"
             servers="1"
             type="DataSetSurfaceFilter">
        <Property id="1013.Input"
                  name="Input"
                  number_of_elements="1">
          <Domain id="1013.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="1013.Input.input_type"
                  name="input_type">
            <DataType value="vtkDataSet" />
          </Domain>
        </Property>
        <Property id="1013.PieceInvariant"
                  name="PieceInvariant"
                  number_of_elements="1">
          <Element index="0"
                   value="1" />
          <Domain id="1013.PieceInvariant.bool"
                  name="bool" />
        </Property>
      </Proxy>
      <Proxy compound_name="GenerateSurfaceNormals1"
             group="filters"
             id="1224"
             servers="1"
             type="PolyDataNormals">
        <Property id="1224.ComputeCellNormals"
                  name="ComputeCellNormals"
                  number_of_elements="1">
          <Element index="0"
                   value="1" />
          <Domain id="1224.ComputeCellNormals.bool"
                  name="bool" />
        </Property>
        <Property id="1224.Consistency"
                  name="Consistency"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="1224.Consistency.bool"
                  name="bool" />
        </Property>
        <Property id="1224.FeatureAngle"
                  name="FeatureAngle"
                  number_of_elements="1">
          <Element index="0"
                   value="30" />
          <Domain id="1224.FeatureAngle.range"
                  name="range">
            <Min index="0"
                 value="0" />
            <Max index="0"
                 value="180" />
          </Domain>
        </Property>
        <Property id="1224.FlipNormals"
                  name="FlipNormals"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="1224.FlipNormals.bool"
                  name="bool" />
        </Property>
        <Property id="1224.Input"
                  name="Input"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="1013" />
          <Domain id="1224.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="1224.Input.input_type"
                  name="input_type">
            <DataType value="vtkPolyData" />
          </Domain>
        </Property>
        <Property id="1224.NonManifoldTraversal"
                  name="NonManifoldTraversal"
                  number_of_elements="1">
          <Element index="0"
                   value="1" />
          <Domain id="1224.NonManifoldTraversal.bool"
                  name="bool" />
        </Property>
        <Property id="1224.PieceInvariant"
                  name="PieceInvariant"
                  number_of_elements="1">
          <Element index="0"
                   value="1" />
          <Domain id="1224.PieceInvariant.bool"
                  name="bool" />
        </Property>
        <Property id="1224.Splitting"
                  name="Splitting"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="1224.Splitting.bool"
                  name="bool" />
        </Property>
      </Proxy>
      <Proxy compound_name="CellCenters1"
             group="filters"
             id="3392"
             servers="1"
             type="CellCenters">
        <Property id="3392.Input"
                  name="Input"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="1224" />
          <Domain id="3392.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="3392.Input.input_type"
                  name="input_type">
            <DataType value="vtkDataSet" />
          </Domain>
        </Property>
        <Property id="3392.VertexCells"
                  name="VertexCells"
                  number_of_elements="1">
          <Element index="0"
                   value="1" />
          <Domain id="3392.VertexCells.bool"
                  name="bool" />
        </Property>
      </Proxy>
      <Proxy compound_name="Glyph1"
             group="filters"
             id="2429"
             servers="1"
             type="Glyph">
        <Property id="2429.Input"
                  name="Input"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="3392" />
          <Domain id="2429.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="2429.Input.input_array1"
                  name="input_array1">
            <InputArray attribute_type="point"
                        number_of_components="1" />
          </Domain>
          <Domain id="2429.Input.input_array2"
                  name="input_array2">
            <InputArray attribute_type="point"
                        number_of_components="3" />
          </Domain>
          <Domain id="2429.Input.input_type"
                  name="input_type">
            <DataType value="vtkDataSet" />
          </Domain>
        </Property>
        <Property name="GlyphMode"
                  id="2429.GlyphMode"
                  number_of_elements="1">
          <Element index="0" value="0"/>
        </Property>
        <Property id="2429.ScaleArray"
                  name="ScalarArray"
                  number_of_elements="5">
          <Element index="0"
                   value="" />
          <Element index="1"
                   value="" />
          <Element index="2"
                   value="" />
          <Element index="3"
                   value="" />
          <Element index="4"
                   value="" />
        </Property>
        <Property id="2429.OrientationArray"
                  name="OrientationArray"
                  number_of_elements="5">
          <Element index="0"
                   value="1" />
          <Element index="1"
                   value="" />
          <Element index="2"
                   value="" />
          <Element index="3"
                   value="" />
          <Element index="4"
                   value="Normals" />
        </Property>
        <Property id="2429.SetScaleFactor"
                  name="SetScaleFactor"
                  number_of_elements="1">
          <Element index="0"
                   value="1.0" />
        </Property>
        <!--
        <Property id="2429.ScaleMode"
                  name="ScaleMode"
                  number_of_elements="1">
          <Element index="0"
                   value="3" />
        </Property>
        -->
        <Property id="2429.Source"
                  name="Source"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="2432" />
          <Domain id="2429.Source.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="glyph_sources" />
          </Domain>
          <Domain id="2429.Source.input_type"
                  name="input_type">
            <DataType value="vtkPolyData" />
          </Domain>
          <Domain id="2429.Source.proxy_list"
                  name="proxy_list">
            <Proxy value="2432" />
          </Domain>
        </Property>
      </Proxy>
      <Proxy compound_name="ArrowSource"
             group="sources"
             id="2432"
             servers="1"
             type="ArrowSource">
        <Property id="2432.ShaftRadius"
                  name="ShaftRadius"
                  number_of_elements="1">
          <Element index="0"
                   value="0.03" />
          <Domain id="2432.ShaftRadius.range"
                  name="range">
            <Min index="0"
                 value="0" />
            <Max index="0"
                 value="5" />
          </Domain>
        </Property>
        <Property id="2432.ShaftResolution"
                  name="ShaftResolution"
                  number_of_elements="1">
          <Element index="0"
                   value="6" />
          <Domain id="2432.ShaftResolution.range"
                  name="range">
            <Min index="0"
                 value="0" />
            <Max index="0"
                 value="128" />
          </Domain>
        </Property>
        <Property id="2432.TipLength"
                  name="TipLength"
                  number_of_elements="1">
          <Element index="0"
                   value="0.35" />
          <Domain id="2432.TipLength.range"
                  name="range">
            <Min index="0"
                 value="0" />
            <Max index="0"
                 value="1" />
          </Domain>
        </Property>
        <Property id="2432.TipRadius"
                  name="TipRadius"
                  number_of_elements="1">
          <Element index="0"
                   value="0.1" />
          <Domain id="2432.TipRadius.range"
                  name="range">
            <Min index="0"
                 value="0" />
            <Max index="0"
                 value="10" />
          </Domain>
        </Property>
        <Property id="2432.TipResolution"
                  name="TipResolution"
                  number_of_elements="1">
          <Element index="0"
                   value="6" />
          <Domain id="2432.TipResolution.range"
                  name="range">
            <Min index="0"
                 value="1" />
            <Max index="0"
                 value="128" />
          </Domain>
        </Property>
      </Proxy>
      <ExposedProperties>
        <Property exposed_name="Consistency"
                  name="Consistency"
                  proxy_name="GenerateSurfaceNormals1" />
        <Property exposed_name="Glyph Max. Points"
                  name="MaximumNumberOfSamplePoints"
                  proxy_name="Glyph1" />
        <Property exposed_name="Glyph Scale Factor"
                  name="ScaleFactor"
                  proxy_name="Glyph1" />
        <Property exposed_name="Input"
                  name="Input"
                  proxy_name="ExtractSurface2" />
        <Property exposed_name="InvertArrow"
                  name="Invert"
                  proxy_name="ArrowSource" />
      </ExposedProperties>
      <OutputPort name="Output"
                  port_index="0"
                  proxy="Glyph1" />

      <!-- FIXME: PropertyGroup doesn't work for compound proxies, it seems.
      <PropertyGroup label="Normals Generator Parameters">
        <Property name="Consistency" />
      </PropertyGroup>
      <PropertyGroup label="Glyph Parameters">
        <Property name="Glyph Max. Points" />
        <Property name="Glyph Scale Factor" />
      </PropertyGroup>
      <PropertyGroup label="Arrow Source Parameters">
        <Property name="InvertArrow" />
      </PropertyGroup>
      -->
      <Hints>
        <!-- Visibility Element can be used to suggest the GUI about
             visibility of this filter (or its input) on creation.
             replace_input="0" implies that the input visibility is not
             changed on creation of this filter (defaults to "1")
             -->
        <Visibility replace_input="0" />
      </Hints>
    </CompoundSourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTableToPolyData"
                 label="Table To Points"
                 name="TableToPolyData">
      <Documentation long_help="Converts table to set of points."
                     short_help="Converts table to set of points.">The
                     TableToPolyData filter converts a vtkTable to a set of
                     points in a vtkPolyData. One must specifies the columns in
                     the input table to use as the X, Y and Z coordinates for
                     the points in the output.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <InputArrayDomain attribute_type="row"
                          name="input_array"
                          number_of_components="1" />
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
        </DataTypeDomain>
        <Documentation>This property specifies the input..</Documentation>
      </InputProperty>
      <StringVectorProperty command="SetXColumn"
                            name="XColumn"
                            number_of_elements="1"
                            panel_visibility="default">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies which data array is going to be
        used as the X coordinate in the generated polydata
        dataset.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetYColumn"
                            name="YColumn"
                            number_of_elements="1"
                            panel_visibility="default">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies which data array is going to be
        used as the Y coordinate in the generated polydata
        dataset.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetZColumn"
                            name="ZColumn"
                            number_of_elements="1"
                            panel_visibility="default">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies which data array is going to be
        used as the Z coordinate in the generated polydata
        dataset.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetCreate2DPoints"
                         default_values="0"
                         label="2D Points"
                         name="Create2DPoints"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether the points of the polydata are 3D or 2D.
        If this is set to true then the Z Column will be ignored and the z
        value of each point on the polydata will be set to 0. By default this
        will be off.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPreserveCoordinateColumnsAsDataArrays"
                         default_values="0"
                         name="KeepAllDataArrays"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Allow user to keep columns specified as X,Y,Z as Data
        arrays. By default this will be off.</Documentation>
      </IntVectorProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkTableToStructuredGrid"
                 label="Table To Structured Grid"
                 name="TableToStructuredGrid">
      <Documentation long_help="Converts to table to structured grid."
                     short_help="Converts to table to structured grid.">The
                     TableToStructuredGrid filter converts a vtkTable to a
                     vtkStructuredGrid. One must specifies the columns in the
                     input table to use as the X, Y and Z coordinates for the
                     points in the output, and the whole
                     extent.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <InputArrayDomain attribute_type="row"
                          name="input_array"
                          number_of_components="1" />
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
        </DataTypeDomain>
        <Documentation>This property specifies the input..</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetWholeExtent"
                         default_values="0 0 0 0 0 0"
                         name="WholeExtent"
                         number_of_elements="6">
        <!--
        <ExtentDomain name="extent">
          <RequiredProperties>
             <Property name="Input" function="Input"/>
          </RequiredProperties>
        </ExtentDomain>
        <Documentation>
          This property gives the minimum and maximum point index (extent) in
          each dimension for the output dataset.
        </Documentation>
        -->
      </IntVectorProperty>
      <StringVectorProperty command="SetXColumn"
                            name="XColumn"
                            number_of_elements="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies which data array is going to be
        used as the X coordinate in the generated polydata
        dataset.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetYColumn"
                            name="YColumn"
                            number_of_elements="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies which data array is going to be
        used as the Y coordinate in the generated polydata
        dataset.</Documentation>
      </StringVectorProperty>
      <StringVectorProperty command="SetZColumn"
                            name="ZColumn"
                            number_of_elements="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property specifies which data array is going to be
        used as the Z coordinate in the generated polydata
        dataset.</Documentation>
      </StringVectorProperty>
    </SourceProxy>
    <!-- ================================================================== -->
    <SourceProxy class="vtkTableFFT"
                 label="Table FFT"
                 name="TableFFT">
      <Documentation>Performs the Fast Fourier Transform on the columns of a
      table.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <InputArrayDomain attribute_type="row"
                          name="input_array"
                          number_of_components="1" />
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the
        filter.</Documentation>
      </InputProperty>
    </SourceProxy>
    <!-- ================================================================== -->
    <CompoundSourceProxy label="FFT Of Selection Over Time"
                         name="FFTSelectionOverTime">
      <Documentation long_help="Extracts selection over time and plots the FFT"
                     short_help="Extracts selection over time and plots the FFT">
                     Extracts the data of a selection (e.g. points or cells)
                     over time, takes the FFT of them, and plots
                     them.</Documentation>
      <Proxy compound_name="PlotSelectionOverTime1"
             group="filters"
             id="734"
             servers="1"
             type="ExtractSelectionOverTime">
        <Property id="734.Input"
                  name="Input"
                  number_of_elements="1">
          <Domain id="734.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="734.Input.input_type"
                  name="input_type">
            <DataType value="vtkDataSet" />
            <DataType value="vtkCompositeDataSet" />
          </Domain>
        </Property>
        <Property id="734.Selection"
                  name="Selection"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="742" />
          <Domain id="734.Selection.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="734.Selection.input_type"
                  name="input_type">
            <DataType value="vtkSelection" />
          </Domain>
        </Property>
        <Property id="734.SetReportStatisticsOnly"
                  name="Only Report Selection Statistics"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="734.SetReportStatisticsOnly.bool"
                  name="bool" />
        </Property>
      </Proxy>
      <Proxy compound_name="TableFFT1"
             group="filters"
             id="812"
             servers="1"
             type="TableFFT">
        <Property id="812.Input"
                  name="Input"
                  number_of_elements="1">
          <Proxy output_port="0"
                 value="734" />
          <Domain id="812.Input.groups"
                  name="groups">
            <Group value="sources" />
            <Group value="filters" />
          </Domain>
          <Domain id="812.Input.input_array"
                  name="input_array">
            <InputArray attribute_type="row"
                        number_of_components="1" />
          </Domain>
          <Domain id="812.Input.input_type"
                  name="input_type">
            <DataType value="vtkTable" />
          </Domain>
        </Property>
      </Proxy>
      <Proxy compound_name="auto_742"
             group="sources"
             id="742"
             servers="1"
             type="CompositeDataIDSelectionSource">
        <Property id="742.ContainingCells"
                  name="ContainingCells"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="742.ContainingCells.bool"
                  name="bool" />
        </Property>
        <Property id="742.FieldType"
                  name="FieldType"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="742.FieldType.enum"
                  name="enum">
            <Entry text="CELL"
                   value="0" />
            <Entry text="POINT"
                   value="1" />
            <Entry text="FIELD"
                   value="2" />
            <Entry text="VERTEX"
                   value="3" />
            <Entry text="EDGE"
                   value="4" />
          </Domain>
        </Property>
        <Property id="742.IDs"
                  name="IDs"
                  number_of_elements="3">
          <Element index="0"
                   value="2" />
          <Element index="1"
                   value="-1" />
          <Element index="2"
                   value="3892" />
        </Property>
        <Property id="742.InsideOut"
                  name="InsideOut"
                  number_of_elements="1">
          <Element index="0"
                   value="0" />
          <Domain id="742.InsideOut.bool"
                  name="bool" />
        </Property>
      </Proxy>
      <ExposedProperties>
        <Property exposed_name="Input"
                  name="Input"
                  proxy_name="PlotSelectionOverTime1" />
        <Property exposed_name="Selection"
                  name="Selection"
                  proxy_name="PlotSelectionOverTime1" />
      </ExposedProperties>
      <OutputPort name="Output"
                  port_index="0"
                  proxy="TableFFT1" />
      <Hints>
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="XYChartView" />
        <Plotable />
      </Hints>
    </CompoundSourceProxy>
    <!-- FFTSelectionOverTime -->
    <!-- ================================================================== -->
    <SourceProxy class="vtkAttributeDataToTableFilter"
                 label="Extract Attributes"
                 name="AttributeDataToTableFilter">
      <Documentation long_help="Extract attribute data as a table."
                     short_help="Extract attribute data as a table.">This is a
                     filter that produces a vtkTable from the chosen attribute
                     in the input data object. This filter can accept composite
                     datasets. If the input is a composite dataset, the output
                     is a multiblock with vtkTable leaves.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>This property specifies the input of the
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetFieldAssociation"
                         default_values="0"
                         name="FieldAssociation"
                         number_of_elements="1">
        <Documentation>Select the attribute data to pass.</Documentation>
        <EnumerationDomain name="enum">
          <Entry text="Points"
                 value="0" />
          <Entry text="Cells"
                 value="1" />
          <Entry text="Field Data"
                 value="2" />
          <Entry text="Vertices"
                 value="4" />
          <Entry text="Edges"
                 value="5" />
          <Entry text="Rows"
                 value="6" />
        </EnumerationDomain>
      </IntVectorProperty>
      <IntVectorProperty command="SetAddMetaData"
                         default_values="0"
                         name="AddMetaData"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>It is possible for this filter to add additional
        meta-data to the field data such as point coordinates (when point
        attributes are selected and input is pointset) or structured
        coordinates etc. To enable this addition of extra information, turn
        this flag on. Off by default.</Documentation>
      </IntVectorProperty>
      <!-- End of AttributeDataToTableFilter -->
    </SourceProxy>
    <!-- ================================================================== -->
    <SourceProxy class="vtkPassThrough"
                 label="Plot Data"
                 name="PlotAttributes">
      <Documentation short_help="Plot data arrays from the input">This filter
      prepare arbitrary data to be plotted in any of the plots. By default the
      data is shown in a XY line plot.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <Documentation>The input.</Documentation>
      </InputProperty>
      <Hints>
        <View type="XYChartView" />
        <Plotable />
      </Hints>
      <!-- End of PlotAttributes -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPSciVizContingencyStats"
                 label="Contingency Statistics"
                 name="ContingencyStatistics">
      <Documentation long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
                     short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model.">
      This filter either computes a statistical model of a dataset or takes
      such a model as its second input. Then, the model (however it is
      obtained) may optionally be used to assess the input dataset. This filter
      computes contingency tables between pairs of attributes. This result is a
      tabular bivariate probability distribution which serves as a
      Bayesian-style prior model. Data is assessed by computing &lt;ul&gt;
      &lt;li&gt; the probability of observing both variables simultaneously;
      &lt;li&gt; the probability of each variable conditioned on the other (the
      two values need not be identical); and &lt;li&gt; the pointwise mutual
      information (PMI). &lt;/ul&gt; Finally, the summary statistics include
      the information entropy of the observations.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
          <DataType value="vtkStructuredGrid" />
          <DataType value="vtkPolyData" />
          <DataType value="vtkUnstructuredGrid" />
          <DataType value="vtkTable" />
          <DataType value="vtkGraph" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>The input to the filter. Arrays from this dataset will
        be used for computing statistics and/or assessed by a statistical
        model.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="ModelInput"
                     null_on_empty="1"
                     port_index="1">
        <Hints>
          <Optional />
          <!-- No input selection dialog at instantiation -->
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>A previously-calculated model with which to assess a
        separate dataset. This input is optional.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetAttributeMode"
                         default_values="0"
                         name="AttributeMode"
                         number_of_elements="1">
        <FieldDataDomain enable_field_data="1"
                         name="enum">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>Specify which type of field data the arrays will be
        drawn from.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearAttributeArrays"
                            command="EnableAttributeArray"
                            label="Variables of Interest"
                            name="SelectArrays"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="FieldDataSelection"
                      name="AttributeMode" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Choose arrays whose entries will be used to form
        observations for statistical analysis.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetTask"
                         default_values="0"
                         name="Task"
                         number_of_elements="1">
        <EnumerationDomain name="task_list">
          <Entry text="Detailed model of input data"
                 value="0" />
          <Entry text="Model a subset of the data"
                 value="1" />
          <Entry text="Assess the data with a model"
                 value="2" />
          <Entry text="Model and assess the same data"
                 value="3" />
        </EnumerationDomain>
        <Documentation>Specify the task to be performed: modeling and/or
        assessment. &lt;ol&gt; &lt;li&gt; "Detailed model of input data,"
        creates a set of output tables containing a calculated statistical
        model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
        &lt;li&gt; "Model a subset of the data," creates an output table (or
        tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the
        input dataset;&lt;/li&gt; &lt;li&gt; "Assess the data with a model,"
        adds attributes to the first input dataset using a model provided on
        the second input port; and&lt;/li&gt; &lt;li&gt; "Model and assess the
        same data," is really just operations 2 and 3 above applied to the same
        input dataset. The model is first trained using a fraction of the input
        data and then the entire dataset is assessed using that
        model.&lt;/li&gt; &lt;/ol&gt; When the task includes creating a model
        (i.e., tasks 2, and 4), you may adjust the fraction of the input
        dataset used for training. You should avoid using a large fraction of
        the input data for training as you will then not be able to detect
        overfitting. The &lt;i&gt;Training fraction&lt;/i&gt; setting will be
        ignored for tasks 1 and 3.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTrainingFraction"
                            default_values="0.1"
                            name="TrainingFraction"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="training_range" />
        <Documentation>Specify the fraction of values from the input dataset to
        be used for model fitting. The exact set of values is chosen at random
        from the dataset.</Documentation>
      </DoubleVectorProperty>
      <OutputPort index="0"
                  name="Statistical Model" />
      <OutputPort index="1"
                  name="Assessed Data" />
      <Hints>
        <Visibility replace_input="1" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="SpreadSheetView" port="0" />
        <View type="None" port="1" />
      </Hints>
    </SourceProxy>
    <!-- ContingencyStatistics -->
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPSciVizDescriptiveStats"
                 label="Descriptive Statistics"
                 name="DescriptiveStatistics">
      <Documentation long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
                     short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model.">
      This filter either computes a statistical model of a dataset or takes
      such a model as its second input. Then, the model (however it is
      obtained) may optionally be used to assess the input dataset.&lt;p&gt;
      This filter computes the min, max, mean, raw moments M2 through M4,
      standard deviation, skewness, and kurtosis for each array you
      select.&lt;p&gt; The model is simply a univariate Gaussian distribution
      with the mean and standard deviation provided. Data is assessed using
      this model by detrending the data (i.e., subtracting the mean) and then
      dividing by the standard deviation. Thus the assessment is an array whose
      entries are the number of standard deviations from the mean that each
      input point lies.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
          <DataType value="vtkStructuredGrid" />
          <DataType value="vtkPolyData" />
          <DataType value="vtkUnstructuredGrid" />
          <DataType value="vtkTable" />
          <DataType value="vtkGraph" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>The input to the filter. Arrays from this dataset will
        be used for computing statistics and/or assessed by a statistical
        model.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="ModelInput"
                     null_on_empty="1"
                     port_index="1">
        <Hints>
          <Optional />
          <!-- No input selection dialog at instantiation -->
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>A previously-calculated model with which to assess a
        separate dataset. This input is optional.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetAttributeMode"
                         default_values="0"
                         name="AttributeMode"
                         number_of_elements="1">
        <FieldDataDomain enable_field_data="1"
                         name="enum">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>Specify which type of field data the arrays will be
        drawn from.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearAttributeArrays"
                            command="EnableAttributeArray"
                            label="Variables of Interest"
                            name="SelectArrays"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="FieldDataSelection"
                      name="AttributeMode" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Choose arrays whose entries will be used to form
        observations for statistical analysis.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetTask"
                         default_values="0"
                         name="Task"
                         number_of_elements="1">
        <EnumerationDomain name="task_list">
          <Entry text="Detailed model of input data"
                 value="0" />
          <Entry text="Model a subset of the data"
                 value="1" />
          <Entry text="Assess the data with a model"
                 value="2" />
          <Entry text="Model and assess the same data"
                 value="3" />
        </EnumerationDomain>
        <Documentation>Specify the task to be performed: modeling and/or
        assessment. &lt;ol&gt; &lt;li&gt; "Detailed model of input data,"
        creates a set of output tables containing a calculated statistical
        model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
        &lt;li&gt; "Model a subset of the data," creates an output table (or
        tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the
        input dataset;&lt;/li&gt; &lt;li&gt; "Assess the data with a model,"
        adds attributes to the first input dataset using a model provided on
        the second input port; and&lt;/li&gt; &lt;li&gt; "Model and assess the
        same data," is really just operations 2 and 3 above applied to the same
        input dataset. The model is first trained using a fraction of the input
        data and then the entire dataset is assessed using that
        model.&lt;/li&gt; &lt;/ol&gt; When the task includes creating a model
        (i.e., tasks 2, and 4), you may adjust the fraction of the input
        dataset used for training. You should avoid using a large fraction of
        the input data for training as you will then not be able to detect
        overfitting. The &lt;i&gt;Training fraction&lt;/i&gt; setting will be
        ignored for tasks 1 and 3.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTrainingFraction"
                            default_values="0.1"
                            name="TrainingFraction"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="training_range" />
        <Documentation>Specify the fraction of values from the input dataset to
        be used for model fitting. The exact set of values is chosen at random
        from the dataset.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetSignedDeviations"
                         default_values="0"
                         label="Deviations should be"
                         name="SignedDeviations"
                         number_of_elements="1">
        <EnumerationDomain name="signed_distance">
          <Entry text="Unsigned"
                 value="0" />
          <Entry text="Signed"
                 value="1" />
        </EnumerationDomain>
        <Documentation>Should the assessed values be signed deviations or
        unsigned?</Documentation>
      </IntVectorProperty>
      <OutputPort index="0"
                  name="Statistical Model" />
      <OutputPort index="1"
                  name="Assessed Data" />
      <Hints>
        <Visibility replace_input="1" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="SpreadSheetView" port="0" />
        <View type="None" port="1" />
      </Hints>
    </SourceProxy>
    <!-- DescriptiveStatistics -->
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPSciVizKMeans"
                 label="K Means"
                 name="KMeans">
      <Documentation long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
                     short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model.">
      This filter either computes a statistical model of a dataset or takes
      such a model as its second input. Then, the model (however it is
      obtained) may optionally be used to assess the input dataset.&lt;p&gt;
      This filter iteratively computes the center of k clusters in a space
      whose coordinates are specified by the arrays you select. The clusters
      are chosen as local minima of the sum of square Euclidean distances from
      each point to its nearest cluster center. The model is then a set of
      cluster centers. Data is assessed by assigning a cluster center and
      distance to the cluster to each point in the input data
      set.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
          <DataType value="vtkStructuredGrid" />
          <DataType value="vtkPolyData" />
          <DataType value="vtkUnstructuredGrid" />
          <DataType value="vtkTable" />
          <DataType value="vtkGraph" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>The input to the filter. Arrays from this dataset will
        be used for computing statistics and/or assessed by a statistical
        model.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="ModelInput"
                     null_on_empty="1"
                     port_index="1">
        <Hints>
          <Optional />
          <!-- No input selection dialog at instantiation -->
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>A previously-calculated model with which to assess a
        separate dataset. This input is optional.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetAttributeMode"
                         default_values="0"
                         name="AttributeMode"
                         number_of_elements="1">
        <FieldDataDomain enable_field_data="1"
                         name="enum">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>Specify which type of field data the arrays will be
        drawn from.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearAttributeArrays"
                            command="EnableAttributeArray"
                            label="Variables of Interest"
                            name="SelectArrays"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="FieldDataSelection"
                      name="AttributeMode" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Choose arrays whose entries will be used to form
        observations for statistical analysis.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetTask"
                         default_values="3"
                         name="Task"
                         number_of_elements="1">
        <EnumerationDomain name="task_list">
          <Entry text="Detailed model of input data"
                 value="0" />
          <Entry text="Model a subset of the data"
                 value="1" />
          <Entry text="Assess the data with a model"
                 value="2" />
          <Entry text="Model and assess the same data"
                 value="3" />
        </EnumerationDomain>
        <Documentation>Specify the task to be performed: modeling and/or
        assessment. &lt;ol&gt; &lt;li&gt; "Detailed model of input data,"
        creates a set of output tables containing a calculated statistical
        model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
        &lt;li&gt; "Model a subset of the data," creates an output table (or
        tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the
        input dataset;&lt;/li&gt; &lt;li&gt; "Assess the data with a model,"
        adds attributes to the first input dataset using a model provided on
        the second input port; and&lt;/li&gt; &lt;li&gt; "Model and assess the
        same data," is really just operations 2 and 3 above applied to the same
        input dataset. The model is first trained using a fraction of the input
        data and then the entire dataset is assessed using that
        model.&lt;/li&gt; &lt;/ol&gt; When the task includes creating a model
        (i.e., tasks 2, and 4), you may adjust the fraction of the input
        dataset used for training. You should avoid using a large fraction of
        the input data for training as you will then not be able to detect
        overfitting. The &lt;i&gt;Training fraction&lt;/i&gt; setting will be
        ignored for tasks 1 and 3.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTrainingFraction"
                            default_values="0.1"
                            name="TrainingFraction"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="training_range" />
        <Documentation>Specify the fraction of values from the input dataset to
        be used for model fitting. The exact set of values is chosen at random
        from the dataset.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetK"
                         default_values="5"
                         label="k"
                         name="K"
                         number_of_elements="1">
        <IntRangeDomain min="1"
                        name="num_cluster_centers" />
        <Documentation>Specify the number of clusters.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetMaxNumIterations"
                         default_values="50"
                         label="Max Iterations"
                         name="MaxNumIterations"
                         number_of_elements="1">
        <IntRangeDomain min="1"
                        name="max_num_iter" />
        <Documentation>Specify the maximum number of iterations in which
        cluster centers are moved before the algorithm
        terminates.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTolerance"
                            default_values="0.01"
                            name="Tolerance"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="cluster_center_tolerance" />
        <Documentation>Specify the relative tolerance that will cause early
        termination.</Documentation>
      </DoubleVectorProperty>
      <OutputPort index="0"
                  name="Statistical Model" />
      <OutputPort index="1"
                  name="Assessed Data" />
      <Hints>
        <Visibility replace_input="1" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="SpreadSheetView" port="0" />
        <View type="None" port="1" />
      </Hints>
    </SourceProxy>
    <!-- K Means -->
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPSciVizMultiCorrelativeStats"
                 label="Multicorrelative Statistics"
                 name="MulticorrelativeStatistics">
      <Documentation long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
                     short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model.">
      This filter either computes a statistical model of a dataset or takes
      such a model as its second input. Then, the model (however it is
      obtained) may optionally be used to assess the input dataset.&lt;p&gt;
      This filter computes the covariance matrix for all the arrays you select
      plus the mean of each array. The model is thus a multivariate Gaussian
      distribution with the mean vector and variances provided. Data is
      assessed using this model by computing the Mahalanobis distance for each
      input point. This distance will always be positive.&lt;p&gt; The learned
      model output format is rather dense and can be confusing, so it is
      discussed here. The first filter output is a multiblock dataset
      consisting of 2 tables: &lt;ol&gt; &lt;li&gt; Raw covariance data.
      &lt;li&gt; Covariance matrix and its Cholesky decomposition. &lt;/ol&gt;
      The raw covariance table has 3 meaningful columns: 2 titled "Column1" and
      "Column2" whose entries generally refer to the N arrays you selected when
      preparing the filter and 1 column titled "Entries" that contains numeric
      values. The first row will always contain the number of observations in
      the statistical analysis. The next N rows contain the mean for each of
      the N arrays you selected. The remaining rows contain covariances of
      pairs of arrays.&lt;p&gt; The second table (covariance matrix and
      Cholesky decomposition) contains information derived from the raw
      covariance data of the first table. The first N rows of the first column
      contain the name of one array you selected for analysis. These rows are
      followed by a single entry labeled "Cholesky" for a total of N+1 rows.
      The second column, Mean contains the mean of each variable in the first N
      entries and the number of observations processed in the final (N+1)
      row.&lt;p&gt; The remaining columns (there are N, one for each array)
      contain 2 matrices in triangular format. The upper right triangle
      contains the covariance matrix (which is symmetric, so its lower triangle
      may be inferred). The lower left triangle contains the Cholesky
      decomposition of the covariance matrix (which is triangular, so its upper
      triangle is zero). Because the diagonal must be stored for both matrices,
      an additional row is required &#226;&#8364;&#8221; hence the N+1 rows and
      the final entry of the column named "Column".</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
          <DataType value="vtkStructuredGrid" />
          <DataType value="vtkPolyData" />
          <DataType value="vtkUnstructuredGrid" />
          <DataType value="vtkTable" />
          <DataType value="vtkGraph" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>The input to the filter. Arrays from this dataset will
        be used for computing statistics and/or assessed by a statistical
        model.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="ModelInput"
                     null_on_empty="1"
                     port_index="1">
        <Hints>
          <Optional />
          <!-- No input selection dialog at instantiation -->
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>A previously-calculated model with which to assess a
        separate dataset. This input is optional.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetAttributeMode"
                         default_values="0"
                         name="AttributeMode"
                         number_of_elements="1">
        <FieldDataDomain enable_field_data="1"
                         name="enum">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>Specify which type of field data the arrays will be
        drawn from.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearAttributeArrays"
                            command="EnableAttributeArray"
                            label="Variables of Interest"
                            name="SelectArrays"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="FieldDataSelection"
                      name="AttributeMode" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Choose arrays whose entries will be used to form
        observations for statistical analysis.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetTask"
                         default_values="3"
                         name="Task"
                         number_of_elements="1">
        <EnumerationDomain name="task_list">
          <Entry text="Detailed model of input data"
                 value="0" />
          <Entry text="Model a subset of the data"
                 value="1" />
          <Entry text="Assess the data with a model"
                 value="2" />
          <Entry text="Model and assess the same data"
                 value="3" />
        </EnumerationDomain>
        <Documentation>Specify the task to be performed: modeling and/or
        assessment. &lt;ol&gt; &lt;li&gt; "Detailed model of input data,"
        creates a set of output tables containing a calculated statistical
        model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
        &lt;li&gt; "Model a subset of the data," creates an output table (or
        tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the
        input dataset;&lt;/li&gt; &lt;li&gt; "Assess the data with a model,"
        adds attributes to the first input dataset using a model provided on
        the second input port; and&lt;/li&gt; &lt;li&gt; "Model and assess the
        same data," is really just operations 2 and 3 above applied to the same
        input dataset. The model is first trained using a fraction of the input
        data and then the entire dataset is assessed using that
        model.&lt;/li&gt; &lt;/ol&gt; When the task includes creating a model
        (i.e., tasks 2, and 4), you may adjust the fraction of the input
        dataset used for training. You should avoid using a large fraction of
        the input data for training as you will then not be able to detect
        overfitting. The &lt;i&gt;Training fraction&lt;/i&gt; setting will be
        ignored for tasks 1 and 3.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTrainingFraction"
                            default_values="0.1"
                            name="TrainingFraction"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="training_range" />
        <Documentation>Specify the fraction of values from the input dataset to
        be used for model fitting. The exact set of values is chosen at random
        from the dataset.</Documentation>
      </DoubleVectorProperty>
      <OutputPort index="0"
                  name="Statistical Model" />
      <OutputPort index="1"
                  name="Assessed Data" />
      <Hints>
        <Visibility replace_input="1" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="SpreadSheetView" port="0" />
        <View type="None" port="1" />
      </Hints>
    </SourceProxy>
    <!-- MulticorrelativeStatistics -->
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPSciVizPCAStats"
                 label="Principal Component Analysis"
                 name="PCAStatistics">
      <Documentation long_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model."
                     short_help="Compute a statistical model of a dataset and/or assess the dataset with a statistical model.">
      This filter either computes a statistical model of a dataset or takes
      such a model as its second input. Then, the model (however it is
      obtained) may optionally be used to assess the input dataset. &lt;p&gt;
      This filter performs additional analysis above and beyond the
      multicorrelative filter. It computes the eigenvalues and eigenvectors of
      the covariance matrix from the multicorrelative filter. Data is then
      assessed by projecting the original tuples into a possibly
      lower-dimensional space. &lt;p&gt; Since the PCA filter uses the
      multicorrelative filter's analysis, it shares the same raw covariance
      table specified in the multicorrelative documentation. The second table
      in the multiblock dataset comprising the model output is an expanded
      version of the multicorrelative version. &lt;p&gt; As with the
      multicorrelative filter, the second model table contains the mean values,
      the upper-triangular portion of the symmetric covariance matrix, and the
      non-zero lower-triangular portion of the Cholesky decomposition of the
      covariance matrix. Below these entries are the eigenvalues of the
      covariance matrix (in the column labeled "Mean") and the eigenvectors (as
      row vectors) in an additional NxN matrix.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
          <DataType value="vtkRectilinearGrid" />
          <DataType value="vtkStructuredGrid" />
          <DataType value="vtkPolyData" />
          <DataType value="vtkUnstructuredGrid" />
          <DataType value="vtkTable" />
          <DataType value="vtkGraph" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array" />
        <Documentation>The input to the filter. Arrays from this dataset will
        be used for computing statistics and/or assessed by a statistical
        model.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection"
                     name="ModelInput"
                     null_on_empty="1"
                     port_index="1">
        <Hints>
          <Optional />
          <!-- No input selection dialog at instantiation -->
        </Hints>
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkTable" />
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>A previously-calculated model with which to assess a
        separate dataset. This input is optional.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetAttributeMode"
                         default_values="0"
                         name="AttributeMode"
                         number_of_elements="1">
        <FieldDataDomain enable_field_data="1"
                         name="enum">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </FieldDataDomain>
        <Documentation>Specify which type of field data the arrays will be
        drawn from.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty clean_command="ClearAttributeArrays"
                            command="EnableAttributeArray"
                            label="Variables of Interest"
                            name="SelectArrays"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
            <Property function="FieldDataSelection"
                      name="AttributeMode" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Choose arrays whose entries will be used to form
        observations for statistical analysis.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty animateable="0"
                         command="SetTask"
                         default_values="3"
                         name="Task"
                         number_of_elements="1">
        <EnumerationDomain name="task_list">
          <Entry text="Detailed model of input data"
                 value="0" />
          <Entry text="Model a subset of the data"
                 value="1" />
          <Entry text="Assess the data with a model"
                 value="2" />
          <Entry text="Model and assess the same data"
                 value="3" />
        </EnumerationDomain>
        <Documentation>Specify the task to be performed: modeling and/or
        assessment. &lt;ol&gt; &lt;li&gt; "Detailed model of input data,"
        creates a set of output tables containing a calculated statistical
        model of the &lt;b&gt;entire&lt;/b&gt; input dataset;&lt;/li&gt;
        &lt;li&gt; "Model a subset of the data," creates an output table (or
        tables) summarizing a &lt;b&gt;randomly-chosen subset&lt;/b&gt; of the
        input dataset;&lt;/li&gt; &lt;li&gt; "Assess the data with a model,"
        adds attributes to the first input dataset using a model provided on
        the second input port; and&lt;/li&gt; &lt;li&gt; "Model and assess the
        same data," is really just operations 2 and 3 above applied to the same
        input dataset. The model is first trained using a fraction of the input
        data and then the entire dataset is assessed using that
        model.&lt;/li&gt; &lt;/ol&gt; When the task includes creating a model
        (i.e., tasks 2, and 4), you may adjust the fraction of the input
        dataset used for training. You should avoid using a large fraction of
        the input data for training as you will then not be able to detect
        overfitting. The &lt;i&gt;Training fraction&lt;/i&gt; setting will be
        ignored for tasks 1 and 3.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetTrainingFraction"
                            default_values="0.1"
                            name="TrainingFraction"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="training_range" />
        <Documentation>Specify the fraction of values from the input dataset to
        be used for model fitting. The exact set of values is chosen at random
        from the dataset.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetNormalizationScheme"
                         default_values="2"
                         label="Normalization Scheme"
                         name="NormalizationScheme"
                         number_of_elements="1">
        <EnumerationDomain name="norm_scheme">
          <Entry text="No normalization"
                 value="0" />
          <Entry text="Normalize using covariances"
                 value="3" />
        </EnumerationDomain>
        <Documentation>Before the eigenvector decomposition of the covariance
        matrix takes place, you may normalize each (i,j) entry by sqrt(
        cov(i,i) * cov(j,j) ). This implies that the variance of each variable
        of interest should be of equal importance.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetBasisScheme"
                         default_values="0"
                         label="Basis Scheme"
                         name="BasisScheme"
                         number_of_elements="1">
        <EnumerationDomain name="basis_scheme">
          <Entry text="Full basis"
                 value="0" />
          <Entry text="Fixed-size basis"
                 value="1" />
          <Entry text="Fixed-energy basis"
                 value="2" />
        </EnumerationDomain>
        <Documentation>When reporting assessments, should the full eigenvector
        decomposition be used to project the original vector into the new space
        (Full basis), or should a fixed subset of the decomposition be used
        (Fixed-size basis), or should the projection be clipped to preserve at
        least some fixed "energy" (Fixed-energy basis)?&lt;p&gt; As an example,
        suppose the variables of interest were {A,B,C,D,E} and that the
        eigenvalues of the covariance matrix for these were {5,2,1.5,1,.5}. If
        the "Full basis" scheme is used, then all 5 components of the
        eigenvectors will be used to project each {A,B,C,D,E}-tuple in the
        original data into a new 5-components space.&lt;p&gt; If the
        "Fixed-size" scheme is used and the "Basis Size" property is set to 4,
        then only the first 4 eigenvector components will be used to project
        each {A,B,C,D,E}-tuple into the new space and that space will be of
        dimension 4, not 5.&lt;p&gt; If the "Fixed-energy basis" scheme is used
        and the "Basis Energy" property is set to 0.8, then only the first 3
        eigenvector components will be used to project each {A,B,C,D,E}-tuple
        into the new space, which will be of dimension 3. The number 3 is
        chosen because 3 is the lowest N for which the sum of the first N
        eigenvalues divided by the sum of all eigenvalues is larger than the
        specified "Basis Energy" (i.e., (5+2+1.5)/10 = 0.85 &gt;
        0.8).</Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="SetFixedBasisSize"
                         default_values="2"
                         label="Basis Size"
                         name="BasisSize"
                         number_of_elements="1">
        <IntRangeDomain min="1"
                        name="basis_size_range" />
        <Documentation>The maximum number of eigenvector components to use when
        projecting into the new space.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty animateable="1"
                            command="SetFixedBasisEnergy"
                            default_values="0.1"
                            label="Basis Energy"
                            name="BasisEnergy"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="basis_energy_range" />
        <Documentation>The minimum energy to use when determining the
        dimensionality of the new space into which the assessment will project
        tuples.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetRobustPCA"
                         default_values="0"
                         name="RobustPCA"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute robust PCA with medians instead of means.</Documentation>
      </IntVectorProperty>
      <OutputPort index="0"
                  name="Statistical Model" />
      <OutputPort index="1"
                  name="Assessed Data" />
      <Hints>
        <Visibility replace_input="1" />
        <!-- View can be used to specify the preferred view for the proxy -->
        <View type="SpreadSheetView" port="0" />
        <View type="None" port="1" />
      </Hints>
    </SourceProxy>
    <!-- PCAStatistics -->

    <!-- ==================================================================== -->
    <SourceProxy class="vtkMaterialInterfaceFilter"
                 label="Material Interface Filter"
                 name="MaterialInterfaceFilter">
      <Documentation long_help="The Material Interface filter finds volumes in the input data containing material above a certain material fraction."
                     short_help="The Material Interface filter finds volumes in the input data containing material above a certain material fraction.">
      The Material Interface filter finds voxels inside of which a material
      fraction (or normalized amount of material) is higher than a given
      threshold. As these voxels are identified surfaces enclosing adjacent
      voxels above the threshold are generated. The resulting volume and its
      surface are what we call a fragment. The filter has the ability to
      compute various volumetric attributes such as fragment volume, mass,
      center of mass as well as volume and mass weighted averages for any of
      the fields present. Any field selected for such computation will be also
      be copied into the fragment surface's point data for visualization. The
      filter also has the ability to generate Oriented Bounding Boxes (OBB) for
      each fragment. The data generated by the filter is organized in three
      outputs. The "geometry" output, containing the fragment surfaces. The
      "statistics" output, containing a point set of the centers of mass. The
      "obb representation" output, containing OBB representations (poly data).
      All computed attributes are copied into the statistics and geometry
      output. The obb representation output is used for validation and
      debugging purposes and is turned off by default. To measure the size of
      craters, the filter can invert a volume fraction and clip the volume
      fraction with a sphere and/or a plane.</Documentation>
      <OutputPort index="0"
                  name="geometry" />
      <OutputPort index="1"
                  name="statistics" />
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkNonOverlappingAMR" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array" />
        <Documentation>Input to the filter can be a hierarchical box data set
        containing image data or a multiblock of rectilinear
        grids.</Documentation>
      </InputProperty>
      <!-- Material Fraction Array-->
      <StringVectorProperty clean_command="UnselectAllMaterialArrays"
                            command="SelectMaterialArray"
                            label="Select Material Fraction Arrays"
                            name="SelectMaterialArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <!-- <NoDefault /> -->
        </Hints>
        <Documentation>Material fraction is defined as normalized amount of
        material per voxel. It is expected that arrays containing material
        fraction data has been down converted to a unsigned
        char.</Documentation>
      </StringVectorProperty>
      <!-- Material fraction -->
      <DoubleVectorProperty command="SetMaterialFractionThreshold"
                            default_values="0.5"
                            label="Material Fraction Threshold"
                            name="MaterialFractionThreshold"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0.08"
                           name="range" />
        <Documentation>Material fraction is defined as normalized amount of
        material per voxel. Any voxel in the input data set with a material
        fraction greater than this value is included in the output data
        set.</Documentation>
      </DoubleVectorProperty>
      <!-- Invert the volume fraction -->
      <IntVectorProperty command="SetInvertVolumeFraction"
                         default_values="0"
                         name="InvertVolumeFraction"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Inverting the volume fraction generates the negative of
        the material. It is useful for analyzing craters.</Documentation>
      </IntVectorProperty>
      <ProxyProperty command="SetClipFunction"
                     label="Clip Type"
                     name="ClipFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="None" />
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
        </ProxyListDomain>
        <Documentation>This property sets the type of clip geometry, and
        associated parameters.</Documentation>
      </ProxyProperty>
      <!-- Mass Array-->
      <StringVectorProperty clean_command="UnselectAllMassArrays"
                            command="SelectMassArray"
                            label="Select Mass Arrays"
                            name="SelectMassArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_FLOAT VTK_DOUBLE"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <NoDefault />
        </Hints>
        <Documentation>Mass arrays are paired with material fraction arrays.
        This means that the first selected material fraction array is paired
        with the first selected mass array, and so on sequentially. As the
        filter identifies voxels meeting the minimum material fraction
        threshold, these voxel's mass will be used in fragment center of mass
        and mass calculation. A warning is generated if no mass array is
        selected for an individual material fraction array. However, in that
        case the filter will run without issue because the statistics output
        can be generated using fragments' centers computed from axis aligned
        bounding boxes.</Documentation>
      </StringVectorProperty>
      <!-- Volume weighted average Array -->
      <StringVectorProperty clean_command="UnselectAllVolumeWtdAvgArrays"
                            command="SelectVolumeWtdAvgArray"
                            label="Compute volume weighted average over:"
                            name="SelectVolumeWtdAvgArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>Specifies the arrays from which to volume weighted
        average.</Documentation>
        <ArrayListDomain data_type="VTK_FLOAT VTK_DOUBLE"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <NoDefault />
        </Hints>
        <Documentation>For arrays selected a volume weighted average is
        computed. The values of these arrays are also copied into fragment
        geometry cell data as the fragment surfaces are
        generated.</Documentation>
      </StringVectorProperty>
      <!-- Mass weighted average Array -->
      <StringVectorProperty clean_command="UnselectAllMassWtdAvgArrays"
                            command="SelectMassWtdAvgArray"
                            label="Compute mass weighted average over:"
                            name="SelectMassWtdAvgArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain data_type="VTK_FLOAT VTK_DOUBLE"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <NoDefault />
        </Hints>
        <Documentation>For arrays selected a mass weighted average is computed.
        These arrays are also copied into fragment geometry cell data as the
        fragment surfaces are generated.</Documentation>
      </StringVectorProperty>
      <!-- do not remove -->
      <!-- Summation Array
     <StringVectorProperty
       name="SelectSummationArray"
       command="SelectSummationArray"
       clean_command="UnselectAllSummationArrays"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Compute summation over:">
       <Documentation>
         Specifies the arrays from which to sum over fragments.
       </Documentation>

       <ArrayListDomain
         name="array_list"
         data_type="VTK_FLOAT VTK_DOUBLE">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <NoDefault />
       </Hints>
     </StringVectorProperty>-->
      <!-- Compute OBB -->
      <IntVectorProperty command="SetComputeOBB"
                         default_values="0"
                         name="ComputeOBB"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute Object Oriented Bounding boxes (OBB). When
        active the result of this computation is copied into the statistics
        output. In the case that the filter is built in its validation mode,
        the OBB's are rendered.</Documentation>
      </IntVectorProperty>
      <!-- Write a csv file:
          This is not an excel compatible file, it has more
          information that is stored in headers. Also commas
          are used on tuple boundaries while spaces are used
          on component boundaries.-->
      <IntVectorProperty command="SetWriteGeometryOutput"
                         default_values="0"
                         name="WriteGeometryOutput"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set, then the geometry output is
        written to a text file. The file name will be constructed using the
        path in the "Output Base Name" widget.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetWriteStatisticsOutput"
                         default_values="0"
                         name="WriteStatisticsOutput"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set, then the statistics output is
        written to a text file. The file name will be constructed using the
        path in the "Output Base Name" widget.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty animateable="0"
                            command="SetOutputBaseName"
                            name="OutputBaseName"
                            number_of_elements="1">
        <Documentation>This property specifies the base including path of where
        to write the statistics and geometry output text files. It follows the
        pattern "/path/to/folder/and/file" here file has no extension, as the
        filter will generate a unique extension.</Documentation>
      </StringVectorProperty>
      <!-- do not remove
      this is a feature that most users should not
      need. If memory usage becomes a problem then
      this gives the user more control over excluding
      highly loaded processes from memory intesive operations. -->
      <!-- loading bounds
     <IntVectorProperty
       name="UpperLoadingBound"
       command="SetUpperLoadingBound"
       number_of_elements="1"
       default_values="-1"
       label="Loading Bound">
       <DoubleRangeDomain name="range" min="-1" max="2000000000" />
       <Documentation>
         Bound in polygons above which process are excluded from work sharing.
       </Documentation>
     </IntVectorProperty>-->
      <!-- End MaterialInterfaceFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkSliceAlongPolyPlane"
                 label="Slice Along PolyLine"
                 name="SliceAlongPolyLine">
      <Documentation
        long_help="Slice along the surface defined by sweeping a polyline parallel to the z-axis."
        short_help="Slice along the surface defined by sweeping a polyline parallel to the z-axis.">
        The Slice Along PolyLine filter is similar to the Slice Filter except that it slices along a surface that
        is defined by sweeping the input polyline parallel to the z-axis.  Explained another way: take a laser
        cutter and move it so that it hits every point on the input polyline while keeping it parallel
        to the z-axis. The surface cut from the input dataset is the result.
      </Documentation>
      <InputProperty command="SetInputConnection" name="Dataset" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>
          Set the vtkDataObject to slice.
        </Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection" name="PolyLine" port_index="1">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>
          Set the polyline to slice along.
        </Documentation>
      </InputProperty>
      <DoubleVectorProperty animatable="0"
                            command="SetTolerance"
                            default_values="10"
                            label="Tolerance"
                            name="Tolerance"
                            number_of_elements="1">
        <BoundsDomain mode="approximate_cell_length"
                      name="bounds">
          <RequiredProperties>
            <Property function="Input" name="Dataset" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          The threshold used internally to determine correspondence between the polyline
          and the output slice.  If the output has sections missing, increasing this
          value may help.
        </Documentation>
      </DoubleVectorProperty>
      <!-- End Slice Along PolyLine -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkIntersectFragments"
                 label="Intersect Fragments"
                 name="IntersectFragments">
      <Documentation long_help="The Intersect Fragments filter perform geometric intersections on sets of fragments."
                     short_help="The Intersect Fragments filter perform geometric intersections on sets of fragments.">
      The Intersect Fragments filter perform geometric intersections on sets of
      fragments. The filter takes two inputs, the first containing fragment
      geometry and the second containing fragment centers. The filter has two
      outputs. The first is geometry that results from the intersection. The
      second is a set of points that is an approximation of the center of where
      each fragment has been intersected.</Documentation>
      <!-- Out -->
      <OutputPort index="0"
                  name="geometry" />
      <OutputPort index="1"
                  name="statistics" />
      <!-- In -->
      <InputProperty command="SetGeometryInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>This input must contain fragment
        geometry.</Documentation>
      </InputProperty>
      <InputProperty command="SetStatisticsInputConnection"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>This input must contain fragment
        centers.</Documentation>
      </InputProperty>
      <!-- Cut functuion -->
      <ProxyProperty command="SetCutFunction"
                     label="Slice Type"
                     name="CutFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
        </ProxyListDomain>
        <Documentation>This property sets the type of intersecting geometry,
        and associated parameters.</Documentation>
      </ProxyProperty>
      <!-- End IntersectFragments -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkGaussianSplatter"
                 label="Gaussian Resampling"
                 name="GaussianSplatter">
      <Documentation long_help="Splat points into a volume with an elliptical, Gaussian distribution."
                     short_help="Point to voxel splatter.">vtkGaussianSplatter
                     is a filter that injects input points into a structured
                     points (volume) dataset. As each point is injected, it
                     "splats" or distributes values to nearby voxels. Data is
                     distributed using an elliptical, Gaussian distribution
                     function. The distribution function is modified using
                     scalar values (expands distribution) or normals (creates
                     ellipsoidal distribution rather than spherical). Warning:
                     results may be incorrect in parallel as points can't splat
                     into other processor's cells.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1" />
        <Documentation>This property specifies the input to the
        filter.</Documentation>
      </InputProperty>
      <StringVectorProperty animateable="0"
                            command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Resample Field"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list"
                         none_string="ignore arrays">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Choose a scalar array to splat into the output cells. If
        ignore arrays is chosen, point density will be counted
        instead.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetSampleDimensions"
                         default_values="50 50 50"
                         label="Resampling Grid"
                         name="SampleDimensions"
                         number_of_elements="3">
        <IntRangeDomain name="range" />
        <Documentation>Set / get the dimensions of the sampling structured
        point set. Higher values produce better results but are much
        slower.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetModelBounds"
                            default_values="0.0 0.0 0.0 0.0 0.0 0.0"
                            label="Extent to Resample"
                            name="ModelBounds"
                            number_of_elements="6">
        <DoubleRangeDomain name="range" />
        <Documentation>Set / get the (xmin,xmax, ymin,ymax, zmin,zmax) bounding
        box in which the sampling is performed. If any of the (min,max) bounds
        values are min &gt;= max, then the bounds will be computed
        automatically from the input data. Otherwise, the user-specified bounds
        will be used.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetRadius"
                            default_values="0.1"
                            label="Gaussian Splat Radius"
                            name="Radius"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Set / get the radius of propagation of the splat. This
        value is expressed as a percentage of the length of the longest side of
        the sampling volume. Smaller numbers greatly reduce execution
        time.</Documentation>
      </DoubleVectorProperty>
      <DoubleVectorProperty command="SetExponentFactor"
                            default_values="-5.0"
                            label="Gaussian Exponent Factor"
                            name="ExponentFactor"
                            number_of_elements="1">
        <DoubleRangeDomain max="0.0"
                           name="range" />
        <Documentation>Set / get the sharpness of decay of the splats. This is
        the exponent constant in the Gaussian equation. Normally this is a
        negative value.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetScalarWarping"
                         default_values="1"
                         label="Scale Splats"
                         name="ScalarWarping"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Turn on/off the scaling of splats by scalar
        value.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetScaleFactor"
                            default_values="1.0"
                            label="Scale Factor"
                            name="ScaleFactor"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Multiply Gaussian splat distribution by this value. If
        ScalarWarping is on, then the Scalar value will be multiplied by the
        ScaleFactor times the Gaussian function.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetNormalWarping"
                         default_values="1"
                         label="Elliptical Splats"
                         name="NormalWarping"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Turn on/off the generation of elliptical splats. If
        normal warping is on, then the input normals affect the distribution of
        the splat. This boolean is used in combination with the Eccentricity
        ivar.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetEccentricity"
                            default_values="2.5"
                            label="Ellipitical Eccentricity"
                            name="Eccentricity"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Control the shape of elliptical splatting. Eccentricity
        is the ratio of the major axis (aligned along normal) to the minor
        (axes) aligned along other two axes. So Eccentricity gt 1 creates
        needles with the long axis in the direction of the normal; Eccentricity
        lt 1 creates pancakes perpendicular to the normal
        vector.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetCapping"
                         default_values="1"
                         label="Fill Volume Boundary"
                         name="Capping"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Turn on/off the capping of the outer boundary of the
        volume to a specified cap value. This can be used to close surfaces
        (after isosurfacing) and create other effects.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetCapValue"
                            default_values="0.0"
                            label="Fill Value"
                            name="CapValue"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Specify the cap value to use. (This instance variable
        only has effect if the ivar Capping is on.)</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetAccumulationMode"
                         default_values="1"
                         label="Splat Accumulation Mode"
                         name="Accumulation Mode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Min"
                 value="0" />
          <Entry text="Max"
                 value="1" />
          <Entry text="Sum"
                 value="2" />
        </EnumerationDomain>
        <Documentation>Specify the scalar accumulation mode. This mode
        expresses how scalar values are combined when splats are overlapped.
        The Max mode acts like a set union operation and is the most commonly
        used; the Min mode acts like a set intersection, and the sum is just
        weird.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetNullValue"
                            default_values="0.0"
                            label="Empty Cell Value"
                            name="NullValue"
                            number_of_elements="1">
        <DoubleRangeDomain name="range" />
        <Documentation>Set the Null value for output points not receiving a
        contribution from the input points. (This is the initial value of the
        voxel samples.)</Documentation>
      </DoubleVectorProperty>
      <!-- End of GaussianSplatter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkYoungsMaterialInterface"
                 label="Youngs Material Interface"
                 name="YoungsMaterialInterface">
      <Documentation long_help="Computes linear material interfaces in 2D or 3D mixed cells produced by eulerian or ALE simulation codes"
                     short_help="Youngs material interface reconstruction">
                     Computes linear material interfaces in 2D or 3D mixed
                     cells produced by Eulerian or ALE simulation
                     codes</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array1"
                          number_of_components="1"></InputArrayDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array3"
                          number_of_components="3"
                          optional="1"></InputArrayDomain>
      </InputProperty>
      <IntVectorProperty command="SetInverseNormal"
                         default_values="0"
                         name="InverseNormal"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetReverseMaterialOrder"
                         default_values="0"
                         name="ReverseMaterialOrder"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetOnionPeel"
                         default_values="1"
                         name="OnionPeel"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetAxisSymetric"
                         default_values="1"
                         name="AxisSymetric"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetFillMaterial"
                         default_values="1"
                         name="FillMaterial"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetUseFractionAsDistance"
                         default_values="0"
                         name="UseFractionAsDistance"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <DoubleVectorProperty command="SetVolumeFractionRange"
                            default_values="0.01 0.99"
                            name="VolumeFractionRange"
                            number_of_elements="2">
        <DoubleRangeDomain max="1"
                           min="0"
                           name="range" />
      </DoubleVectorProperty>
      <IntVectorProperty command="GetNumberOfDomains"
                         information_only="1"
                         name="NumberOfDomainsInformation">
        <SimpleIntInformationHelper />
      </IntVectorProperty>
      <StringVectorProperty command="SetMaterialVolumeFractionArray"
                            name="VolumeFractionArrays"
                            repeat_command="1"
                            set_number_command="SetNumberOfMaterials"
                            use_index="1">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array1"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
      </StringVectorProperty>
      <StringVectorProperty command="SetMaterialNormalArray"
                            element_types="2 2"
                            name="NormalArrays"
                            number_of_elements_per_command="2"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Vectors"
                         input_domain_name="input_array3"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
      </StringVectorProperty>
      <StringVectorProperty command="SetMaterialOrderingArray"
                            element_types="2 2"
                            name="OrderingArrays"
                            number_of_elements_per_command="2"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array1"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <NoDefault />
        </Hints>
      </StringVectorProperty>
      <PropertyGroup panel_widget="YoungsMaterial">
        <Property name="VolumeFractionArrays" function="VolumeFractionArrays" />
        <Property name="OrderingArrays" function="OrderingArrays" />
        <Property name="NormalArrays" function="NormalArrays" />
      </PropertyGroup>
      <!-- End of YoungsMaterialInterface -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPassSelectedArrays" name="PassArrays">
      <Documentation long_help="Pass specified point and cell data arrays."
                     short_help="Pass specified point and cell data arrays.">
                     The Pass Arrays filter makes a shallow copy of the output
                     data object from the input data object except for passing
                     only the arrays specified to the output from the
                     input.
      </Documentation>
      <InputProperty command="SetInputConnection" name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
        <InputArrayDomain name="point_arrays" attribute_type="point" optional="1" />
        <InputArrayDomain name="cell_arrays" attribute_type="cell" optional="1" />
        <InputArrayDomain name="field_arrays" attribute_type="field" optional="1" />
        <InputArrayDomain name="vertex_arrays" attribute_type="vertex" optional="1" />
        <InputArrayDomain name="edge_arrays" attribute_type="edge" optional="1" />
        <InputArrayDomain name="row_arrays" attribute_type="row" optional="1" />
      </InputProperty>

      <StringVectorProperty
          name="PointDataArrays"
          command="GetPointDataArraySelection"
          number_of_elements_per_command="1"
          repeat_command="1"
          si_class="vtkSIDataArraySelectionProperty">
          <ArrayListDomain name="array_list" input_domain_name="point_arrays">
            <RequiredProperties>
              <Property name="Input" function="Input" />
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the point data arrays to pass through
          </Documentation>
          <Hints>
            <ArraySelectionWidget icon_type="point"/>
          </Hints>
      </StringVectorProperty>
      <StringVectorProperty
          name="CellDataArrays"
          command="GetCellDataArraySelection"
          number_of_elements_per_command="1"
          repeat_command="1"
          si_class="vtkSIDataArraySelectionProperty">
          <ArrayListDomain name="array_list" input_domain_name="cell_arrays">
            <RequiredProperties>
              <Property name="Input" function="Input" />
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the cell data arrays to pass through
          </Documentation>
          <Hints>
            <ArraySelectionWidget icon_type="cell"/>
          </Hints>
      </StringVectorProperty>
      <StringVectorProperty
          name="FieldDataArrays"
          command="GetFieldDataArraySelection"
          number_of_elements_per_command="1"
          repeat_command="1"
          si_class="vtkSIDataArraySelectionProperty">
          <ArrayListDomain name="array_list" input_domain_name="field_arrays">
            <RequiredProperties>
              <Property name="Input" function="Input" />
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the field data arrays to pass through
          </Documentation>
          <Hints>
            <ArraySelectionWidget icon_type="field"/>
          </Hints>
      </StringVectorProperty>
      <StringVectorProperty
          name="VertexDataArrays"
          command="GetVertexDataArraySelection"
          number_of_elements_per_command="1"
          repeat_command="1"
          si_class="vtkSIDataArraySelectionProperty">
          <ArrayListDomain name="array_list" input_domain_name="vertex_arrays">
            <RequiredProperties>
              <Property name="Input" function="Input" />
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the vertex data arrays to pass through
          </Documentation>
          <Hints>
            <ArraySelectionWidget icon_type="vertex"/>
          </Hints>
      </StringVectorProperty>
      <StringVectorProperty
          name="EdgeDataArrays"
          command="GetEdgeDataArraySelection"
          number_of_elements_per_command="1"
          repeat_command="1"
          si_class="vtkSIDataArraySelectionProperty">
          <ArrayListDomain name="array_list" input_domain_name="edge_arrays">
            <RequiredProperties>
              <Property name="Input" function="Input" />
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the edge data arrays to pass through
          </Documentation>
          <Hints>
            <ArraySelectionWidget icon_type="edge"/>
          </Hints>
      </StringVectorProperty>
      <StringVectorProperty
          name="RowDataArrays"
          command="GetRowDataArraySelection"
          number_of_elements_per_command="1"
          repeat_command="1"
          si_class="vtkSIDataArraySelectionProperty">
          <ArrayListDomain name="array_list" input_domain_name="row_arrays">
            <RequiredProperties>
              <Property name="Input" function="Input" />
            </RequiredProperties>
          </ArrayListDomain>
          <Documentation>
            Select the row data arrays to pass through
          </Documentation>
          <Hints>
            <ArraySelectionWidget icon_type="row"/>
          </Hints>
      </StringVectorProperty>
    </SourceProxy>

    <SourceProxy class="vtkImageToAMR"
                 label="Image Data To AMR"
                 name="ImageDataToAMR">
      <Documentation long_help="Converts certain images to AMR."
                     short_help="Convert ImageData to AMR. ">
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
        </DataTypeDomain>
        <Documentation>
          This property specifies the input to the Cell Data to
          Point Data filter.
        </Documentation>
      </InputProperty>

      <IntVectorProperty command="SetNumberOfLevels"
                         default_values="2"
                         label="Number of levels"
                         name="NumberOfLevels"
                         number_of_elements="1">
        <IntRangeDomain max="20"
                        min="1"
                        name="range" />
        <Documentation>
          This property specifies the number of levels in the AMR data structure.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMaximumNumberOfBlocks"
                         default_values="100"
                         label="Maximum Number of Blocks"
                         name="MaximumNumberOfLevels"
                         number_of_elements="1">
        <IntRangeDomain max="100000"
                        min="1"
                        name="range" />
        <Documentation>
          This property specifies the maximum number of blocks in the output
          AMR data structure.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetRefinementRatio"
                         default_values="2"
                         label="Refinement Ratio"
                         name="RefinementRatio"
                         number_of_elements="1">
        <IntRangeDomain max="16"
                        min="1"
                        name="range" />
        <Documentation>
          This property specifies the refinement ratio between levels.
        </Documentation>
      </IntVectorProperty>
    <!-- End of ImageDataToAMR -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkImageDataToUniformGrid"
                 label="Image Data To Uniform Grid"
                 name="ImageDataToUniformGrid">
      <Documentation long_help="Create a uniform grid from an image data by specified blanking arrays."
                     short_help="Create a uniform grid from an image data.">
        Create a vtkUniformGrid from a vtkImageData by passing in arrays to be used
        for point and/or cell blanking. By default, values of 0 in the specified
        array will result in a point or cell being blanked. Use Reverse to switch this.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkImageData" />
          <!-- temporary for now until we can check if there is a vtkImageData in the composite dataset
          see https://discourse.paraview.org/t/xml-specification-questions-for-a-filter/2641 -->
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <InputArrayDomain name="input_array"
                          number_of_components="1" />
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>Specify the array to use for blanking.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetReverse"
                         default_values="0"
                         name="Reverse"
                         number_of_elements="1">
        <Documentation>Reverse the array value to whether or not a point or cell is blanked.</Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <!-- End ImageDataToUniformGrid -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAggregateDataSetFilter"
                 label="Aggregate Dataset"
                 name="AggregateDataSet">
      <Documentation long_help="This filter aggregates a dataset onto a subset of processes."
                     short_help="Aggregate a dataset onto a subset of processes.">
        This filter aggregates a dataset onto a subset of processes.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type" composite_data_supported="0">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the filter.
        </Documentation>
      </InputProperty>
      <IntVectorProperty command="SetNumberOfTargetProcesses"
                         default_values="1"
                         name="NumberOfTargetProcesses"
                         number_of_elements="1">
        <Documentation>This property specifies the number of target processes to
        aggregate the dataset onto.</Documentation>
      </IntVectorProperty>
      <!-- End AggregateDataSet -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkAngularPeriodicFilter"
                 label="Angular Periodic Filter"
                 name="AngularPeriodicFilter">
      <Documentation long_help="This filter generate a periodic multiblock dataset."
                     short_help="Periodic Filter.">This filter generate a periodic
                     multiblock dataset</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the Periodic filter.
        </Documentation>
      </InputProperty>
      <IntVectorProperty clean_command="RemoveAllIndices"
                         command="AddIndex"
                         name="BlockIndices"
                         number_of_elements_per_command="1"
                         panel_visibility="default"
                         repeat_command="1">
        <CompositeTreeDomain mode="leaves"
                             name="tree">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </CompositeTreeDomain>
        <Hints>
          <WidgetHeight number_of_rows="20" />
        </Hints>
        <Documentation>This property lists the ids of the blocks to make periodic
        from the input multiblock dataset.</Documentation>
      </IntVectorProperty>

      <IntVectorProperty command="SetIterationMode"
                         default_values="1"
                         name="IterationMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Manual"
                 value="0" />
          <Entry text="Maximum"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This property specifies the mode of iteration, either a user-provided number
        of periods, or the maximum number of periods to rotate to 360 degrees.</Documentation>
      </IntVectorProperty>

      <IntVectorProperty command="SetNumberOfPeriods"
                         default_values="3"
                         name="NumberOfPeriods"
                         number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="IterationMode"
                                   value="0" />
          <!-- show this widget when IterationMode==0 -->
        </Hints>
        <Documentation>This property specifies the number of iteration</Documentation>
      </IntVectorProperty>

      <IntVectorProperty command="SetRotationMode"
                         default_values="0"
                         name="RotationMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Direct Angle"
                 value="0" />
          <Entry text="Array Value"
                 value="1" />
        </EnumerationDomain>
        <Documentation>This property specifies the mode of rotation, either from a user provided
        angle or from an array in the data.</Documentation>

      </IntVectorProperty>

      <DoubleVectorProperty command="SetRotationAngle"
                            default_values="10"
                            name="RotationAngle"
                            number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="RotationMode"
                                   value="0" />
          <!-- show this widget when RotationMode==0 -->
        </Hints>
        <Documentation>Rotation angle in degree.
        </Documentation>
      </DoubleVectorProperty>

      <StringVectorProperty command="SetRotationArrayName"
                            name="RotationArrayName"
                            default_values="periodic angle"
                            number_of_elements="1">
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="RotationMode"
                                   value="1" />
          <!-- show this widget when RotationMode==1 -->
        </Hints>
        <Documentation>Field array name that contains the rotation angle in radians.
        </Documentation>
      </StringVectorProperty>

      <IntVectorProperty command="SetRotationAxis"
                         default_values="0"
                         name="Axis"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Axis X"
                 value="0" />
          <Entry text="Axis Y"
                 value="1" />
          <Entry text="Axis Z"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property specifies the axis of rotation</Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty animateable="1"
                            command="SetCenter"
                            default_values="0.0 0.0 0.0"
                            name="Center"
                            number_of_elements="3"
                            panel_visibility="default">
        <DoubleRangeDomain name="range" />
        <Documentation>This property specifies the 3D coordinates for the
        center of the rotation.</Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetComputeRotationsOnTheFly"
                         default_values="1"
                         name="ComputeRotationsOnTheFly"
                         number_of_elements="1"
                         panel_visibility="default">
        <Documentation>
        Specify whether the rotations should be computed on-the-fly, which is
        compute intensive, or if the arrays should be explicitly generated and
        stored, at the cost of using more memory.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <Hints>
        <RepresentationType view="RenderView" type="Outline" />
      </Hints>
      <!-- End AngularPeriodicFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkResampleToImage"
                 label="Resample To Image"
                 name="ResampleToImage">
      <Documentation long_help="Sample attributes using a 3D image as probing mesh."
                     short_help="Sample attributes using a 3D image."/>

      <InputProperty command="SetInputConnection" name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the dataset whose data will
        be probed</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetUseInputBounds"
                         default_values="1"
                         name="UseInputBounds"
                         number_of_elements="1"
                         panel_visibility="default">
        <Documentation>
        Use input bounds or custom ones?
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetSamplingDimensions"
                         default_values="100 100 100"
                         name="SamplingDimensions"
                         number_of_elements="3"
                         panel_visibility="default">
                         <IntRangeDomain name="range" min="1 1 1"/>
        <Documentation>
        How many linear samples we want along each axis
        </Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty command="SetSamplingBounds"
                         default_values="0 1 0 1 0 1"
                         name="SamplingBounds"
                         number_of_elements="6"
                         panel_visibility="default">
        <BoundsDomain name="bounds">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
        Custom probing bounds
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="UseInputBounds"
                                   value="0" />
        </Hints>
      </DoubleVectorProperty>
      <!-- End vtkResampleToImage -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkResampleWithDataSet"
                 label="Resample With Dataset"
                 name="ResampleWithDataset">
      <Documentation short_help="Sample data attributes at the points of a dataset.">
          This filter takes two inputs - **Source Data Arrays**, and samples the
          point and cell values of this input onto the point locations of the
          **Destination Geometry** input. The output has the same structure as the
          **Destination Geometry** input, but its point data has the resampled values from
          the **Source Data Arrays**."
      </Documentation>
      <InputProperty command="SetSourceConnection" name="SourceDataArrays">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the dataset from which to obtain
        probe values. The data attributes come from this dataset.</Documentation>
      </InputProperty>
      <InputProperty command="SetInputConnection" name="DestinationMesh">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the dataset whose geometry will
        be used in determining positions to probe. The mesh comes from this
        dataset.</Documentation>
      </InputProperty>

      <IntVectorProperty command="SetCategoricalData"
                         default_values="0"
                         name="CategoricalData"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>Control whether the source point data is to be
        treated as categorical. If the data is categorical, then the
        resultant data will be determined by a nearest neighbor
        interpolation scheme rather than by linear interpolation.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetPassCellArrays"
                         default_values="0"
                         name="PassCellArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        When set the input's cell data arrays are shallow copied to the output.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetPassPointArrays"
                         default_values="0"
                         name="PassPointArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        When set the input's point data arrays are shallow copied to the output.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty command="SetPassFieldArrays"
                         default_values="1"
                         name="PassFieldArrays"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to pass the field-data arrays from the Input i.e. the input
        providing the geometry to the output. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty command="SetComputeTolerance"
                         default_values="1"
                         name="ComputeTolerance"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        Set whether to compute the tolerance or to use a user provided
        value. On by default.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <DoubleVectorProperty command="SetTolerance"
                            default_values="2.2204460492503131e-16"
                            name="Tolerance"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain min="2.2204460492503131e-16"
                           name="range" />
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="ComputeTolerance" function="boolean_invert" />
          </PropertyWidgetDecorator>
        </Hints>
        <Documentation>Set the tolerance to use for
        vtkDataSet::FindCell</Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty command="SetMarkBlankPointsAndCells"
                         default_values="0"
                         name="MarkBlankPointsAndCells"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>
        When set, points that did not get valid values during resampling, and
        cells containing such points, are marked as blank.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <!-- cell locator begin -->
      <ProxyProperty command="SetCellLocatorPrototype"
                     label="Cell Locator"
                     name="CellLocator"
                     panel_visibility="advanced">
        <ProxyGroupDomain name="groups">
          <Group name="cell_locators" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="cell_locators"
                 name="StaticCellLocator" />
          <Proxy group="cell_locators"
                 name="CellTreeLocator" />
          <Proxy group="cell_locators"
                 name="CellLocator" />
        </ProxyListDomain>
        <Documentation>The cell locator to use for finding cells for probing.
        </Documentation>
      </ProxyProperty>
      <!-- cell locator end -->

      <!-- End vtkResampleToImage -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractTimeSteps"
                 name="ExtractTimeSteps"
                 label="Extract Time Steps">
      <Documentation short_help="Extract time steps from data.">
        This filter extracts specified time steps from its input.
      </Documentation>

      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
      </InputProperty>

      <IntVectorProperty command="SetUseRange"
                         name="SelectionMode"
                         number_of_elements="1"
                         default_values="0">
        <EnumerationDomain name="enum">
          <Entry text="Select Time Steps"
                 value="0" />
          <Entry text="Select Time Range"
                 value="1" />
        </EnumerationDomain>
        <Documentation>
          Extract time steps supports two ways to select the time steps to be extracted:

          - **Select Time Steps**: Specify time steps to be extracted by their index

          - **Select Time Range**: Specify the start and end time steps of a range by their index and optionally specify
          a stride to optionally take every nth timestep in the range.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty animateable="1"
                         command="AddTimeStepIndex"
                         clean_command="ClearTimeStepIndices"
                         label="Time Step Indices"
                         name="TimeStepIndices"
                         number_of_elements="0"
                         number_of_elements_per_command="1"
                         repeat_command="1">
        <TimeStepIndexDomain name="timestep_index_range" default_mode="min">
          <RequiredProperties>
            <Property function="Input" name="Input"/>
          </RequiredProperties>
        </TimeStepIndexDomain>
        <Documentation>
          This property specifies the indices of the time steps to extract.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="SelectionMode" value="0">
          </PropertyWidgetDecorator>
        </Hints>
      </IntVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>

      <IntVectorProperty command="SetRange"
                         name="TimeStepRange"
                         number_of_elements="2"
                         default_values="0 1">
        <TimeStepIndexDomain name="timestep_index_range" default_mode="min">
          <RequiredProperties>
            <Property function="Input" name="Input"/>
          </RequiredProperties>
        </TimeStepIndexDomain>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="SelectionMode" value="1">
          </PropertyWidgetDecorator>
        </Hints>
        <Documentation>
          Select the beginning and end indices of the range of timesteps to extract.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty command="SetTimeStepInterval"
                         name="TimeStepInterval"
                         number_of_elements="1"
                         default_values="1">
        <IntRangeDomain name="range" min="1"/>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator" mode="visibility" property="SelectionMode" value="1">
          </PropertyWidgetDecorator>
        </Hints>
        <Documentation>
          Select the stride to use when extracting the range of time steps (the n in every nth timestep).
        </Documentation>
      </IntVectorProperty>

      <PropertyGroup label="Time Step Indices">
        <Property name="TimeStepIndices" />
      </PropertyGroup>

      <IntVectorProperty command="SetTimeEstimationMode"
                         name="ApproximationMode"
                         number_of_elements="1"
                         default_values="2"
                         panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Previous Time Step"
                 value="0" />
          <Entry text="Next Time Step"
                 value="1" />
          <Entry text="Nearest Time Step"
                 value="2" />
        </EnumerationDomain>
        <Documentation>
          If the scene's time does not match the time in any of the timesteps selected (likely because something
          else in the scene has time steps at different times) this setting controls which timestep should
          be returned by the filter.  The options are the previous time step, the nearest time step and the next
          time step.
        </Documentation>
      </IntVectorProperty>


      <!-- End ExtractTimeSteps -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRulerLineForInput"
                 name="RulerFilter"
                 label="Bounding Ruler">
      <Documentation short_help="Create a line along the input to use as a ruler">
        This filter creates a line along the object and defaults its
        representation to showing a ruler along that line.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataObject" />
        </DataTypeDomain>
      </InputProperty>
      <IntVectorProperty command="SetAxis"
                         default_values="0"
                         name="Axis"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="X Axis"
                 value="0" />
          <Entry text="Y Axis"
                 value="1" />
          <Entry text="Z Axis"
                 value="2" />
          <Entry text="Oriented Bounding Box Major Axis"
                 value="3" />
          <Entry text="Oriented Bounding Box Medium Axis"
                 value="4" />
          <Entry text="Oriented Bounding Box Minor Axis"
                 value="5" />
        </EnumerationDomain>
        <Documentation>Select along which axis the ruler should be aligned. Note:
        this filter requires that all points in the dataset to which it is applied
        be copied to a single rank when this option is set to any of the
        Oriented Bound Box options, so make sure the dataset can fit on one rank
        before applying this filter.</Documentation>
      </IntVectorProperty>
      <Hints>
        <Representation view="RenderView" type="RulerSourceRepresentation" />
        <Visibility replace_input="0" />
      </Hints>
      <!-- End vtkRulerLineForInput -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkSynchronizeTimeFilter"
                 label="Synchronize Time"
                 name="SynchronizeTime">
      <Documentation short_help="Set 'close' time step values from the source to the input">
        Synchronize time step values in the first input (Input) to time step
        values in the second input (Source) that are considered close enough.
        The outputted data set is from the first input and the number of
        output time steps is also equal to the number of time steps in
        the first input. Time step values in the first input that are
        "close" to time step values in the second input are replaced
        with the value from the second input. Close is determined to
        be if the difference is less than RelativeTolerance multiplied
        by the time range of the first input.
      </Documentation>
      <InputProperty command="SetInputConnection" name="DataToPass">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the dataset whose geometry and
        fields will be output.</Documentation>
      </InputProperty>
      <InputProperty command="SetSourceConnection" name="TimeToSync">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
          <DataType value="vtkCompositeDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the dataset from which to obtain
        the time step values.</Documentation>
      </InputProperty>
      <DoubleVectorProperty
          name="RelativeTolerance"
          command="SetRelativeTolerance"
          number_of_elements="1"
          default_values="0.00001"
          panel_visibility="advanced">
      </DoubleVectorProperty>
      <DoubleVectorProperty information_only="1"
                            name="TimestepValues">
        <TimeStepsInformationHelper />
      </DoubleVectorProperty>
      <Hints>
        <Visibility RelativeTolerance="1" />
      </Hints>
      <!-- End vtkSynchronizeTimeFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDistributedDataFilter"
                 label="D3"
                 name="D3">
      <Documentation long_help="Repartition a data set into load-balanced spatially convex regions.  Create ghost cells if requested."
                     short_help="Repartition a data set.">The D3 filter is
                     available when ParaView is run in parallel. It operates on
                     any type of data set to evenly divide it across the
                     processors into spatially contiguous regions. The output
                     of this filter is of type unstructured
                     grid.</Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the D3
        filter.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetBoundaryMode"
                         default_values="0"
                         name="BoundaryMode"
                         number_of_elements="1">
        <EnumerationDomain name="enum">
          <Entry text="Assign cells uniquely"
                 value="0" />
          <Entry text="Duplicate cells"
                 value="1" />
          <Entry text="Divide cells"
                 value="2" />
        </EnumerationDomain>
        <Documentation>This property determines how cells that lie on processor
        boundaries are handled. The "Assign cells uniquely" option assigns each
        boundary cell to exactly one process, which is useful for isosurfacing.
        Selecting "Duplicate cells" causes the cells on the boundaries to be
        copied to each process that shares that boundary. The "Divide cells"
        option breaks cells across process boundary lines so that pieces of the
        cell lie in different processes. This option is useful for volume
        rendering.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseMinimalMemory"
                         default_values="0"
                         label="Minimal Memory"
                         name="UseMinimalMemory"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set to 1, the D3 filter requires
        communication routines to use minimal memory than without this
        restriction.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetMinimumGhostLevel"
                         default_values="0"
                         label="Minimum Number Of Ghost Levels"
                         name="MinimumGhostLevel"
                         number_of_elements="1">
        <Documentation>The minimum number of ghost levels to add to each
        processor's output. If the pipeline also requests ghost levels, the
        larger value will be used.</Documentation>
      </IntVectorProperty>
      <!-- End D3 -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkUnstructuredGridGhostCellsGenerator"
                 label="Ghost Cells Generator"
                 name="GhostCellsGenerator">
      <Documentation long_help="Generate ghost cells for unstructured grids."
                     short_help="Generate ghost cells for unstructured grids.">
                     The GhostCellGenerator operates on unstructured grids only.
                     This filter does not redistribute the input data, it only
                     generates ghost cells at processor boundaries by fetching
                     topological and geometrical information of those cells on
                     neighbor ranks. The filter can take advantage of global point
                     ids if they are available - if so it will perform faster,
                     otherwise point coordinates will be exchanged and processed.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type" composite_data_supported="0">
          <DataType value="vtkUnstructuredGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the ghost cells
        generator.</Documentation>
      </InputProperty>
      <IntVectorProperty command="SetBuildIfRequired"
                         default_values="0"
                         name="BuildIfRequired"
                         number_of_elements="1">
        <Documentation>Specify if the filter must generate the ghost cells only
          if required by the pipeline downstream. To force at least a fixed level
          of ghosts, this must be set to 0 (unchecked).</Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <IntVectorProperty command="SetMinimumNumberOfGhostLevels"
                         number_of_elements="1"
                         default_values="1"
                         name="MinimumNumberOfGhostLevels">
        <IntRangeDomain name="range" min="1" max="10" />
        <Documentation>
          When **BuildIfRequired** if off, use this to specify the minimum number of
          ghost cells to request. The filter may request more ghost levels than indicated if a
          downstream filter asked for more ghost levels.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="enabled_state"
                                   property="BuildIfRequired"
                                   value="0" />
          <!-- if BuildIfRequired !=0 , we disable this property -->
        </Hints>
      </IntVectorProperty>
      <IntVectorProperty command="SetUseGlobalPointIds"
                         default_values="1"
                         name="UseGlobalIds"
                         number_of_elements="1"
                         panel_visibility="advanced">
        <Documentation>Specify if the filter must take benefit of global point
        ids if they exist or if point coordinates should be used instead.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <StringVectorProperty command="SetGlobalPointIdsArrayName"
                            default_values="GlobalNodeIds"
                            name="GlobalPointIdsArrayName"
                            number_of_elements="1"
                            panel_visibility="never">
        <Documentation>This property provides the name for the input array
        containing the global point ids if the GlobalIds array of the point
        data if not set. Default is GlobalNodeIds.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="ShowWidgetDecorator">
            <Property name="UseGlobalIds" function="boolean" />
          </PropertyWidgetDecorator>
        </Hints>
      </StringVectorProperty>
      <!-- End vtkPUnstructuredGridGhostCellsGenerator -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy base_proxygroup="filters"
                 base_proxyname="ParticlePath"
                 class="vtkInSituPParticlePathFilter"
                 name="InSituParticlePath">
      <Documentation long_help="Trace Particle Paths through time in a vector field."
                     short_help="Trace Particle Paths through time in a vector field.">
                     The Particle Trace filter generates pathlines in a vector
                     field from a collection of seed points. The vector field
                     used is selected from the Vectors menu, so the input data
                     set is required to have point-centered vectors. The Seed
                     portion of the interface allows you to select whether the
                     seed points for this integration lie in a point cloud or
                     along a line. Depending on which is selected, the
                     appropriate 3D widget (point or line widget) is displayed
                     along with traditional user interface controls for
                     positioning the point cloud or line within the data set.
                     Instructions for using the 3D widgets and the
                     corresponding manual controls can be found in section 7.4.
                     This filter operates on any type of data set, provided it
                     has point-centered vectors. The output is polygonal data
                     containing polylines. This filter is available on the
                     Toolbar.</Documentation>
      <InputProperty clean_command="RemoveAllRestarts"
                     command="AddRestartConnection"
                     label="Restart Source"
                     multiple_input="0"
                     name="RestartSource"
                     panel_visibility="never">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>Specify the restart dataset. This is optional and
        can be used to have particle histories that were computed
        previously be included in this filter's computation.</Documentation>
        <Hints>
          <Optional />
        </Hints>
      </InputProperty>
      <IntVectorProperty command="SetClearCache"
                         default_values="0"
                         name="ClearCache"
                         number_of_elements="1"
                         panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>Clear the particle cache from previous time steps.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetFirstTimeStep"
                         default_values="0"
                         name="FirstTimeStep"
                         number_of_elements="1"
                         panel_visibility="never">
        <Documentation>Set the first time step. Default is 0.
        </Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetRestartedSimulation"
                         default_values="0"
                         name="RestartedSimulation"
                         number_of_elements="1"
                         panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>Specify whether or not this is a restarted simulation.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetDisableResetCache"
                         default_values="0"
                         name="DisableResetCache"
                         number_of_elements="1"
                         panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>Prevents cache from getting reset so that new computation
          always start from previous results.</Documentation>
      </IntVectorProperty>
      <!-- End vtkInSituPParticlePathFilter -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy name="ExtractEnclosedPoints"
      class="vtkExtractEnclosedPoints"
      label="Extract Enclosed Points">
      <Documentation long_help="Extract points inside a closed polygonal surface"
                     short_help="Extract points inside a closed points surface">
        Evaluates all points in the input dataset to determine whether they are contained within
        an enclosing surface, defined by the **Surface**. The filter assumes that the surface
        is closed and manifold. To force a check to ensure these preconditions are met
        set the **CheckSurface** property.
      </Documentation>

      <OutputPort index="0" name="EnclosedPoints" />
      <OutputPort index="1" name="Outliers" />

      <InputProperty command="SetInputConnection" name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
         <DataType value="vtkPointSet" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to extract points from.</Documentation>
      </InputProperty>

      <InputProperty command="SetSurfaceConnection" name="Surface">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type" composite_data_supported="0">
          <DataType value="vtkPolyData" />
        </DataTypeDomain>
        <Documentation>This property specifies the closed and manifold surface.</Documentation>
      </InputProperty>

      <DoubleVectorProperty name="Tolerance"
        command="SetTolerance"
        number_of_elements="1"
        default_values="0.0001">
        <DoubleRangeDomain name="range" min="0.0" />
        <Documentation>
          Specify the tolerance on the intersection. The tolerance is expressed as
          a fraction of the diagonal of the bounding box of the enclosing surface.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="CheckSurface"
        number_of_elements="1"
        default_values="0"
        command="SetCheckSurface">
        <BooleanDomain name="bool" />
        <Documentation>
          Specify whether to check the surface for closure. If on, then the
          algorithm first checks to see if the surface is closed and manifold.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="GenerateOutliers"
        command="SetGenerateOutliers"
        number_of_elements="1"
        default_values="0">
        <Documentation>
          If checked, then a second output will be created
          that contains the outlier points.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty name="GenerateVertices"
        command="SetGenerateVertices"
        number_of_elements="1"
        default_values="1">
        <Documentation>
          If checked, then the outputs will contain a poly-vertex cell. This takes a
          lot more memory, however certain filters many requires cells to be present
          to function properly.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkHyperTreeGridToUnstructuredGrid"
                 label="HyperTreeGrid To UnstructuredGrid"
                 name="HyperTreeGridToUnstructuredGrid">
      <Documentation long_help="Convert HyperTreeGrid to UnstructuredGrid."
                     short_help="Convert HyperTreeGrid to UnstructuredGrid.">
                     This filter converts vtkHyperTreeGrid data to vtkUnstructuredGrid. The converted output consumes much more memory but is compatible with most of the standard filters.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the converter.</Documentation>
      </InputProperty>
      <!-- End vtkHyperTreeGridToUnstructuredGrid -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkHyperTreeGridToDualGrid"
                 label="HyperTreeGrid To Dual Grid"
                 name="HyperTreeGridToDualGrid">
      <Documentation long_help="Convert HyperTreeGrid to the dual UnstructuredGrid."
                     short_help="Convert HyperTreeGrid to the dual UnstructuredGrid.">
                     This filter converts vtkHyperTreeGrid data to vtkUnstructuredGrid, using the dual grid. The converted output consumes much more memory but is compatible with most of the standard filters.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
        <Documentation>This property specifies the input to the converter.</Documentation>
      </InputProperty>
      <!-- End vtkHyperTreeGridToDualGrid -->
    </SourceProxy>
    <SourceProxy class="vtkHyperTreeGridAxisReflection"
                 name="HyperTreeGridAxisReflection"
                 label="Hyper Tree Grid - Axis Reflection">
      <Documentation short_help="Reflect an HTG across an axis-aligned plane.">
        This filter reflect the cells of a hyper tree grid with respect to
        one of the planes parallel to the bounding box of the data set.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
      </InputProperty>
      <IntVectorProperty name="PlaneNormal"
                         command="SetPlane"
                         number_of_elements="1"
                         default_values="0">
          <EnumerationDomain name="enum">
            <Entry text="X Axis" value="6" />
            <Entry text="Y Axis" value="7" />
            <Entry text="Z Axis" value="8" />
          </EnumerationDomain>
        <Documentation>Axis to use as the normal to the reflection plane.</Documentation>
      </IntVectorProperty>
      <DoubleVectorProperty name="PlanePosition"
                            command="SetCenter"
                            number_of_elements="1"
                            default_values="0.0">
        <Documentation>Position of the reflection plane along the normal axis.</Documentation>
      </DoubleVectorProperty>
      <!-- End vtkHyperTreeGridAxisReflection -->
    </SourceProxy>
    <SourceProxy class="vtkHyperTreeGridCellCenters"
                 name="HyperTreeGridCellCenters"
                 label="Hyper Tree Grid - Cell Centers">
      <Documentation short_help="Generate points at leaf node centers.">
        This filter generates output points at the center of the leaf
        cells in the hyper tree grid.
        These points can be used for placing glyphs or labeling.
        The cell attributes will be associated with the points in the output.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
      </InputProperty>
      <IntVectorProperty name="CreateVertexCells"
                         command="SetVertexCells"
                         default_values="0"
                         number_of_elements="1">
        <Documentation>
          If enabled, vertex cells will be added to the output dataset. This
          is useful for visualizing the output points, which are not rendered
          otherwise.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
      <!-- End vtkHyperTreeGridCellCenters -->
    </SourceProxy>
    <SourceProxy class="vtkHyperTreeGridDepthLimiter"
                 name="HyperTreeGridDepthLimiter"
                 label="Hyper Tree Grid - Depth Limiter">
      <Documentation short_help="Limit HTG nodes to a maximum depth">
        Extract all levels down to a specified depth from a hyper tree grid.
        If the required depth is greater or equal to the maximum level of the
        input grid, then the output is identical.
        Note that when a material mask is present, the geometry extent of the
        output grid is guaranteed to contain that of the input tree, but the
        former might be strictly larger than the latter. This is not a bug
        but an expected behavior of which the user should be aware.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
      </InputProperty>
      <IntVectorProperty name="SetDepth"
                         command="SetDepth"
                         default_values="0"
                         number_of_elements="1">
        <Documentation>
          Maximum depth to which the output grid should be limited.
        </Documentation>
        <IntRangeDomain min="0"
                        name="range" />
      </IntVectorProperty>
      <!-- End vtkHyperTreeGridDepthLimiter -->
    </SourceProxy>
    <SourceProxy class="vtkHyperTreeGridGeometry"
                 name="HyperTreeGridGeometry"
                 label="Hyper Tree Grid - Geometry Filter">
      <Documentation short_help="Generate external surface of a HTG.">
        Generate PolyData representing the external surface of a HTG.
      </Documentation>
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkHyperTreeGrid" />
        </DataTypeDomain>
      </InputProperty>
      <!-- End vtkHyperTreeGridGeometry -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkPointSetToMoleculeFilter"
                 name="PointSetToMolecule"
                 label="Convert Into Molecule">
      <Documentation long_help="Convert a point set into a molecule."
                     short_help="Convert a point set into a molecule.">
        Convert a point set into a molecule. Every point of the input becomes an atom
        of the output molecule. It needs a point array containing the atomic numbers.
      </Documentation>
      <InputProperty name="Input"
                     command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet"/>
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point"
                          name="input_array"
                          number_of_components="1"/>
      </InputProperty>
      <StringVectorProperty command="SetInputArrayToProcess"
                            element_types="0 0 0 0 2"
                            label="Atomic Numbers"
                            name="SelectInputScalars"
                            number_of_elements="5">
        <ArrayListDomain attribute_type="Scalars"
                         input_domain_name="input_array"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Documentation>This property indicates the name of the scalar array
        corresponding to atomic numbers.</Documentation>
      </StringVectorProperty>
      <IntVectorProperty command="SetConvertLinesIntoBonds"
                         default_values="1"
                         name="ConvertLinesIntoBonds"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation short_help="Specify if line cells are converted into bonds."
                       long_help="Specify if line cells are converted into bonds.">
          This property determines if the lines (cell of type VTK_LINE) are converted into bonds.
        </Documentation>
      </IntVectorProperty>
    <!-- End PointSetToMolecule -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkMoleculeToLinesFilter"
                 name="MoleculeToLines"
                label="Molecule To Lines">
      <Documentation long_help="Convert a molecule into lines."
                     short_help="Convert a molecule into lines.">
        Convert a molecule into lines. Each atom of the input becomes a point of the output polydata, each bond a line.
      </Documentation>
      <InputProperty name="Input"
                     command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMolecule"/>
        </DataTypeDomain>
      </InputProperty>
    <!-- End MoleculeToLines -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkMoleculeAppend"
                 name="AppendMolecule"
                 label="Append Molecule">
      <Documentation long_help="Appends one or more molecules into a single molecule."
                     short_help="Append molecules into a single molecule.">
        Appends one or more molecules into a single molecule. It also appends  the associated atom data and edge data.
        Note that input data arrays should match (same number of arrays with same names in each input)
      </Documentation>
      <InputProperty clean_command="RemoveAllInputs"
                     command="AddInputConnection"
                     multiple_input="1"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMolecule"/>
        </DataTypeDomain>
      </InputProperty>
    <!-- End AppendMolecule -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkSimpleBondPerceiver"
                 name="ComputeMoleculeBonds"
                 label="Compute Molecule Bonds">
      <Documentation long_help="Compute the bonds of a molecule based on interatomic distance only."
                     short_help="Compute the bonds of a molecule.">
        Compute the bonds of a molecule. If the
        interatomic distance is less than the sum of the two atom's covalent radii
        (and a tolerance), a single bond is added.
        This algorithm does not consider valences, hybridization, aromaticity, or
        anything other than atomic separations. It will not produce anything other
        than single bonds.
      </Documentation>
      <InputProperty name="Input"
                     command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMolecule"/>
        </DataTypeDomain>
      </InputProperty>
      <DoubleVectorProperty command="SetTolerance"
                            default_values="0.45"
                            name="Tolerance"
                            number_of_elements="1"
                            panel_visibility="advanced">
        <DoubleRangeDomain name="scalar_range" />
        <Documentation short_help="Tolerance on covalent radius size">
          This property determines the tolerance to apply on covalent radius.
        </Documentation>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetIsToleranceAbsolute"
                         default_values="1"
                         name="IsToleranceAbsolute"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation short_help="Specify if Tolerance is absolute or relative to radius."
                       long_help="Specify if Tolerance is absolute (addition) or relative (multiplication) to radius.">
          This property determines if the tolerance is absolute (value is added to radius and should be positive)
          or not (value multiplied with radius and should be greater than 1).
        </Documentation>
      </IntVectorProperty>
    <!-- End ComputeMoleculeBonds -->
    </SourceProxy>
    <!-- ==================================================================== -->
    <SourceProxy class="vtkDistributedPointCloudFilter"
                 name="DistributePoints"
                 label="Distribute Points">
      <Documentation long_help="Fairly distribute points over processors into spatially contiguous regions."
                     short_help="Distribute points over processors.">
           This filter fairly distributes points over processors into contiguous spatial regions.
           The output is a PolyData which does not contain any cell.
           Distribution is done using a Kd-tree.
      </Documentation>
      <InputProperty name="Input"
                     command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet"/>
        </DataTypeDomain>
      </InputProperty>
    </SourceProxy>
    <!-- End DistributePointCloud -->
    <!-- ==================================================================== -->
    <SourceProxy class="vtkExtractSubsetWithSeed"
      name="ExtractSubsetWithSeed"
      label="Extract Subset With Seed">
      <Documentation
        long_help="Extract a subset from a structured-grid starting with a seed point.">
        Extract a subset (line or plane) from a structured-grid starting with a seed point.
        The filter supports cases where the structured grid is split up into multiple blocks
        (across multiple ranks). It also handles cases were the ijk origin for each the
        blocks is not aligned.
      </Documentation>
      <InputProperty name="Input"
                     command="SetInputConnection">
        <ProxyGroupDomain name="groups">
          <Group name="sources"/>
          <Group name="filters"/>
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkStructuredGrid"/>
        </DataTypeDomain>
      </InputProperty>
      <DoubleVectorProperty name="Seed"
        command="SetSeed"
        number_of_elements="3"
        default_values="0 0 0">
        <Documentation>
          Specify the seed point in x-y-z coordinates to initiate in the slice extraction.
        </Documentation>
        <BoundsDomain default_mode="mid" mode="normal" name="range">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>
      <IntVectorProperty command="SetDirection"
                         default_values="0"
                         name="Direction"
                         number_of_elements="1"
                         panel_visibility="default">
        <EnumerationDomain name="enum">
          <Entry value="0" text="I" info="line" />
          <Entry value="1" text="J" info="line" />
          <Entry value="2" text="K" info="line" />
          <Entry value="3" text="IJ" info="plane" />
          <Entry value="4" text="JK" info="plane" />
          <Entry value="5" text="KI" info="plane" />
        </EnumerationDomain>
        <Documentation>
          Specify the direction in which to extract the slice starting with the **Seed**.
        </Documentation>
      </IntVectorProperty>
      <PropertyGroup label="Seed Parameters" panel_widget="InteractiveHandle">
        <Property function="WorldPosition" name="Seed" />
        <Property function="Input" name="Input" />
      </PropertyGroup>
      <Hints>
        <Visibility replace_input="2" />
      </Hints>
    </SourceProxy>
    <!-- End ExtractSubsetWithSeed -->
    <!-- ==================================================================== -->
    <SourceProxy class="vtkRedistributeDataSetFilter"
                 name="RedistributeDataSet"
                 label="Redistribute DataSet">
      <Documentation
        long_help="Redistribute dataset into requested number of partitions.">
        Redistribute data for load balancing. The filter either computes the bounding
        boxes, or uses a provided collection of bounding boxes, for distributing the
        data. Cells along partition boundaries can be uniquely assigned to a partition,
        duplicated among partitions, or split among the partitions. The output
        is an unstructured grid.
      </Documentation>
      <InputProperty name="Input"
                     command="SetInputConnection">
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet"/>
        </DataTypeDomain>
      </InputProperty>

      <IntVectorProperty name="BoundaryMode"
        number_of_elements="1"
        default_values="0"
        command="SetBoundaryMode">
        <EnumerationDomain name="enum">
          <Entry text="Assign to one region" value="0" />
          <Entry text="Assign to all regions" value="1" />
          <Entry text="Split cells" value="2" />
        </EnumerationDomain>
        <Documentation>This property determines how cells that lie on processor
        boundaries are handled. The "Assign to one region" option assigns each
        boundary cell to exactly one process, which is useful for isosurfacing.
        Selecting "Assign to all regions" causes the cells on the boundaries to be
        copied to each process that shares that boundary. The "Split cells"
        option breaks cells across process boundary lines so that pieces of the
        cell lie in different processes. This option is useful for volume
        rendering.</Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="NumberOfPartitions"
        command="SetNumberOfPartitions"
        number_of_elements="1"
        default_values="-1">
        <IntRangeDomain min="-1"
                        name="range" />
        <Documentation>Specify the number of partitions to split the dataset into.
          Set to 0 to indicate that the partitions should match the number of ranks.
          The value provided is a hint and the actual number of partitions will be
        equal to the power of 2 greater than or equal to the chosen value.</Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="PreservePartitionsInOutput"
        command="SetPreservePartitionsInOutput"
        number_of_elements="1"
        default_values="0"
        panel_visibility="advanced">
        <Documentation>When unchecked, ranks with more than one partition will merge
          the partitions into a single vtkUnstructuredGrid. When checked, the partitions
          are preserved and the output is a vtkPartitionedDataSet.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty name="GenerateGlobalCellIds"
        command="SetGenerateGlobalCellIds"
        number_of_elements="1"
        default_values="0">
        <Documentation>Generate global Ids for all cells across partitions.
        </Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>

      <IntVectorProperty name="EnableDebugging"
        command="SetEnableDebugging"
        number_of_elements="1"
        default_values="0"
        panel_visibility="advanced">
        <Documentation>Retains some helper arrays created for generating
        global cell Ids and ghost cells that are useful for debugging.</Documentation>
        <BooleanDomain name="bool" />
      </IntVectorProperty>
    </SourceProxy>
    <!-- End RedistributeDataSetFilter -->
  </ProxyGroup>
</ServerManagerConfiguration>
