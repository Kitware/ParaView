<ServerManagerConfiguration>
  <ProxyGroup name="filters">
    <!-- ==================================================================== -->
    <SourceProxy class="vtkIntersectFragments"
                 label="Intersect Fragments"
                 name="IntersectFragments">
      <Documentation long_help="The Intersect Fragments filter perform geometric intersections on sets of fragments."
                     short_help="The Intersect Fragments filter perform geometric intersections on sets of fragments.">
      The Intersect Fragments filter perform geometric intersections on sets of
      fragments. The filter takes two inputs, the first containing fragment
      geometry and the second containing fragment centers. The filter has two
      outputs. The first is geometry that results from the intersection. The
      second is a set of points that is an approximation of the center of where
      each fragment has been intersected.</Documentation>
      <!-- Out -->
      <OutputPort index="0"
                  name="geometry" />
      <OutputPort index="1"
                  name="statistics" />
      <!-- In -->
      <InputProperty command="SetGeometryInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>This input must contain fragment
        geometry.</Documentation>
      </InputProperty>
      <InputProperty command="SetStatisticsInputConnection"
                     name="Source">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkMultiBlockDataSet" />
        </DataTypeDomain>
        <Documentation>This input must contain fragment
        centers.</Documentation>
      </InputProperty>
      <!-- Cut functuion -->
      <ProxyProperty command="SetCutFunction"
                     label="Slice Type"
                     name="CutFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Box" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
        </ProxyListDomain>
        <Documentation>This property sets the type of intersecting geometry,
        and associated parameters.</Documentation>
      </ProxyProperty>
      <!-- End IntersectFragments -->
    </SourceProxy>

    <!-- ==================================================================== -->
    <SourceProxy class="vtkMaterialInterfaceFilter"
                 label="Material Interface Filter"
                 name="MaterialInterfaceFilter">
      <Documentation long_help="The Material Interface filter finds volumes in the input data containing material above a certain material fraction."
                     short_help="The Material Interface filter finds volumes in the input data containing material above a certain material fraction.">
      The Material Interface filter finds voxels inside of which a material
      fraction (or normalized amount of material) is higher than a given
      threshold. As these voxels are identified surfaces enclosing adjacent
      voxels above the threshold are generated. The resulting volume and its
      surface are what we call a fragment. The filter has the ability to
      compute various volumetric attributes such as fragment volume, mass,
      center of mass as well as volume and mass weighted averages for any of
      the fields present. Any field selected for such computation will be also
      be copied into the fragment surface's point data for visualization. The
      filter also has the ability to generate Oriented Bounding Boxes (OBB) for
      each fragment. The data generated by the filter is organized in three
      outputs. The "geometry" output, containing the fragment surfaces. The
      "statistics" output, containing a point set of the centers of mass. The
      "obb representation" output, containing OBB representations (poly data).
      All computed attributes are copied into the statistics and geometry
      output. The obb representation output is used for validation and
      debugging purposes and is turned off by default. To measure the size of
      craters, the filter can invert a volume fraction and clip the volume
      fraction with a sphere and/or a plane.</Documentation>
      <OutputPort index="0"
                  name="geometry" />
      <OutputPort index="1"
                  name="statistics" />
      <InputProperty command="SetInputConnection"
                     name="Input">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkNonOverlappingAMR" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="cell"
                          name="input_array" />
        <Documentation>Input to the filter can be a hierarchical box data set
        containing image data or a multiblock of rectilinear
        grids.</Documentation>
      </InputProperty>
      <!-- Material Fraction Array-->
      <StringVectorProperty clean_command="UnselectAllMaterialArrays"
                            command="SelectMaterialArray"
                            label="Select Material Fraction Arrays"
                            name="SelectMaterialArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_UNSIGNED_CHAR"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <!-- <NoDefault /> -->
        </Hints>
        <Documentation>Material fraction is defined as normalized amount of
        material per voxel. It is expected that arrays containing material
        fraction data has been down converted to a unsigned
        char.</Documentation>
      </StringVectorProperty>
      <!-- Material fraction -->
      <DoubleVectorProperty command="SetMaterialFractionThreshold"
                            default_values="0.5"
                            label="Material Fraction Threshold"
                            name="MaterialFractionThreshold"
                            number_of_elements="1">
        <DoubleRangeDomain max="1"
                           min="0.08"
                           name="range" />
        <Documentation>Material fraction is defined as normalized amount of
        material per voxel. Any voxel in the input data set with a material
        fraction greater than this value is included in the output data
        set.</Documentation>
      </DoubleVectorProperty>
      <!-- Invert the volume fraction -->
      <IntVectorProperty command="SetInvertVolumeFraction"
                         default_values="0"
                         name="InvertVolumeFraction"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Inverting the volume fraction generates the negative of
        the material. It is useful for analyzing craters.</Documentation>
      </IntVectorProperty>
      <ProxyProperty command="SetClipFunction"
                     label="Clip Type"
                     name="ClipFunction">
        <ProxyGroupDomain name="groups">
          <Group name="implicit_functions" />
        </ProxyGroupDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="implicit_functions"
                 name="None" />
          <Proxy group="implicit_functions"
                 name="Plane" />
          <Proxy group="implicit_functions"
                 name="Sphere" />
        </ProxyListDomain>
        <Documentation>This property sets the type of clip geometry, and
        associated parameters.</Documentation>
      </ProxyProperty>
      <!-- Mass Array-->
      <StringVectorProperty clean_command="UnselectAllMassArrays"
                            command="SelectMassArray"
                            label="Select Mass Arrays"
                            name="SelectMassArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain attribute_type="Scalars"
                         data_type="VTK_FLOAT VTK_DOUBLE"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <NoDefault />
        </Hints>
        <Documentation>Mass arrays are paired with material fraction arrays.
        This means that the first selected material fraction array is paired
        with the first selected mass array, and so on sequentially. As the
        filter identifies voxels meeting the minimum material fraction
        threshold, these voxel's mass will be used in fragment center of mass
        and mass calculation. A warning is generated if no mass array is
        selected for an individual material fraction array. However, in that
        case the filter will run without issue because the statistics output
        can be generated using fragments' centers computed from axis aligned
        bounding boxes.</Documentation>
      </StringVectorProperty>
      <!-- Volume weighted average Array -->
      <StringVectorProperty clean_command="UnselectAllVolumeWtdAvgArrays"
                            command="SelectVolumeWtdAvgArray"
                            label="Compute volume weighted average over:"
                            name="SelectVolumeWtdAvgArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <Documentation>Specifies the arrays from which to volume weighted
        average.</Documentation>
        <ArrayListDomain data_type="VTK_FLOAT VTK_DOUBLE"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <NoDefault />
        </Hints>
        <Documentation>For arrays selected a volume weighted average is
        computed. The values of these arrays are also copied into fragment
        geometry cell data as the fragment surfaces are
        generated.</Documentation>
      </StringVectorProperty>
      <!-- Mass weighted average Array -->
      <StringVectorProperty clean_command="UnselectAllMassWtdAvgArrays"
                            command="SelectMassWtdAvgArray"
                            label="Compute mass weighted average over:"
                            name="SelectMassWtdAvgArray"
                            number_of_elements_per_command="1"
                            repeat_command="1">
        <ArrayListDomain data_type="VTK_FLOAT VTK_DOUBLE"
                         name="array_list">
          <RequiredProperties>
            <Property function="Input"
                      name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- override gui no to set default -->
          <NoDefault />
        </Hints>
        <Documentation>For arrays selected a mass weighted average is computed.
        These arrays are also copied into fragment geometry cell data as the
        fragment surfaces are generated.</Documentation>
      </StringVectorProperty>
      <!-- do not remove -->
      <!-- Summation Array
     <StringVectorProperty
       name="SelectSummationArray"
       command="SelectSummationArray"
       clean_command="UnselectAllSummationArrays"
       repeat_command="1"
       number_of_elements_per_command="1"
       label="Compute summation over:">
       <Documentation>
         Specifies the arrays from which to sum over fragments.
       </Documentation>

       <ArrayListDomain
         name="array_list"
         data_type="VTK_FLOAT VTK_DOUBLE">
         <RequiredProperties>
           <Property name="Input" function="Input"/>
         </RequiredProperties>
       </ArrayListDomain>
       <Hints>
         <NoDefault />
       </Hints>
     </StringVectorProperty>-->
      <!-- Compute OBB -->
      <IntVectorProperty command="SetComputeOBB"
                         default_values="0"
                         name="ComputeOBB"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>Compute Object Oriented Bounding boxes (OBB). When
        active the result of this computation is copied into the statistics
        output. In the case that the filter is built in its validation mode,
        the OBB's are rendered.</Documentation>
      </IntVectorProperty>
      <!-- Write a csv file:
          This is not an excel compatible file, it has more
          information that is stored in headers. Also commas
          are used on tuple boundaries while spaces are used
          on component boundaries.-->
      <IntVectorProperty command="SetWriteGeometryOutput"
                         default_values="0"
                         name="WriteGeometryOutput"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set, then the geometry output is
        written to a text file. The file name will be constructed using the
        path in the "Output Base Name" widget.</Documentation>
      </IntVectorProperty>
      <IntVectorProperty command="SetWriteStatisticsOutput"
                         default_values="0"
                         name="WriteStatisticsOutput"
                         number_of_elements="1">
        <BooleanDomain name="bool" />
        <Documentation>If this property is set, then the statistics output is
        written to a text file. The file name will be constructed using the
        path in the "Output Base Name" widget.</Documentation>
      </IntVectorProperty>
      <StringVectorProperty animateable="0"
                            command="SetOutputBaseName"
                            name="OutputBaseName"
                            number_of_elements="1">
        <Documentation>This property specifies the base including path of where
        to write the statistics and geometry output text files. It follows the
        pattern "/path/to/folder/and/file" here file has no extension, as the
        filter will generate a unique extension.</Documentation>
      </StringVectorProperty>
      <!-- do not remove
      this is a feature that most users should not
      need. If memory usage becomes a problem then
      this gives the user more control over excluding
      highly loaded processes from memory intesive operations. -->
      <!-- loading bounds
     <IntVectorProperty
       name="UpperLoadingBound"
       command="SetUpperLoadingBound"
       number_of_elements="1"
       default_values="-1"
       label="Loading Bound">
       <DoubleRangeDomain name="range" min="-1" max="2000000000" />
       <Documentation>
         Bound in polygons above which process are excluded from work sharing.
       </Documentation>
     </IntVectorProperty>-->
      <!-- End MaterialInterfaceFilter -->
    </SourceProxy>
  </ProxyGroup>
</ServerManagerConfiguration>
