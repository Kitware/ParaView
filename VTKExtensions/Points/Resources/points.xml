<ServerManagerConfiguration>
  <!-- =================================================================== -->
  <ProxyGroup name="extended_sources">
    <SourceProxy name="BoundedPlaneSource" class="vtkBoundedPlaneSource"
                 label="Bounded Plane">
      <DoubleVectorProperty command="SetBoundingBox"
          name="BoundingBox"
          default_values="0 1 0 1 0 1"
          number_of_elements="6">
        <Documentation>Set the bounding box for the domain</Documentation>
        <BoundsDomain mode="data_bounds" name="range">
          <RequiredProperties>
            <Property function="Input" name="DummyInput" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>

      <DoubleVectorProperty command="SetPadding"
        name="Padding"
        default_values="0"
        number_of_elements="1">
        <DoubleRangeDomain name="range" min="0" />
        <Documentation>
          Specify a padding to use to inflate the bounds in all directions
          before generating the plane.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="RefinementMode"
        command="SetRefinementMode"
        number_of_elements="1"
        default_values="0">
        <Documentation>
          Specify how refinement is computed.
        </Documentation>
        <EnumerationDomain name="enum">
          <Entry text="Use resolution" value="0" />
          <Entry text="Use cell-size" value="1" />
        </EnumerationDomain>
      </IntVectorProperty>

      <IntVectorProperty command="SetResolution"
        default_values="100"
        name="Resolution"
        number_of_elements="1">
        <IntRangeDomain min="1" name="range" />
        <Documentation>This property specifies the number of divisions along
          the X axis of the parallelogram.</Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="RefinementMode"
                                   value="0" />
        </Hints>
      </IntVectorProperty>

      <DoubleVectorProperty name="CellSize"
        command="SetCellSize"
        default_values="1.0"
        number_of_elements="1">
        <Documentation>Specify the cell size to use to compute plane refinement.</Documentation>
        <DoubleRangeDomain name="range" min= "1" />
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="RefinementMode"
                                   value="1" />
        </Hints>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Center"
        command="SetCenter"
        number_of_elements="3"
        default_values="0 0 0">
        <Documentation>
          Specify the center of the plane. Works in conjunction with the plane
          normal to position the plane. Don't use this method to define the plane.
          Instead, use it to move the plane to a new center point.
        </Documentation>
        <BoundsDomain default_mode="mid" mode="normal" name="range">
          <RequiredProperties>
            <Property function="Input" name="DummyInput" />
          </RequiredProperties>
        </BoundsDomain>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Normal"
        command="SetNormal"
        number_of_elements="3"
        default_values="0 0 1">
        <Documentation>
          Specify the plane normal. Works in conjunction with the plane center to
          orient the plane. Don't use this method to define the plane. Instead, use
          it to rotate the plane around the current center point.
        </Documentation>
      </DoubleVectorProperty>

      <InputProperty is_internal="1" name="DummyInput">
        <!-- Used when this source is added to a proxy list domain. -->
      </InputProperty>

      <PropertyGroup label="Plane Bounds">
        <Property name="BoundingBox" />
        <Property name="RefinementMode" />
        <Property name="Resolution" />
        <Property name="CellSize" />
      </PropertyGroup>

      <PropertyGroup label="Plane Parameters" panel_widget="InteractivePlane">
        <Property function="Origin" name="Center" />
        <Property function="Normal" name="Normal" />
        <Property function="Input" name="DummyInput" />
      </PropertyGroup>
      <Hints>
        <ProxyList>
          <Link name="DummyInput" with_property="Input" />
        </ProxyList>
      </Hints>
    </SourceProxy>

    <SourceProxy name="BoundedVolumeSource" class="vtkBoundedVolumeSource" label="Bounded Volume">
      <DoubleVectorProperty name="Origin"
        command="SetOrigin"
        number_of_elements="3"
        default_values="0 0 0">
        <BoundsDomain name="range" mode="normal" default_mode="min,min,min" >
          <RequiredProperties>
            <Property function="Input" name="DummyInput" />
          </RequiredProperties>
        </BoundsDomain>
        <Documentation>
          Set the origin for the volume.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Scale"
        command="SetScale"
        number_of_elements="3"
        default_values="1 1 1">
        <BoundsDomain name="range" mode="extents">
          <RequiredProperties>
            <Property function="Input" name="DummyInput" />
          </RequiredProperties>
        </BoundsDomain>

        <Documentation>
          Set scale factor for a unit volume.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty command="SetPadding"
        name="Padding"
        default_values="0"
        number_of_elements="1">
        <DoubleRangeDomain name="range" min="0" />
        <Documentation>
          Specify a padding to use to inflate the bounds in all directions
          before generating the plane.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="RefinementMode"
        command="SetRefinementMode"
        number_of_elements="1"
        default_values="0">
        <Documentation>
          Specify how refinement is computed.
        </Documentation>
        <EnumerationDomain name="enum">
          <Entry text="Use resolution" value="0" />
          <Entry text="Use cell-size" value="1" />
        </EnumerationDomain>
      </IntVectorProperty>

      <IntVectorProperty name="Resolution"
        command="SetResolution"
        number_of_elements="3"
        default_values="100 100 100">
        <IntRangeDomain name="range" min="1 1 1" />
        <Documentation>
          Set the sampling resolution for the generated volume.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="RefinementMode"
                                   value="0" />
        </Hints>
      </IntVectorProperty>

      <DoubleVectorProperty name="CellSize"
        command="SetCellSize"
        default_values="1.0"
        number_of_elements="1">
        <Documentation>Specify the cell size to use to compute plane refinement.</Documentation>
        <DoubleRangeDomain name="range" min= "1" />
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
                                   mode="visibility"
                                   property="RefinementMode"
                                   value="1" />
        </Hints>
      </DoubleVectorProperty>

      <InputProperty is_internal="1" name="DummyInput">
        <!-- Used when this source is added to a proxy list domain. -->
      </InputProperty>

      <PropertyGroup label="Volume Parameters" panel_widget="InteractiveBox">
        <Property function="Position" name="Origin" />
        <Property function="Scale" name="Scale" />
      </PropertyGroup>

      <PropertyGroup label="Volume Refinement">
        <Property name="RefinementMode" />
        <Property name="Resolution" />
        <Property name="CellSize" />
      </PropertyGroup>
      <Hints>
        <ProxyList>
          <Link name="DummyInput" with_property="Input" />
        </ProxyList>
      </Hints>
    </SourceProxy>
  </ProxyGroup>

  <!-- =================================================================== -->
  <ProxyGroup name="point_interpolation_kernels">
    <Proxy name="EllipsoidalGaussianKernel" class="vtkEllipsoidalGaussianKernel">
      <Documentation>
        This is an interpolation kernel that returns the
        weights for all points found in the ellipsoid defined by radius R in
        combination with local data (normals and/or scalars).
      </Documentation>

      <IntVectorProperty name="UseNormals"
        command="SetUseNormals"
        number_of_elements="1"
        default_values="1">
        <BooleanDomain name="bool" />
        <Documentation>
          Specify whether vector values should be used to affect the shape
          of the Gaussian distribution.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="UseScalars"
        command="SetUseScalars"
        number_of_elements="1"
        default_values="0">
        <BooleanDomain name="bool" />
        <Documentation>
          Specify whether scalar values should be used to scale the weights.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Radius"
        command="SetRadius"
        number_of_elements="1"
        default_values="1.0">
        <DoubleRangeDomain name="range" min="0.000001" />
        <Documentation>
          Specify the radius of the kernel. Points within this radius will be
          used for interpolation. If no point is found, then the closest point
          will be used.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Sharpness"
        command="SetSharpness"
        number_of_elements="1"
        default_values="2.0">
        <DoubleRangeDomain name="range" min="1.0" />
        <Documentation>
          Specify the sharpness (i.e., falloff) of the Gaussian. By default
          Sharpness=2. As the sharpness increases the effects of distant points
          are reduced.
        </Documentation>
      </DoubleVectorProperty>

      <DoubleVectorProperty name="Eccentricity"
        command="SetEccentricity"
        number_of_elements="1"
        default_values="2.0">
        <DoubleRangeDomain name="range" min="0.000001" />
        <Documentation>
          Specify the eccentricity of the ellipsoidal Gaussian. A value=1.0
          produces a spherical distribution. Values less than 1 produce a needle like
          distribution (in the direction of the normal); values greater than 1 produce a
          pancake like distribution (orthogonal to the normal).
        </Documentation>
      </DoubleVectorProperty>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="GeneralizedKernelBase" class="vtkGeneralizedKernel">
      <IntVectorProperty name="KernelFootprint"
        command="SetKernelFootprint"
        number_of_elements="1"
        default_values="0">
        <EnumerationDomain name="enum">
          <Entry text="Radius" value="0"/>
          <Entry text="N Closest" value="1"/>
        </EnumerationDomain>
        <Documentation>
          Specify the interpolation basis style. By default, a Radius style is
          used (i.e., the basis is defined from all points within a specified
          radius). However, it is also possible to select the N closest points
          (N Closest). Note that in most formulations the Radius style is assumed
          as it provides better mathematical properties. However, for convenience
          some bases are easier to use when the N closest points are taken.
        </Documentation>
      </IntVectorProperty>

      <DoubleVectorProperty name="Radius"
        command="SetRadius"
        number_of_elements="1"
        default_values="1.0">
        <DoubleRangeDomain name="range" min="0.000001" />
        <Documentation>
          If the interpolation basis style is Radius, then this method specifies
          the radius within which the basis points must lie.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
            mode="enabled_state"
            property="KernelFootprint"
            value="0" />
        </Hints>
      </DoubleVectorProperty>

      <IntVectorProperty name="NumberOfPoints"
        command="SetNumberOfPoints"
        number_of_elements="1"
        default_values="8">
        <IntRangeDomain name="range" min="1" />
        <Documentation>
          If the interpolation basis style is N Closest, then this method specifies
          the number of the closest points used to form the interpolation basis.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
            mode="enabled_state"
            property="KernelFootprint"
            value="1" />
        </Hints>
      </IntVectorProperty>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="GaussianKernel" class="vtkGaussianKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="GeneralizedKernelBase">
      <Documentation>
        This is an interpolation kernel that simply returns the
        weights for all points found in the sphere defined by radius R. The
        weights are computed as: `exp(-(s*r/R)^2)` where r is the distance from the
        point to be interpolated to a neighboring point within R. The sharpness s
        simply affects the rate of fall off of the Gaussian. (A more general
        Gaussian kernel is available from **EllipsoidalGaussianKernel**.)
      </Documentation>

      <DoubleVectorProperty name="Sharpness"
        command="SetSharpness"
        number_of_elements="1"
        default_values="2.0">
        <DoubleRangeDomain name="range" min="1.0" />
        <Documentation>
          Specify the sharpness (i.e., falloff) of the Gaussian. By default
          Sharpness=2. As the sharpness increases the effects of distant points
          are reduced.
        </Documentation>
      </DoubleVectorProperty>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="LinearKernel" class="vtkLinearKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="GeneralizedKernelBase">
      <Documentation>
        This is an interpolation kernel that averages the contributions
        of all points in the basis.
      </Documentation>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="ProbabilisticVoronoiKernel" class="vtkProbabilisticVoronoiKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="GeneralizedKernelBase">
      <Documentation>
        This is an interpolation kernel that interpolates
        from the closest weighted point from a neighborhood of points. The weights
        refer to the probabilistic weighting.
      </Documentation>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="ShepardKernel" class="vtkShepardKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="GeneralizedKernelBase">
      <Documentation>
        This is an interpolation kernel that uses the method of
        Shepard to perform interpolation. The weights are computed as 1/r^p, where
        r is the distance to a neighbor point within the kernel radius R; and p
        (the power parameter) is a positive exponent (typically p=2).
      </Documentation>

      <DoubleVectorProperty name="PowerParameter"
        command="SetPowerParameter"
        number_of_elements="1"
        default_values="2.0">
        <DoubleRangeDomain name="range" min="0.001" max="100" />
        <Documentation>
          Specify the power parameter p. By default p=2. Values (which must be
          a positive, real value) != 2 may affect performance significantly.
        </Documentation>
      </DoubleVectorProperty>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="SPHKernelBase" class="vtkSPHKernel">
      <DoubleVectorProperty name="SpatialStep"
        command="SetSpatialStep"
        number_of_elements="1"
        default_values="0.0001">
        <DoubleRangeDomain name="range" min="0" />
        <Documentation>
          Specify the initial particle spatial step.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="Dimension"
        command="SetDimension"
        number_of_elements="1"
        default_values="3">
        <IntRangeDomain name="range" min="1" max="3" />
        <Documentation>
          The domain dimension, default to 3.
        </Documentation>
      </IntVectorProperty>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="SPHCubicKernel" class="vtkSPHCubicKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="SPHKernelBase">
      <Documentation>
        This is an smooth particle hydrodynamics interpolation kernel as
        described by D.J. Price. This is a cubic formulation.
      </Documentation>
    </Proxy>

    <Proxy name="SPHQuarticKernel" class="vtkSPHQuarticKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="SPHKernelBase">
      <Documentation>
        This is an smooth particle hydrodynamics interpolation kernel as
        described by D.J. Price. This is a quartic formulation.
      </Documentation>
    </Proxy>

    <Proxy name="SPHQuinticKernel" class="vtkSPHQuinticKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="SPHKernelBase">
      <Documentation>
        This is an smooth particle hydrodynamics interpolation kernel as
        described by D.J. Price. This is a quintic formulation.
      </Documentation>
    </Proxy>

    <Proxy name="SPHWendlandQuinticKernel" class="vtkWendlandQuinticKernel"
           base_proxygroup="point_interpolation_kernels" base_proxyname="SPHKernelBase">
      <Documentation>
        This is an smooth particle hydrodynamics interpolation kernel as
        described by D.J. Price. This is a quintic formulation.
      </Documentation>
    </Proxy>

    <!-- =================================================================== -->
    <Proxy name="VoronoiKernel" class="vtkVoronoiKernel">
      <Documentation>
        This is an interpolation kernel that simply returns the
        closest point to a point to be interpolated. A single weight is returned
        with value=1.0.
      </Documentation>
    </Proxy>
  </ProxyGroup>

  <!-- =================================================================== -->
  <ProxyGroup name="filters">

    <!-- =================================================================== -->
    <SourceProxy name="SPHInterpolatorBase" class="vtkSPHInterpolator"
                 label="SPH Interpolator"
                 multiprocess_support="single_process">
      <Documentation>
        This filter uses SPH (smooth particle hydrodynamics) kernels to
        interpolate a data source onto an input structure. For example, while the
        data source is a set of particles, the data from these particles can be
        interpolated onto an input object such as a line, plane or volume. Then
        the output (which consists of the input structure plus interpolated data)
        can then be visualized using classical visualization techniques such as
        isocontouring, slicing, heat maps and so on.
      </Documentation>

      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="1">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point" name="point_scalars" number_of_components="1" />
        <InputArrayDomain attribute_type="point" name="point_arrays" />
        <Documentation>The data source to be interpolated onto the *Source*.</Documentation>
      </InputProperty>

      <StringVectorProperty name="DensityArray"
        command="SetDensityArrayName"
        number_of_elements="1"
        default_values="Rho">
        <Documentation>
          Specify the density array name.  This is required in computation. If not
          specified the code will error out.
        </Documentation>
        <ArrayListDomain attribute_type="Scalars" name="array_list" input_domain_name="point_scalars">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
      </StringVectorProperty>

      <StringVectorProperty name="MassArray"
        command="SetMassArrayName"
        number_of_elements="1">
        <Documentation>
          Specify the mass array name.  If not specified, then the mass at each point
          will be computed from the density and local (spherical) volume at a each
          point.
        </Documentation>
        <ArrayListDomain attribute_type="Scalars" name="array_list" none_string="None"
          input_domain_name="point_scalars">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
      </StringVectorProperty>

      <StringVectorProperty name="CutoffArray"
        command="SetCutoffArrayName"
        number_of_elements="1">
        <Documentation>
          Specify the Cutoff array name.  If not specified, then the radius at each point
          will be computed as cutoff factor * smoothing length at a each point.
        </Documentation>
        <ArrayListDomain attribute_type="Scalars" name="array_list" none_string="None"
          input_domain_name="point_scalars">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
      </StringVectorProperty>

      <StringVectorProperty name="ExcludedArrays"
        command="AddExcludedArray"
        clean_command="ClearExcludedArrays"
        number_of_elements_per_command="1"
        repeat_command="1" >
        <Documentation>
           Specify arrays which are to be excluded from the interpolation process.
         </Documentation>
        <ArrayListDomain name="array_list" input_domain_name="point_arrays">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This ensures that no array is selected by default -->
          <NoDefault />
        </Hints>
      </StringVectorProperty>

      <StringVectorProperty name="DerivativeArrays"
        command="AddDerivativeArray"
        clean_command="ClearDerivativeArrays"
        number_of_elements_per_command="1"
        repeat_command="1">
        <Documentation>
          Specify the arrays whose derivative is to be taken. If
          the name of the array is "derivArray" this will produce an output array
          with the name "derivArray_deriv" (after filter execution).
         </Documentation>
        <ArrayListDomain name="array_list" input_domain_name="point_arrays">
          <RequiredProperties>
            <Property function="Input" name="Input" />
          </RequiredProperties>
        </ArrayListDomain>
        <Hints>
          <!-- This ensures that no array is selected by default -->
          <NoDefault />
        </Hints>
      </StringVectorProperty>

      <PropertyGroup label="Array Selections">
        <Property name="DensityArray" />
        <Property name="MassArray" />
        <Property name="CutoffArray" />
        <Property name="ExcludedArrays" />
        <Property name="DerivativeArrays" />
      </PropertyGroup>

      <ProxyProperty name="Kernel" command="SetKernel" >
        Specify an interpolation kernel. The interpolation kernel changes the basis of the
        interpolation.
        <ProxyListDomain name="proxy_list">
          <Proxy group="point_interpolation_kernels" name="SPHQuinticKernel" />
          <Proxy group="point_interpolation_kernels" name="SPHCubicKernel" />
          <Proxy group="point_interpolation_kernels" name="SPHQuarticKernel" />
          <Proxy group="point_interpolation_kernels" name="SPHWendlandQuinticKernel" />
        </ProxyListDomain>
      </ProxyProperty>

      <IntVectorProperty name="NullPointsStrategy"
        command="SetNullPointsStrategy"
        number_of_elements="1"
        default_values="1"
        panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Mask Points" value="0" />
          <Entry text="Null Value" value="1" />
        </EnumerationDomain>
        <Documentation>
          Specify a strategy to use when encountering a "null" point during the
          interpolation process. Null points occur when the local neighborhood (of
          nearby points to interpolate from) is empty. If the strategy is set to
          MaskPoints, then an output array is created that marks points as being
          valid (=1) or null (invalid =0) (and the NullValue is set as well). If
          the strategy is set to NullValue, then the output data value(s) are set
          to the NullPoint value (specified in the output point data).
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="ComputeShepardSum"
        command="SetComputeShepardSum"
        number_of_elements="1"
        default_values="1"
        panel_visibility="advanced">
        <BooleanDomain name="bool" />
        <Documentation>
          Indicate whether to compute the summation of Shepard coefficients. In the
          interior of a SPH point cloud, the Shephard summation value should be ~1.0.
          Towards the boundary, the Shepard summation is less than 1.0. If ComputeShepardSum
          is specified, then the output will contain an array of summed Shepard weights
          for each output point.
        </Documentation>
      </IntVectorProperty>

      <StringVectorProperty name="ShepardSumArrayName"
        command="SetShepardSumArrayName"
        number_of_elements="1"
        default_values="Shepard Summation"
        panel_visibility="advanced">
        <Documentation>
          If ComputeShepardSum is on, then an array is generated with name
          ShepardSumArrayName for each input point. This vtkFloatArray is placed
          into the output of the filter, and NullPoints have value =0.0. The
          default name is "Shepard Summation".
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
            mode="enabled_state" property="ComputeShepardSum" value="1" />
        </Hints>
      </StringVectorProperty>

      <StringVectorProperty name="ValidPointsMaskArrayName"
        command="SetValidPointsMaskArrayName"
        number_of_elements="1"
        default_values="vtkValidPointMask"
        panel_visibility="advanced">
        <Documentation>
          If the NullPointsStrategy is "Mask Points", then an array is generated for
          each input point. This vtkCharArray is placed into the output of the filter,
          with a non-zero value for a valid point, and zero otherwise. The name of
          this masking array is specified here.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
            mode="enabled_state" property="NullPointsStrategy" value="0" />
        </Hints>
      </StringVectorProperty>

      <DoubleVectorProperty name="NullValue"
        command="SetNullValue"
        number_of_elements="1"
        default_values="0.0"
        panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>
          Specify the null point value. When a null point is encountered then all
          components of each null tuple are set to this value. By default the
          null value is set to zero.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="PassPointArrays"
        command="SetPassPointArrays"
        number_of_elements="1"
        default_values="0"
        panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>
          Indicate whether to shallow copy the input point data arrays to the output.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="PassCellArrays"
        command="SetPassCellArrays"
        number_of_elements="1"
        default_values="0"
        panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>
          Indicate whether to shallow copy the input cell data arrays to the output.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="PassFieldArrays"
        command="SetPassFieldArrays"
        number_of_elements="1"
        default_values="0"
        panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>
          Indicate whether to shallow copy the input field data arrays to the output.
        </Documentation>
      </IntVectorProperty>

      <ProxyProperty name="Locator" command="SetLocator" panel_visibility="advanced">
        <Documentation>
          Specify a point locator.
        </Documentation>
        <ProxyListDomain name="proxy_list">
          <Proxy group="point_locators" name="StaticPointLocator" />
        </ProxyListDomain>
      </ProxyProperty>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="SPHLineInterpolator" class="vtkSPHInterpolator"
                 label="SPH Line Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="SPHInterpolatorBase">
      <Documentation>
        This filter uses SPH (smooth particle hydrodynamics) kernels to
        interpolate a data source onto an input structure. For example, while the
        data source is a set of particles, the data from these particles can be
        interpolated onto an input line. Then
        the output (which consists of the input structure plus interpolated data)
        can then be visualized using classical visualization techniques such as
        isocontouring, slicing, heat maps and so on.
      </Documentation>
      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources" name="HighResLineSource" />
        </ProxyListDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
      <Hints>
        <View type="XYChartView" />
        <Plotable />
      </Hints>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="SPHPlaneInterpolator" class="vtkSPHInterpolator"
                 label="SPH Plane Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="SPHInterpolatorBase">
      <Documentation>
        This filter uses SPH (smooth particle hydrodynamics) kernels to
        interpolate a data source onto an input structure. For example, while the
        data source is a set of particles, the data from these particles can be
        interpolated onto an input plane. Then
        the output (which consists of the input structure plus interpolated data)
        can then be visualized using classical visualization techniques such as
        isocontouring, slicing, heat maps and so on.
      </Documentation>

      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources" name="BoundedPlaneSource" />
        </ProxyListDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="SPHVolumeInterpolator" class="vtkSPHInterpolator"
                 label="SPH Volume Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="SPHInterpolatorBase">
      <Documentation>
        This filter uses SPH (smooth particle hydrodynamics) kernels to
        interpolate a data source onto an input structure. For example, while the
        data source is a set of particles, the data from these particles can be
        interpolated onto an input volume. Then
        the output (which consists of the input structure plus interpolated data)
        can then be visualized using classical visualization techniques such as
        isocontouring, slicing, heat maps and so on.
      </Documentation>

      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources" name="BoundedVolumeSource" />
        </ProxyListDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="SPHDatasetInterpolator" class="vtkSPHInterpolator"
                 label="SPH Dataset Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="SPHInterpolatorBase">
      <Documentation>
        This filter uses SPH (smooth particle hydrodynamics) kernels to
        interpolate a data source onto an input structure. For example, while the
        data source is a set of particles, the data from these particles can be
        interpolated onto an input volume. Then
        the output (which consists of the input structure plus interpolated data)
        can then be visualized using classical visualization techniques such as
        isocontouring, slicing, heat maps and so on.
      </Documentation>

      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="PointInterpolatorBase" class="vtkPointInterpolator"
      label="Point Interpolator"
      multiprocess_support="single_process">
      <Documentation>
        This probes a point cloud `PC` on the *Input* with a
        set of points `P` (the filter *Source*), interpolating the data values from `PC`
        onto `P`. Note however that the descriptive phrase "point cloud" is a
        misnomer: PC can be represented by any dataset type, with the points of
        the dataset forming PC. Similarly, the output P can also be represented by
        any vtkDataSet type; and the topology/geometry structure of P is passed
        through to the output along with the newly interpolated arrays.
      </Documentation>

      <InputProperty command="SetInputConnection"
                     name="Input"
                     port_index="1">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkPointSet" />
        </DataTypeDomain>
        <InputArrayDomain attribute_type="point" name="point_scalars" number_of_components="1" />
        <InputArrayDomain attribute_type="point" name="point_arrays" />
        <Documentation>The data source to be interpolated onto the *Source*.</Documentation>
      </InputProperty>

      <ProxyProperty name="Kernel" command="SetKernel">
        <Documentation>
           Specify an interpolation kernel. By default a vtkVoronoiKernel is used
           (i.e., closest point). The interpolation kernel changes the basis of the
           interpolation.
        </Documentation>
        <ProxyListDomain name="proxy_list">
          <Proxy group="point_interpolation_kernels" name="VoronoiKernel" />
          <Proxy group="point_interpolation_kernels" name="EllipsoidalGaussianKernel" />
          <Proxy group="point_interpolation_kernels" name="GaussianKernel" />
          <Proxy group="point_interpolation_kernels" name="LinearKernel" />
          <Proxy group="point_interpolation_kernels" name="ProbabilisticVoronoiKernel" />
          <Proxy group="point_interpolation_kernels" name="ShepardKernel" />
          <Proxy group="point_interpolation_kernels" name="VoronoiKernel" />
        </ProxyListDomain>
      </ProxyProperty>

      <IntVectorProperty name="NullPointsStrategy"
        command="SetNullPointsStrategy"
        number_of_elements="1"
        default_values="1"
        panel_visibility="advanced">
        <EnumerationDomain name="enum">
          <Entry text="Mask Points" value="0" />
          <Entry text="Null Value" value="1" />
          <Entry text="Closest Point" value="1" />
        </EnumerationDomain>
        <Documentation>
          Specify a strategy to use when encountering a "null" point during the
          interpolation process. Null points occur when the local neighborhood (of
          nearby points to interpolate from) is empty. If the strategy is set to
          MaskPoints, then an output array is created that marks points as being
          valid (=1) or null (invalid =0) (and the NullValue is set as well). If
          the strategy is set to NullValue, then the output data value(s) are set
          to the NullPoint value (specified in the output point data). Finally,
          the default strategy ClosestPoint is to simply use the closest point to
          perform the interpolation.
        </Documentation>
      </IntVectorProperty>

      <StringVectorProperty name="ValidPointsMaskArrayName"
        command="SetValidPointsMaskArrayName"
        number_of_elements="1"
        default_values="vtkValidPointMask"
        panel_visibility="advanced">
        <Documentation>
          If the NullPointsStrategy is "Mask Points", then an array is generated for
          each input point. This vtkCharArray is placed into the output of the filter,
          with a non-zero value for a valid point, and zero otherwise. The name of
          this masking array is specified here.
        </Documentation>
        <Hints>
          <PropertyWidgetDecorator type="GenericDecorator"
            mode="enabled_state" property="NullPointsStrategy" value="0" />
        </Hints>
      </StringVectorProperty>

      <DoubleVectorProperty name="NullValue"
        command="SetNullValue"
        number_of_elements="1"
        default_values="0.0"
        panel_visibility="advanced">
        <DoubleRangeDomain name="range" />
        <Documentation>
          Specify the null point value. When a null point is encountered then all
          components of each null tuple are set to this value. By default the
          null value is set to zero.
        </Documentation>
      </DoubleVectorProperty>

      <IntVectorProperty name="PassPointArrays"
        command="SetPassPointArrays"
        number_of_elements="1"
        default_values="0"
        panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>
          Indicate whether to shallow copy the input point data arrays to the output.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="PassCellArrays"
        command="SetPassCellArrays"
        number_of_elements="1"
        default_values="0"
        panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>
          Indicate whether to shallow copy the input cell data arrays to the output.
        </Documentation>
      </IntVectorProperty>

      <IntVectorProperty name="PassFieldArrays"
        command="SetPassFieldArrays"
        number_of_elements="1"
        default_values="0"
        panel_visibility="never">
        <BooleanDomain name="bool" />
        <Documentation>
          Indicate whether to shallow copy the input field data arrays to the output.
        </Documentation>
      </IntVectorProperty>

      <ProxyProperty name="Locator" command="SetLocator" panel_visibility="advanced">
        <Documentation>
          Specify a point locator.
        </Documentation>
        <ProxyListDomain name="proxy_list">
          <Proxy group="point_locators" name="StaticPointLocator" />
        </ProxyListDomain>
      </ProxyProperty>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="PointLineInterpolator" class="vtkPointInterpolator"
                 label="Point Line Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="PointInterpolatorBase">
      <Documentation>
        This probes a point cloud `PC` on the *Input* with a
        set of points `P` (the filter *Source*), interpolating the data values from `PC`
        onto `P`. Note however that the descriptive phrase "point cloud" is a
        misnomer: PC can be represented by any dataset type, with the points of
        the dataset forming PC. Similarly, the output P can also be represented by
        any vtkDataSet type; and the topology/geometry structure of P is passed
        through to the output along with the newly interpolated arrays.
      </Documentation>
      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources" name="HighResLineSource" />
        </ProxyListDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
      <Hints>
        <View type="XYChartView" />
        <Plotable />
      </Hints>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="PointPlaneInterpolator" class="vtkPointInterpolator"
                 label="Point Plane Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="PointInterpolatorBase">
      <Documentation>
        This probes a point cloud `PC` on the *Input* with a
        set of points `P` (the filter *Source*), interpolating the data values from `PC`
        onto `P`. Note however that the descriptive phrase "point cloud" is a
        misnomer: PC can be represented by any dataset type, with the points of
        the dataset forming PC. Similarly, the output P can also be represented by
        any vtkDataSet type; and the topology/geometry structure of P is passed
        through to the output along with the newly interpolated arrays.
      </Documentation>

      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources" name="BoundedPlaneSource" />
        </ProxyListDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="PointVolumeInterpolator" class="vtkPointInterpolator"
                 label="Point Volume Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="PointInterpolatorBase">
      <Documentation>
        This probes a point cloud `PC` on the *Input* with a
        set of points `P` (the filter *Source*), interpolating the data values from `PC`
        onto `P`. Note however that the descriptive phrase "point cloud" is a
        misnomer: PC can be represented by any dataset type, with the points of
        the dataset forming PC. Similarly, the output P can also be represented by
        any vtkDataSet type; and the topology/geometry structure of P is passed
        through to the output along with the newly interpolated arrays.
      </Documentation>
      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <ProxyListDomain name="proxy_list">
          <Proxy group="extended_sources" name="BoundedVolumeSource" />
        </ProxyListDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
    </SourceProxy>

    <!-- =================================================================== -->
    <SourceProxy name="PointDatasetInterpolator" class="vtkPointInterpolator"
                 label="Point Dataset Interpolator"
                 multiprocess_support="single_process"
                 base_proxygroup="filters"
                 base_proxyname="PointInterpolatorBase">
      <Documentation>
        This probes a point cloud `PC` on the *Input* with a
        set of points `P` (the filter *Source*), interpolating the data values from `PC`
        onto `P`. Note however that the descriptive phrase "point cloud" is a
        misnomer: PC can be represented by any dataset type, with the points of
        the dataset forming PC. Similarly, the output P can also be represented by
        any vtkDataSet type; and the topology/geometry structure of P is passed
        through to the output along with the newly interpolated arrays.
      </Documentation>
      <InputProperty command="SetInputConnection" name="Source" port_index="0">
        <ProxyGroupDomain name="groups">
          <Group name="sources" />
          <Group name="filters" />
        </ProxyGroupDomain>
        <DataTypeDomain name="input_type">
          <DataType value="vtkDataSet" />
        </DataTypeDomain>
        <Documentation>The data source that provides the structure to be interpolated on.</Documentation>
      </InputProperty>
    </SourceProxy>
  </ProxyGroup>
</ServerManagerConfiguration>
