/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkbwidgets.h
  Language:  C++
  Date:      $Date$
  Version:   $Revision$

Copyright (c) 2000-2001 Kitware Inc. 469 Clifton Corporate Parkway,
Clifton Park, NY, 12065, USA.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name of Kitware nor the names of any contributors may be used
   to endorse or promote products derived from this software without specific 
   prior written permission.

 * Modified source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=========================================================================*/

/*
BWidget ToolKit
Copyright (c) 1998-1999 UNIFIX. 
Copyright (c) 2001-2002 ActiveState Corp. 

The following terms apply to all files associated with the software
unless explicitly disclaimed in individual files.

The authors hereby grant permission to use, copy, modify, distribute,
and license this software and its documentation for any purpose, provided
that existing copyright notices are retained in all copies and that this
notice is included verbatim in any distributions. No written agreement,
license, or royalty fee is required for any of the authorized uses.
Modifications to this software may be copyrighted by their authors
and need not follow the licensing terms described here, provided that
the new terms are clearly indicated on the first page of each file where
they apply.

IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.

GOVERNMENT USE: If you are acquiring this software on behalf of the
U.S. government, the Government shall have only "Restricted Rights"
in the software and related documentation as defined in the Federal 
Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
are acquiring the software on behalf of the Department of Defense, the
software shall be classified as "Commercial Computer Software" and the
Government shall have only "Restricted Rights" as defined in Clause
252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing, the
authors grant the U.S. Government and others acting in its behalf
permission to use and distribute the software in accordance with the
terms specified in this license. 
*/

const char* bwidgets =
"# ----------------------------------------------------------------------------\n"
"#  widget.tcl\n"
"#  This file is part of Unifix BWidget Toolkit\n"
"#  Id\n"
"# ----------------------------------------------------------------------------\n"
"namespace eval Widget {\n"
"    variable _optiontype\n"
"    variable _class\n"
"    variable _tk_widget\n"
"\n"
"    array set _optiontype {\n"
"        TkResource Widget::_test_tkresource\n"
"        BwResource Widget::_test_bwresource\n"
"        Enum       Widget::_test_enum\n"
"        Int        Widget::_test_int\n"
"        Boolean    Widget::_test_boolean\n"
"        String     Widget::_test_string\n"
"        Flag       Widget::_test_flag\n"
"        Synonym    Widget::_test_synonym\n"
"        Color      Widget::_test_color\n"
"    }\n"
"\n"
"    proc use {} {}\n"
"}\n"
"\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::declare\n"
"#    Declares new options to BWidget class.\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::declare { class optlist } {\n"
"    variable _optiontype\n"
"\n"
"    namespace eval $class {}\n"
"    upvar 0 ${class}::opt classopt\n"
"    upvar 0 ${class}::optionExports exports\n"
"    upvar 0 ${class}::optionClass optionClass\n"
"\n"
"    foreach optdesc $optlist {\n"
"        set option  [lindex $optdesc 0]\n"
"        set optdesc [lrange $optdesc 1 end]\n"
"        set type    [lindex $optdesc 0]\n"
"\n"
"        if { ![info exists _optiontype($type)] } {\n"
"            # invalid resource type\n"
"            return -code error \"invalid option type \\\"$type\\\"\"\n"
"        }\n"
"\n"
"        if { ![string compare $type \"Synonym\"] } {\n"
"            # test existence of synonym option\n"
"            set syn [lindex $optdesc 1]\n"
"            if { ![info exists classopt($syn)] } {\n"
"                return -code error \"unknow option \\\"$syn\\\" for Synonym \\\"$option\\\"\"\n"
"            }\n"
"            set classopt($option) [list Synonym $syn]\n"
"            continue\n"
"        }\n"
"\n"
"        # all other resource may have default value, readonly flag and\n"
"        # optional arg depending on type\n"
"        set value [lindex $optdesc 1]\n"
"        set ro    [lindex $optdesc 2]\n"
"        set arg   [lindex $optdesc 3]\n"
"\n"
"        if { ![string compare $type \"BwResource\"] } {\n"
"            set subclass    [lindex $arg 0]\n"
"            set realopt     [lindex $arg 1]\n"
"            if { ![string length $realopt] } {\n"
"                set realopt $option\n"
"            }\n"
"\n"
"            upvar 0 ${subclass}::opt subclassopt\n"
"            if { ![info exists subclassopt($realopt)] } {\n"
"                return -code error \"unknow option \\\"$realopt\\\"\"\n"
"            }\n"
"            set suboptdesc $subclassopt($realopt)\n"
"            if { $value == \"\" } {\n"
"                # We initialize default value\n"
"                set value [lindex $suboptdesc 1]\n"
"            }\n"
"            set type [lindex $suboptdesc 0]\n"
"            set ro   [lindex $suboptdesc 2]\n"
"            set arg  [lindex $suboptdesc 3]\n"
"	    set optionDbName \".[lindex [_configure_option $option \"\"] 0]\"\n"
"	    option add *${class}${optionDbName} $value widgetDefault\n"
"	    set exports($option) $optionDbName\n"
"            set classopt($option) [list $type $value $ro $arg]\n"
"            continue\n"
"        }\n"
"\n"
"        # retreive default value for TkResource\n"
"        if { ![string compare $type \"TkResource\"] } {\n"
"            set tkwidget [lindex $arg 0]\n"
"	    set foo [$tkwidget \".ericFoo##\"]\n"
"            set realopt  [lindex $arg 1]\n"
"            if { ![string length $realopt] } {\n"
"                set realopt $option\n"
"            }\n"
"            set tkoptions [_get_tkwidget_options $tkwidget]\n"
"            if { ![string length $value] } {\n"
"                # We initialize default value\n"
"		set ind [lsearch $tkoptions [list $realopt *]]\n"
"                set value [lindex [lindex $tkoptions $ind] end]\n"
"            }\n"
"	    set optionDbName \".[lindex [_configure_option $option \"\"] 0]\"\n"
"	    option add *${class}${optionDbName} $value widgetDefault\n"
"	    set exports($option) $optionDbName\n"
"            set classopt($option) [list TkResource $value $ro \\\n"
"		    [list $tkwidget $realopt]]\n"
"	    set optionClass($option) [lindex [$foo configure $realopt] 1]\n"
"	    ::destroy $foo\n"
"            continue\n"
"        }\n"
"\n"
"	set optionDbName \".[lindex [_configure_option $option \"\"] 0]\"\n"
"	option add *${class}${optionDbName} $value widgetDefault\n"
"	set exports($option) $optionDbName\n"
"        # for any other resource type, we keep original optdesc\n"
"        set classopt($option) [list $type $value $ro $arg]\n"
"    }\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::addmap\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::addmap { class subclass subpath options } {\n"
"    upvar 0 ${class}::opt classopt\n"
"    upvar 0 ${class}::optionExports exports\n"
"    upvar 0 ${class}::optionClass optionClass\n"
"    upvar 0 ${class}::map classmap\n"
"    upvar 0 ${class}::map$subpath submap\n"
"\n"
"    foreach {option realopt} $options {\n"
"        if { ![string length $realopt] } {\n"
"            set realopt $option\n"
"        }\n"
"	set val [lindex $classopt($option) 1]\n"
"	set optDb \".[lindex [_configure_option $realopt \"\"] 0]\"\n"
"	if { ![string equal $subpath \":cmd\"] } {\n"
"	    set optDb \"$subpath$optDb\"\n"
"	}\n"
"	option add *${class}${optDb} $val widgetDefault\n"
"	lappend exports($option) $optDb\n"
"	# Store the forward and backward mappings for this\n"
"	# option <-> realoption pair\n"
"        lappend classmap($option) $subpath $subclass $realopt\n"
"	set submap($realopt) $option\n"
"    }\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::syncoptions\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::syncoptions { class subclass subpath options } {\n"
"    upvar 0 ${class}::sync classync\n"
"\n"
"    foreach {option realopt} $options {\n"
"        if { ![string length $realopt] } {\n"
"            set realopt $option\n"
"        }\n"
"        set classync($option) [list $subpath $subclass $realopt]\n"
"    }\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::init\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::init { class path options } {\n"
"    upvar 0 ${class}::opt classopt\n"
"    upvar 0 ${class}::$path:opt  pathopt\n"
"    upvar 0 ${class}::$path:mod  pathmod\n"
"    upvar 0 ${class}::map classmap\n"
"    upvar 0 ${class}::$path:init pathinit\n"
"\n"
"    if { [info exists pathopt] } {\n"
"	unset pathopt\n"
"    }\n"
"    if { [info exists pathmod] } {\n"
"	unset pathmod\n"
"    }\n"
"    # We prefer to use the actual widget for option db queries, but if it\n"
"    set fpath $path\n"
"    set rdbclass [string map [list :: \"\"] $class]\n"
"    if { ![winfo exists $path] } {\n"
"	set fpath \".#BWidgetClass#$class\"\n"
"	if { ![winfo exists $fpath] } {\n"
"	    frame $fpath -class $rdbclass\n"
"	}\n"
"    }\n"
"    foreach {option optdesc} [array get classopt] {\n"
"        set pathmod($option) 0\n"
"	if { [info exists classmap($option)] } {\n"
"	    continue\n"
"	}\n"
"        set type [lindex $optdesc 0]\n"
"        if { ![string compare $type \"Synonym\"] } {\n"
"	    continue\n"
"        }\n"
"        if { ![string compare $type \"TkResource\"] } {\n"
"            set alt [lindex [lindex $optdesc 3] 1]\n"
"        } else {\n"
"            set alt \"\"\n"
"        }\n"
"        set optdb [lindex [_configure_option $option $alt] 0]\n"
"        set def   [option get $fpath $optdb $rdbclass]\n"
"        if { [string length $def] } {\n"
"            set pathopt($option) $def\n"
"        } else {\n"
"            set pathopt($option) [lindex $optdesc 1]\n"
"        }\n"
"    }\n"
"\n"
"    set Widget::_class($path) $class\n"
"    foreach {option value} $options {\n"
"        if { ![info exists classopt($option)] } {\n"
"            unset pathopt\n"
"            unset pathmod\n"
"            return -code error \"unknown option \\\"$option\\\"\"\n"
"        }\n"
"        set optdesc $classopt($option)\n"
"        set type    [lindex $optdesc 0]\n"
"        if { ![string compare $type \"Synonym\"] } {\n"
"            set option  [lindex $optdesc 1]\n"
"            set optdesc $classopt($option)\n"
"            set type    [lindex $optdesc 0]\n"
"        }\n"
"        set pathopt($option) [$Widget::_optiontype($type) $option $value [lindex $optdesc 3]]\n"
"	set pathinit($option) $pathopt($option)\n"
"    }\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::configure\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::configure { path options } {\n"
"    set len [llength $options]\n"
"    if { $len <= 1 } {\n"
"        return [_get_configure $path $options]\n"
"    } elseif { $len % 2 == 1 } {\n"
"        return -code error \"incorrect number of arguments\"\n"
"    }\n"
"\n"
"    variable _class\n"
"    variable _optiontype\n"
"\n"
"    set class $_class($path)\n"
"    upvar 0 ${class}::opt  classopt\n"
"    upvar 0 ${class}::map  classmap\n"
"    upvar 0 ${class}::$path:opt pathopt\n"
"    upvar 0 ${class}::$path:mod pathmod\n"
"\n"
"    set window [_get_window $class $path]\n"
"    foreach {option value} $options {\n"
"        if { ![info exists classopt($option)] } {\n"
"            return -code error \"unknown option \\\"$option\\\"\"\n"
"        }\n"
"        set optdesc $classopt($option)\n"
"        set type    [lindex $optdesc 0]\n"
"        if { ![string compare $type \"Synonym\"] } {\n"
"            set option  [lindex $optdesc 1]\n"
"            set optdesc $classopt($option)\n"
"            set type    [lindex $optdesc 0]\n"
"        }\n"
"        if { ![lindex $optdesc 2] } {\n"
"            set newval [$_optiontype($type) $option $value [lindex $optdesc 3]]\n"
"            if { [info exists classmap($option)] } {\n"
"		set window [_get_window $class $window]\n"
"                foreach {subpath subclass realopt} $classmap($option) {\n"
"                    if { [string length $subclass] } {\n"
"			set curval [${subclass}::cget $window$subpath $realopt]\n"
"                        ${subclass}::configure $window$subpath $realopt $newval\n"
"                    } else {\n"
"			set curval [$window$subpath cget $realopt]\n"
"                        $window$subpath configure $realopt $newval\n"
"                    }\n"
"                }\n"
"            } else {\n"
"		set curval $pathopt($option)\n"
"		set pathopt($option) $newval\n"
"	    }\n"
"	    set pathmod($option) [expr {![string equal $newval $curval]}]\n"
"        }\n"
"    }\n"
"\n"
"    return {}\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::cget\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::cget { path option } {\n"
"    if { ![info exists ::Widget::_class($path)] } {\n"
"        return -code error \"unknown widget $path\"\n"
"    }\n"
"\n"
"    set class $::Widget::_class($path)\n"
"    if { ![info exists ${class}::opt($option)] } {\n"
"        return -code error \"unknown option \\\"$option\\\"\"\n"
"    }\n"
"\n"
"    set optdesc [set ${class}::opt($option)]\n"
"    set type    [lindex $optdesc 0]\n"
"    if { ![string compare $type \"Synonym\"] } {\n"
"        set option [lindex $optdesc 1]\n"
"    }\n"
"\n"
"    if { [info exists ${class}::map($option)] } {\n"
"	foreach {subpath subclass realopt} [set ${class}::map($option)] {break}\n"
"	set path \"[_get_window $class $path]$subpath\"\n"
"	return [$path cget $realopt]\n"
"    }\n"
"    upvar 0 ${class}::$path:opt pathopt\n"
"    set pathopt($option)\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::subcget\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::subcget { path subwidget } {\n"
"    set class $::Widget::_class($path)\n"
"    upvar 0 ${class}::$path:opt pathopt\n"
"    upvar 0 ${class}::map$subwidget submap\n"
"    upvar 0 ${class}::$path:init pathinit\n"
"\n"
"    set result {}\n"
"    foreach realopt [array names submap] {\n"
"	if { [info exists pathinit($submap($realopt))] } {\n"
"	    lappend result $realopt $pathopt($submap($realopt))\n"
"	}\n"
"    }\n"
"    return $result\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::hasChanged\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::hasChanged { path option pvalue } {\n"
"    upvar    $pvalue value\n"
"    set class $::Widget::_class($path)\n"
"    upvar 0 ${class}::$path:mod pathmod\n"
"\n"
"    set value   [Widget::cget $path $option]\n"
"    set result  $pathmod($option)\n"
"    set pathmod($option) 0\n"
"\n"
"    return $result\n"
"}\n"
"\n"
"proc Widget::hasChangedX { path option args } {\n"
"    set class $::Widget::_class($path)\n"
"    upvar 0 ${class}::$path:mod pathmod\n"
"\n"
"    set result  $pathmod($option)\n"
"    set pathmod($option) 0\n"
"    foreach option $args {\n"
"	lappend result $pathmod($option)\n"
"	set pathmod($option) 0\n"
"    }\n"
"\n"
"    set result\n"
"}\n"
"\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::getoption\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::getoption { path option } {\n"
"#    set class $::Widget::_class($path)\n"
"#    upvar 0 ${class}::$path:opt pathopt\n"
"\n"
"#    return $pathopt($option)\n"
"    return [Widget::cget $path $option]\n"
"}\n"
"\n"
"# Widget::getMegawidgetOption --\n"
"#\n"
"#	Bypass the superfluous checks in cget and just directly peer at the\n"
"#	widgets data space.  This is much more fragile than cget, so it \n"
"#	should only be used with great care, in places where speed is critical.\n"
"#\n"
"# Arguments:\n"
"#	path	widget to lookup options for.\n"
"#	option	option to retrieve.\n"
"#\n"
"# Results:\n"
"#	value	option value.\n"
"\n"
"proc Widget::getMegawidgetOption {path option} {\n"
"    set class $::Widget::_class($path)\n"
"    upvar 0 ${class}::${path}:opt pathopt\n"
"    set pathopt($option)\n"
"}\n"
"\n"
"# Widget::setMegawidgetOption --\n"
"#\n"
"#	Bypass the superfluous checks in cget and just directly poke at the\n"
"#	widgets data space.  This is much more fragile than configure, so it \n"
"#	should only be used with great care, in places where speed is critical.\n"
"#\n"
"# Arguments:\n"
"#	path	widget to lookup options for.\n"
"#	option	option to retrieve.\n"
"#	value	option value.\n"
"#\n"
"# Results:\n"
"#	value	option value.\n"
"\n"
"proc Widget::setMegawidgetOption {path option value} {\n"
"    set class $::Widget::_class($path)\n"
"    upvar 0 ${class}::${path}:opt pathopt\n"
"    set pathopt($option) $value\n"
"}\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_get_window\n"
"#  returns the window corresponding to widget path\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_get_window { class path } {\n"
"    set idx [string last \"#\" $path]\n"
"    if { $idx != -1 && ![string compare [string range $path [expr {$idx+1}] end] $class] } {\n"
"        return [string range $path 0 [expr {$idx-1}]]\n"
"    } else {\n"
"        return $path\n"
"    }\n"
"}\n"
"\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_configure_option\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_configure_option { option altopt } {\n"
"    variable _optiondb\n"
"    variable _optionclass\n"
"\n"
"    if { [info exists _optiondb($option)] } {\n"
"        set optdb $_optiondb($option)\n"
"    } else {\n"
"        set optdb [string range $option 1 end]\n"
"    }\n"
"    if { [info exists _optionclass($option)] } {\n"
"        set optclass $_optionclass($option)\n"
"    } elseif { [string length $altopt] } {\n"
"        if { [info exists _optionclass($altopt)] } {\n"
"            set optclass $_optionclass($altopt)\n"
"        } else {\n"
"            set optclass [string range $altopt 1 end]\n"
"        }\n"
"    } else {\n"
"        set optclass [string range $option 1 end]\n"
"    }\n"
"    return [list $optdb $optclass]\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_get_tkwidget_options\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_get_tkwidget_options { tkwidget } {\n"
"    variable _tk_widget\n"
"    variable _optiondb\n"
"    variable _optionclass\n"
"    \n"
"    set widget \".#BWidget#$tkwidget\"\n"
"    if { ![winfo exists $widget] || ![info exists _tk_widget($tkwidget)] } {\n"
"        set widget [$tkwidget $widget]\n"
"        set config [$widget configure]\n"
"        foreach optlist $config {\n"
"            set opt [lindex $optlist 0]\n"
"            if { [llength $optlist] == 2 } {\n"
"                set refsyn [lindex $optlist 1]\n"
"                # search for class\n"
"                set idx [lsearch $config [list * $refsyn *]]\n"
"                if { $idx == -1 } {\n"
"                    if { [string index $refsyn 0] == \"-\" } {\n"
"                        # search for option (tk8.1b1 bug)\n"
"                        set idx [lsearch $config [list $refsyn * *]]\n"
"                    } else {\n"
"                        # last resort\n"
"                        set idx [lsearch $config [list -[string tolower $refsyn] * *]]\n"
"                    }\n"
"                    if { $idx == -1 } {\n"
"                        # fed up with \"can't read classopt()\"\n"
"                        return -code error \"can't find option of synonym $opt\"\n"
"                    }\n"
"                }\n"
"                set syn [lindex [lindex $config $idx] 0]\n"
"		# JDC: used 4 (was 3) to get def from optiondb\n"
"                set def [lindex [lindex $config $idx] 4]\n"
"                lappend _tk_widget($tkwidget) [list $opt $syn $def]\n"
"            } else {\n"
"		# JDC: used 4 (was 3) to get def from optiondb\n"
"                set def [lindex $optlist 4]\n"
"                lappend _tk_widget($tkwidget) [list $opt $def]\n"
"                set _optiondb($opt)    [lindex $optlist 1]\n"
"                set _optionclass($opt) [lindex $optlist 2]\n"
"            }\n"
"        }\n"
"    }\n"
"    return $_tk_widget($tkwidget)\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_test_tkresource\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_test_tkresource { option value arg } {\n"
"#    set tkwidget [lindex $arg 0]\n"
"#    set realopt  [lindex $arg 1]\n"
"    foreach {tkwidget realopt} $arg break\n"
"    set path     \".#BWidget#$tkwidget\"\n"
"    set old      [$path cget $realopt]\n"
"    $path configure $realopt $value\n"
"    set res      [$path cget $realopt]\n"
"    $path configure $realopt $old\n"
"\n"
"    return $res\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_test_bwresource\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_test_bwresource { option value arg } {\n"
"    return -code error \"bad option type BwResource in widget\"\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_test_synonym\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_test_synonym { option value arg } {\n"
"    return -code error \"bad option type Synonym in widget\"\n"
"}\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_test_color\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_test_color { option value arg } {\n"
"    if {[catch {winfo rgb . $value} color]} {\n"
"        return -code error \"bad $option value \\\"$value\\\": must be a colorname \\\n"
"		or #RRGGBB triplet\"\n"
"    }\n"
"\n"
"    return $value\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_test_string\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_test_string { option value arg } {\n"
"    set value\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::_test_flag\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::_test_flag { option value arg } {\n"
"    set len [string length $value]\n"
"    set res \"\"\n"
"    for {set i 0} {$i < $len} {incr i} {\n"
"        set c [string index $value $i]\n"
"        if { [string first $c $arg] == -1 } {\n"
"            return -code error \"bad [string range $option 1 end] value \\\"$value\\\": characters must be in \\\"$arg\\\"\"\n"
"        }\n"
"        if { [string first $c $res] == -1 } {\n"
"            append res $c\n"
"        }\n"
"    }\n"
"    return $res\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command Widget::_test_enum\n"
"# -----------------------------------------------------------------------------\n"
"proc Widget::_test_enum { option value arg } {\n"
"    if { [lsearch $arg $value] == -1 } {\n"
"        set last [lindex   $arg end]\n"
"        set sub  [lreplace $arg end end]\n"
"        if { [llength $sub] } {\n"
"            set str \"[join $sub \", \"] or $last\"\n"
"        } else {\n"
"            set str $last\n"
"        }\n"
"        return -code error \"bad [string range $option 1 end] value \\\"$value\\\": must be $str\"\n"
"    }\n"
"    return $value\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command Widget::_test_int\n"
"# -----------------------------------------------------------------------------\n"
"proc Widget::_test_int { option value arg } {\n"
"    if { ![string is int -strict $value] || \\\n"
"	    ([string length $arg] && \\\n"
"	    ![expr [string map [list %d $value] $arg]]) } {\n"
"		    return -code error \"bad $option value\\\n"
"			    \\\"$value\\\": must be integer ($arg)\"\n"
"    }\n"
"    return $value\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command Widget::_test_boolean\n"
"# -----------------------------------------------------------------------------\n"
"proc Widget::_test_boolean { option value arg } {\n"
"    if { ![string is boolean -strict $value] } {\n"
"        return -code error \"bad $option value \\\"$value\\\": must be boolean\"\n"
"    }\n"
"\n"
"    # Get the canonical form of the boolean value (1 for true, 0 for false)\n"
"    return [string is true $value]\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command Widget::focusNext\n"
"#  Same as tk_focusNext, but call Widget::focusOK\n"
"# -----------------------------------------------------------------------------\n"
"proc Widget::focusNext { w } {\n"
"    set cur $w\n"
"    while 1 {\n"
"\n"
"	# Descend to just before the first child of the current widget.\n"
"\n"
"	set parent $cur\n"
"	set children [winfo children $cur]\n"
"	set i -1\n"
"\n"
"	# Look for the next sibling that isnt a top-level.\n"
"\n"
"	while 1 {\n"
"	    incr i\n"
"	    if {$i < [llength $children]} {\n"
"		set cur [lindex $children $i]\n"
"		if {[winfo toplevel $cur] == $cur} {\n"
"		    continue\n"
"		} else {\n"
"		    break\n"
"		}\n"
"	    }\n"
"\n"
"	    # No more siblings, so go to the current widget's parent.\n"
"	    # If it's a top-level, break out of the loop, otherwise\n"
"	    # look for its next sibling.\n"
"\n"
"	    set cur $parent\n"
"	    if {[winfo toplevel $cur] == $cur} {\n"
"		break\n"
"	    }\n"
"	    set parent [winfo parent $parent]\n"
"	    set children [winfo children $parent]\n"
"	    set i [lsearch -exact $children $cur]\n"
"	}\n"
"	if {($cur == $w) || [focusOK $cur]} {\n"
"	    return $cur\n"
"	}\n"
"    }\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command Widget::focusPrev\n"
"#  Same as tk_focusPrev, but call Widget::focusOK\n"
"# -----------------------------------------------------------------------------\n"
"proc Widget::focusPrev { w } {\n"
"    set cur $w\n"
"    while 1 {\n"
"\n"
"	# Collect information about the current windows position\n"
"	# among its siblings.  Also, if the window is a top-level,\n"
"	# then reposition to just after the last child of the window.\n"
"    \n"
"	if {[winfo toplevel $cur] == $cur}  {\n"
"	    set parent $cur\n"
"	    set children [winfo children $cur]\n"
"	    set i [llength $children]\n"
"	} else {\n"
"	    set parent [winfo parent $cur]\n"
"	    set children [winfo children $parent]\n"
"	    set i [lsearch -exact $children $cur]\n"
"	}\n"
"\n"
"	# Go to the previous sibling, then descend to its last descendant\n"
"	# (highest in stacking order.  While doing this, ignore top-levels\n"
"	# and their descendants.  When we run out of descendants, go up\n"
"	# one level to the parent.\n"
"\n"
"	while {$i > 0} {\n"
"	    incr i -1\n"
"	    set cur [lindex $children $i]\n"
"	    if {[winfo toplevel $cur] == $cur} {\n"
"		continue\n"
"	    }\n"
"	    set parent $cur\n"
"	    set children [winfo children $parent]\n"
"	    set i [llength $children]\n"
"	}\n"
"	set cur $parent\n"
"	if {($cur == $w) || [focusOK $cur]} {\n"
"	    return $cur\n"
"	}\n"
"    }\n"
"}\n"
"\n"
"\n"
"# ----------------------------------------------------------------------------\n"
"#  Command Widget::focusOK\n"
"#  Same as tk_focusOK, but handles -editable option and whole tags list.\n"
"# ----------------------------------------------------------------------------\n"
"proc Widget::focusOK { w } {\n"
"    set code [catch {$w cget -takefocus} value]\n"
"    if { $code == 1 } {\n"
"        return 0\n"
"    }\n"
"    if {($code == 0) && ($value != \"\")} {\n"
"	if {$value == 0} {\n"
"	    return 0\n"
"	} elseif {$value == 1} {\n"
"	    return [winfo viewable $w]\n"
"	} else {\n"
"	    set value [uplevel \\#0 $value $w]\n"
"            if {$value != \"\"} {\n"
"		return $value\n"
"	    }\n"
"        }\n"
"    }\n"
"    if {![winfo viewable $w]} {\n"
"	return 0\n"
"    }\n"
"    set code [catch {$w cget -state} value]\n"
"    if {($code == 0) && ($value == \"disabled\")} {\n"
"	return 0\n"
"    }\n"
"    set code [catch {$w cget -editable} value]\n"
"    if {($code == 0) && !$value} {\n"
"        return 0\n"
"    }\n"
"\n"
"    set top [winfo toplevel $w]\n"
"    foreach tags [bindtags $w] {\n"
"        if { [string compare $tags $top]  &&\n"
"             [string compare $tags \"all\"] &&\n"
"             [regexp Key [bind $tags]] } {\n"
"            return 1\n"
"        }\n"
"    }\n"
"    return 0\n"
"}\n"
"\n"
"# Widget::varForOption --\n"
"#\n"
"#	Retrieve a fully qualified variable name for the option specified.\n"
"#	If the option is not one for which a variable exists, throw an error \n"
"#	(ie, those options that map directly to widget options).\n"
"#\n"
"# Arguments:\n"
"#	path	megawidget to get an option var for.\n"
"#	option	option to get a var for.\n"
"#\n"
"# Results:\n"
"#	varname	name of the variable, fully qualified, suitable for tracing.\n"
"\n"
"proc Widget::varForOption {path option} {\n"
"    variable _class\n"
"    variable _optiontype\n"
"\n"
"    set class $_class($path)\n"
"    upvar 0 ${class}::$path:opt pathopt\n"
"\n"
"    if { ![info exists pathopt($option)] } {\n"
"	error \"unable to find variable for option \\\"$option\\\"\"\n"
"    }\n"
"    set varname \"::Widget::${class}::$path:opt($option)\"\n"
"    return $varname\n"
"}\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  scrollframe.tcl\n"
"#  This file is part of Unifix BWidget Toolkit\n"
"#  Id\n"
"# ------------------------------------------------------------------------------\n"
"\n"
"namespace eval ScrollableFrame {\n"
"    Widget::declare ScrollableFrame {\n"
"        {-background        TkResource \"\" 0 frame}\n"
"        {-width             Int        0  0 {}}\n"
"        {-height            Int        0  0 {}}\n"
"        {-areawidth         Int        0  0 {}}\n"
"        {-areaheight        Int        0  0 {}}\n"
"        {-constrainedwidth  Boolean    0 0}\n"
"        {-constrainedheight Boolean    0 0}\n"
"        {-xscrollcommand    TkResource \"\" 0 canvas}\n"
"        {-yscrollcommand    TkResource \"\" 0 canvas}\n"
"        {-xscrollincrement  TkResource \"\" 0 canvas}\n"
"        {-yscrollincrement  TkResource \"\" 0 canvas}\n"
"        {-bg                Synonym    -background}\n"
"    }\n"
"\n"
"    Widget::addmap ScrollableFrame \"\" :cmd {\n"
"        -background {} -width {} -height {} \n"
"        -xscrollcommand {} -yscrollcommand {}\n"
"        -xscrollincrement {} -yscrollincrement {}\n"
"    }\n"
"    Widget::addmap ScrollableFrame \"\" .frame {-background {}}\n"
"\n"
"    variable _widget\n"
"\n"
"    bind BwScrollableFrame <Configure> {ScrollableFrame::_resize %W}\n"
"    bind BwScrollableFrame <Destroy>   {Widget::destroy %W; rename %W {}}\n"
"\n"
"    proc ::ScrollableFrame { path args } { return [eval ScrollableFrame::create $path $args] }\n"
"    proc use {} {}\n"
"}\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  Command ScrollableFrame::create\n"
"# ------------------------------------------------------------------------------\n"
"proc ScrollableFrame::create { path args } {\n"
"    Widget::init ScrollableFrame $path $args\n"
"\n"
"    set canvas [eval canvas $path [Widget::subcget $path :cmd] \\\n"
"                    -highlightthickness 0 -borderwidth 0 -relief flat]\n"
"\n"
"    set frame  [eval frame $path.frame [Widget::subcget $path .frame] \\\n"
"                    -highlightthickness 0 -borderwidth 0 -relief flat]\n"
"\n"
"    $canvas create window 0 0 -anchor nw -window $frame -tags win \\\n"
"        -width  [Widget::cget $path -areawidth] \\\n"
"        -height [Widget::cget $path -areaheight]\n"
"\n"
"    bind $frame <Configure> \"$canvas:cmd configure -scrollregion {0 0 %w %h}\"\n"
"    bindtags $path [list $path BwScrollableFrame [winfo toplevel $path] all]\n"
"\n"
"    rename $path ::$path:cmd\n"
"    proc ::$path { cmd args } \"return \\[eval ScrollableFrame::\\$cmd $path \\$args\\]\"\n"
"\n"
"    return $canvas\n"
"}\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  Command ScrollableFrame::configure\n"
"# ------------------------------------------------------------------------------\n"
"proc ScrollableFrame::configure { path args } {\n"
"    set res [Widget::configure $path $args]\n"
"    set upd 0\n"
"\n"
"    set modcw [Widget::hasChanged $path -constrainedwidth cw]\n"
"    set modw  [Widget::hasChanged $path -areawidth w]\n"
"    if { $modcw || (!$cw && $modw) } {\n"
"        if { $cw } {\n"
"            set w [winfo width $path]\n"
"        }\n"
"        set upd 1\n"
"    }\n"
"\n"
"    set modch [Widget::hasChanged $path -constrainedheight ch]\n"
"    set modh  [Widget::hasChanged $path -areaheight h]\n"
"    if { $modch || (!$ch && $modh) } {\n"
"        if { $ch } {\n"
"            set h [winfo height $path]\n"
"        }\n"
"        set upd 1\n"
"    }\n"
"\n"
"    if { $upd } {\n"
"        $path:cmd itemconfigure win -width $w -height $h\n"
"    }\n"
"    return $res\n"
"}\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  Command ScrollableFrame::cget\n"
"# ------------------------------------------------------------------------------\n"
"proc ScrollableFrame::cget { path option } {\n"
"    return [Widget::cget $path $option]\n"
"}\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  Command ScrollableFrame::getframe\n"
"# ------------------------------------------------------------------------------\n"
"proc ScrollableFrame::getframe { path } {\n"
"    return $path.frame\n"
"}\n"
"\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  Command ScrollableFrame::xview\n"
"# ------------------------------------------------------------------------------\n"
"proc ScrollableFrame::xview { path args } {\n"
"    return [eval $path:cmd xview $args]\n"
"}\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  Command ScrollableFrame::yview\n"
"# ------------------------------------------------------------------------------\n"
"proc ScrollableFrame::yview { path args } {\n"
"    return [eval $path:cmd yview $args]\n"
"}\n"
"\n"
"\n"
"# ------------------------------------------------------------------------------\n"
"#  Command ScrollableFrame::_resize\n"
"# ------------------------------------------------------------------------------\n"
"proc ScrollableFrame::_resize { path } {\n"
"    if { [Widget::getoption $path -constrainedwidth] } {\n"
"        $path:cmd itemconfigure win -width [winfo width $path]\n"
"    }\n"
"    if { [Widget::getoption $path -constrainedheight] } {\n"
"        $path:cmd itemconfigure win -height [winfo height $path]\n"
"    }\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  scrollw.tcl\n"
"#  This file is part of Unifix BWidget Toolkit\n"
"#  Id\n"
"# -----------------------------------------------------------------------------\n"
"namespace eval ScrolledWindow {\n"
"    Widget::declare ScrolledWindow {\n"
"        {-background  TkResource \"\"   0 button}\n"
"        {-scrollbar   Enum       both 0 {none both vertical horizontal}}\n"
"        {-auto        Enum       both 0 {none both vertical horizontal}}\n"
"        {-sides       Enum       se   0 {ne en nw wn se es sw ws}}\n"
"        {-size        Int        0    1 \"%d >= 0\"}\n"
"        {-ipad        Int        1    1 \"%d >= 0\"}\n"
"        {-managed     Boolean    1    1}\n"
"        {-relief      TkResource flat 0 frame}\n"
"        {-borderwidth TkResource 0    0 frame}\n"
"        {-bg          Synonym    -background}\n"
"        {-bd          Synonym    -borderwidth}\n"
"    }\n"
"\n"
"    Widget::addmap ScrolledWindow \"\" ._grid.f {-relief {} -borderwidth {}}\n"
"\n"
"    proc ::ScrolledWindow {path args} {\n"
"        return [eval ScrolledWindow::create $path $args]\n"
"    }\n"
"    proc use {} {}\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::create\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::create { path args } {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    Widget::init ScrolledWindow $path $args\n"
"\n"
"    set bg     [Widget::cget $path -background]\n"
"    set sbsize [Widget::cget $path -size]\n"
"    set ipad   [Widget::cget $path -ipad]\n"
"    set sw     [frame $path \\\n"
"                    -relief flat -borderwidth 0 -background $bg \\\n"
"                    -highlightthickness 0 -takefocus 0]\n"
"    set grid   [frame $path._grid \\\n"
"                    -relief flat -borderwidth 0 -background $bg \\\n"
"                    -highlightthickness 0 -takefocus 0]\n"
"    set fv     [frame $grid.vframe \\\n"
"                    -relief flat -borderwidth 0 -background $bg \\\n"
"                    -highlightthickness 0 -takefocus 0]\n"
"    set fh     [frame $grid.hframe \\\n"
"                    -relief flat -borderwidth 0 -background $bg \\\n"
"                    -highlightthickness 0 -takefocus 0]\n"
"    eval frame $grid.f -background $bg -highlightthickness 0 \\\n"
"        [Widget::subcget $path ._grid.f]\n"
"\n"
"    scrollbar $grid.hscroll \\\n"
"        -highlightthickness 0 -takefocus 0 \\\n"
"        -orient  horiz	\\\n"
"        -relief  sunken	\\\n"
"        -bg      $bg\n"
"    scrollbar $grid.vscroll \\\n"
"        -highlightthickness 0 -takefocus 0 \\\n"
"        -orient  vert  	\\\n"
"        -relief  sunken	\\\n"
"        -bg      $bg\n"
"\n"
"    set data(realized) 0\n"
"\n"
"    _setData $path \\\n"
"        [Widget::cget $path -scrollbar] \\\n"
"        [Widget::cget $path -auto] \\\n"
"        [Widget::cget $path -sides]\n"
"\n"
"    if {[Widget::cget $path -managed]} {\n"
"        set data(hsb,packed) $data(hsb,present)\n"
"        set data(vsb,packed) $data(vsb,present)\n"
"    } else {\n"
"        set data(hsb,packed) 0\n"
"        set data(vsb,packed) 0\n"
"    }\n"
"    if {$sbsize} {\n"
"        $grid.vscroll configure -width $sbsize\n"
"        $grid.hscroll configure -width $sbsize\n"
"    } else {\n"
"        set sbsize [$grid.vscroll cget -width]\n"
"    }\n"
"    set size [expr {$sbsize+$ipad}]\n"
"\n"
"    $grid.vframe configure -width  $size\n"
"    $grid.hframe configure -height $size\n"
"    set vplaceopt [list -in $grid.vframe -x [expr {(1-$data(vsb,west))*$ipad}] -y 0 -width [expr {-$ipad}]]\n"
"    set hplaceopt [list -in $grid.hframe -x 0 -y [expr {(1-$data(hsb,north))*$ipad}] -height [expr {-$ipad}]]\n"
"    pack propagate $grid.vframe 0\n"
"    pack propagate $grid.hframe 0\n"
"    pack $grid.vscroll -in $grid.vframe\n"
"    pack $grid.hscroll -in $grid.hframe\n"
"\n"
"    bind $grid.hscroll <Configure> \\\n"
"        \"ScrolledWindow::_setSBSize $grid.hscroll $size -relwidth 1.0 -relheight 1.0 $hplaceopt\"\n"
"    bind $grid.vscroll <Configure> \\\n"
"        \"ScrolledWindow::_setSBSize $grid.vscroll $size -relwidth 1.0 -relheight 1.0 $vplaceopt\"\n"
"\n"
"    grid $grid.hframe \\\n"
"        -column     [expr {$data(vsb,west)*$data(vsb,packed)}] \\\n"
"        -row        [expr {1-$data(hsb,north)}]  \\\n"
"        -columnspan [expr {2-$data(vsb,packed)}] \\\n"
"        -sticky we\n"
"    grid $grid.vframe \\\n"
"        -column  [expr {1-$data(vsb,west)}] \\\n"
"        -row     [expr {$data(hsb,north)*$data(hsb,packed)}] \\\n"
"        -rowspan [expr {2-$data(hsb,packed)}] \\\n"
"        -sticky ns\n"
"\n"
"    grid $grid.f \\\n"
"        -column     [expr {$data(vsb,west)*$data(vsb,packed)}]  \\\n"
"        -row        [expr {$data(hsb,north)*$data(hsb,packed)}] \\\n"
"        -columnspan [expr {2-$data(vsb,packed)}] \\\n"
"        -rowspan    [expr {2-$data(hsb,packed)}] \\\n"
"        -sticky     nwse\n"
"\n"
"    grid columnconfigure $grid $data(vsb,west)  -weight 1\n"
"    grid rowconfigure    $grid $data(hsb,north) -weight 1\n"
"    pack $grid -fill both -expand yes\n"
"\n"
"    bind $grid <Configure> \"ScrolledWindow::_realize $path\"\n"
"    bind $grid <Destroy>   \"ScrolledWindow::_destroy $path\"\n"
"    raise $grid.f\n"
"    rename $path ::$path:cmd\n"
"    proc ::$path { cmd args } \"return \\[eval ScrolledWindow::\\$cmd $path \\$args\\]\"\n"
"\n"
"    return $path\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::getframe\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::getframe { path } {\n"
"    return $path\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::setwidget\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::setwidget { path widget } {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    set grid   $path._grid\n"
"\n"
"    pack $widget -in $grid.f -fill both -expand yes\n"
"\n"
"    $grid.hscroll configure -command \"$widget xview\"\n"
"    $grid.vscroll configure -command \"$widget yview\"\n"
"    $widget configure \\\n"
"        -xscrollcommand \"ScrolledWindow::_set_hscroll $path\" \\\n"
"        -yscrollcommand \"ScrolledWindow::_set_vscroll $path\"\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::configure\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::configure { path args } {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    set grid $path._grid\n"
"    set res [Widget::configure $path $args]\n"
"    if { [Widget::hasChanged $path -background bg] } {\n"
"        $path configure -background $bg\n"
"        $grid configure -background $bg\n"
"        $grid.f configure -background $bg\n"
"        catch {$grid.hscroll configure -background $bg}\n"
"        catch {$grid.vscroll configure -background $bg}\n"
"    }\n"
"\n"
"    if {[Widget::hasChanged $path -scrollbar scrollbar] |\n"
"        [Widget::hasChanged $path -auto      auto]     |\n"
"        [Widget::hasChanged $path -sides     sides]} {\n"
"        _setData $path $scrollbar $auto $sides\n"
"        set hscroll [$grid.hscroll get]\n"
"        set vmin    [lindex $hscroll 0]\n"
"        set vmax    [lindex $hscroll 1]\n"
"        set data(hsb,packed) [expr {$data(hsb,present) &&\n"
"                                    (!$data(hsb,auto) || ($vmin != 0 || $vmax != 1))}]\n"
"        set vscroll [$grid.vscroll get]\n"
"        set vmin    [lindex $vscroll 0]\n"
"        set vmax    [lindex $vscroll 1]\n"
"        set data(vsb,packed) [expr {$data(vsb,present) &&\n"
"                                    (!$data(vsb,auto) || ($vmin != 0 || $vmax != 1))}]\n"
"\n"
"        set ipad [Widget::cget $path -ipad]\n"
"        place configure $grid.vscroll \\\n"
"            -x [expr {(1-$data(vsb,west))*$ipad}]\n"
"        place configure $grid.hscroll \\\n"
"            -y [expr {(1-$data(hsb,north))*$ipad}]\n"
"\n"
"        grid configure $grid.hframe \\\n"
"            -column     [expr {$data(vsb,west)*$data(vsb,packed)}] \\\n"
"            -row        [expr {1-$data(hsb,north)}]  \\\n"
"            -columnspan [expr {2-$data(vsb,packed)}]\n"
"        grid configure $grid.vframe \\\n"
"            -column  [expr {1-$data(vsb,west)}] \\\n"
"            -row     [expr {$data(hsb,north)*$data(hsb,packed)}] \\\n"
"            -rowspan [expr {2-$data(hsb,packed)}]\n"
"        grid configure $grid.f \\\n"
"            -column     [expr {$data(vsb,west)*$data(vsb,packed)}] \\\n"
"            -row        [expr {$data(hsb,north)*$data(hsb,packed)}] \\\n"
"            -columnspan [expr {2-$data(vsb,packed)}] \\\n"
"            -rowspan    [expr {2-$data(hsb,packed)}]\n"
"        grid columnconfigure $grid $data(vsb,west)             -weight 1\n"
"        grid columnconfigure $grid [expr {1-$data(vsb,west)}]  -weight 0\n"
"        grid rowconfigure    $grid $data(hsb,north)            -weight 1\n"
"        grid rowconfigure    $grid [expr {1-$data(hsb,north)}] -weight 0\n"
"    }\n"
"    return $res\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::cget\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::cget { path option } {\n"
"    return [Widget::cget $path $option]\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::_destroy\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::_destroy { path } {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    unset data\n"
"    Widget::destroy $path\n"
"    rename $path {}\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::_set_hscroll\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::_set_hscroll { path vmin vmax } {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    if {$data(realized) && $data(hsb,present)} {\n"
"        set grid $path._grid\n"
"        if {$data(hsb,auto)} {\n"
"            if {$data(hsb,packed) && $vmin == 0 && $vmax == 1} {\n"
"                set data(hsb,packed) 0\n"
"                grid configure $grid.f $grid.vframe -row 0 -rowspan 2\n"
"            } elseif {!$data(hsb,packed) && ($vmin != 0 || $vmax != 1)} {\n"
"                set data(hsb,packed) 1\n"
"                grid configure $grid.f $grid.vframe -row $data(hsb,north) -rowspan 1\n"
"            }\n"
"        }\n"
"	update idletask\n"
"        $grid.hscroll set $vmin $vmax\n"
"    }\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::_set_vscroll\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::_set_vscroll { path vmin vmax } {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    if {$data(realized) && $data(vsb,present)} {\n"
"        set grid $path._grid\n"
"        if {$data(vsb,auto)} {\n"
"            if {$data(vsb,packed) && $vmin == 0 && $vmax == 1} {\n"
"                set data(vsb,packed) 0\n"
"                grid configure $grid.f $grid.hframe -column 0 -columnspan 2\n"
"            } elseif {!$data(vsb,packed) && ($vmin != 0 || $vmax != 1) } {\n"
"                set data(vsb,packed) 1\n"
"                grid configure $grid.f $grid.hframe -column $data(vsb,west) -columnspan 1\n"
"            }\n"
"        }\n"
"	update idletask\n"
"        $grid.vscroll set $vmin $vmax\n"
"    }\n"
"}\n"
"\n"
"\n"
"proc ScrolledWindow::_setData {path scrollbar auto sides} {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    set sb    [lsearch {none horizontal vertical both} $scrollbar]\n"
"    set auto  [lsearch {none horizontal vertical both} $auto]\n"
"    set north [string match *n* $sides]\n"
"    set west  [string match *w* $sides]\n"
"\n"
"    set data(hsb,present)  [expr {($sb & 1) != 0}]\n"
"    set data(hsb,auto)     [expr {($auto & 1) != 0}]\n"
"    set data(hsb,north)    $north\n"
"\n"
"    set data(vsb,present)  [expr {($sb & 2) != 0}]\n"
"    set data(vsb,auto)     [expr {($auto & 2) != 0}]\n"
"    set data(vsb,west)     $west\n"
"}\n"
"\n"
"\n"
"proc ScrolledWindow::_setSBSize {sb size args} {\n"
"    $sb configure -width $size\n"
"    eval place $sb $args\n"
"}\n"
"\n"
"\n"
"# -----------------------------------------------------------------------------\n"
"#  Command ScrolledWindow::_realize\n"
"# -----------------------------------------------------------------------------\n"
"proc ScrolledWindow::_realize { path } {\n"
"    upvar \\#0 ScrolledWindow::$path data\n"
"\n"
"    set grid $path._grid\n"
"    bind $grid <Configure> {}\n"
"    set data(realized) 1\n"
"    place $grid -anchor nw -x 0 -y 0 -relwidth 1.0 -relheight 1.0\n"
"}\n"
"\n";
